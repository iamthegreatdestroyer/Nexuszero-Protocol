<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","benches","comprehensive_benchmarks.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};\r\nuse nexuszero_crypto::lattice::lwe::*;\r\nuse nexuszero_crypto::lattice::ring_lwe::*;\r\nuse nexuszero_crypto::params::security::SecurityLevel;\r\nuse nexuszero_crypto::proof::statement::*;\r\nuse nexuszero_crypto::proof::witness::*;\r\nuse nexuszero_crypto::proof::proof::*;\r\nuse num_bigint::BigUint;\r\nuse rand::thread_rng;\r\n\r\n// ============================================================================\r\n// LWE Benchmarks\r\n// ============================================================================\r\n\r\nfn benchmark_lwe_operations(c: \u0026mut Criterion) {\r\n    let mut group = c.benchmark_group(\"LWE Operations\");\r\n    \r\n    for (name, n, m, q, sigma) in \u0026[\r\n        (\"128-bit\", 256, 512, 12289, 3.2),\r\n        (\"192-bit\", 384, 768, 12289, 3.2),\r\n        (\"256-bit\", 512, 1024, 12289, 3.2),\r\n    ] {\r\n        let params = LWEParameters::new(*n, *m, *q, *sigma);\r\n        let mut rng = thread_rng();\r\n        \r\n        // KeyGen\r\n        group.bench_function(\r\n            BenchmarkId::new(\"KeyGen\", name),\r\n            |b| b.iter(|| {\r\n                let mut rng = thread_rng();\r\n                keygen(black_box(\u0026params), \u0026mut rng)\r\n            })\r\n        );\r\n        \r\n        // Encrypt\r\n        let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n        group.bench_function(\r\n            BenchmarkId::new(\"Encrypt\", name),\r\n            |b| b.iter(|| {\r\n                let mut rng = thread_rng();\r\n                encrypt(black_box(\u0026pk), black_box(true), black_box(\u0026params), \u0026mut rng)\r\n            })\r\n        );\r\n        \r\n        // Decrypt\r\n        let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n        let ct = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n        group.bench_function(\r\n            BenchmarkId::new(\"Decrypt\", name),\r\n            |b| b.iter(|| decrypt(black_box(\u0026sk), black_box(\u0026ct), black_box(\u0026params)))\r\n        );\r\n    }\r\n    \r\n    group.finish();\r\n}\r\n\r\n// ============================================================================\r\n// Ring-LWE Benchmarks\r\n// ============================================================================\r\n\r\nfn benchmark_ring_lwe_operations(c: \u0026mut Criterion) {\r\n    let mut group = c.benchmark_group(\"Ring-LWE Operations\");\r\n    \r\n    for (name, params) in \u0026[\r\n        (\"128-bit\", RingLWEParameters::new_128bit_security()),\r\n        (\"192-bit\", RingLWEParameters::new_192bit_security()),\r\n        (\"256-bit\", RingLWEParameters::new_256bit_security()),\r\n    ] {\r\n        // KeyGen\r\n        group.bench_function(\r\n            BenchmarkId::new(\"KeyGen\", name),\r\n            |b| b.iter(|| ring_keygen(black_box(params)))\r\n        );\r\n        \r\n        // Encrypt\r\n        let (sk, pk) = ring_keygen(params).unwrap();\r\n        let message = vec![true, false, true, false, true];  // 5 bits\r\n        group.bench_function(\r\n            BenchmarkId::new(\"Encrypt\", name),\r\n            |b| b.iter(|| ring_encrypt(black_box(\u0026pk), black_box(\u0026message), black_box(params)))\r\n        );\r\n        \r\n        // Decrypt\r\n        let (sk, pk) = ring_keygen(params).unwrap();\r\n        let message = vec![true, false, true, false, true];\r\n        let ct = ring_encrypt(\u0026pk, \u0026message, params).unwrap();\r\n        group.bench_function(\r\n            BenchmarkId::new(\"Decrypt\", name),\r\n            |b| b.iter(|| ring_decrypt(black_box(\u0026sk), black_box(\u0026ct), black_box(params)))\r\n        );\r\n    }\r\n    \r\n    group.finish();\r\n}\r\n\r\n// ============================================================================\r\n// Polynomial Operations Benchmarks\r\n// ============================================================================\r\n\r\nfn benchmark_polynomial_operations(c: \u0026mut Criterion) {\r\n    let mut group = c.benchmark_group(\"Polynomial Operations\");\r\n    \r\n    let q = 12289u64;\r\n    for degree in \u0026[128, 256, 512, 1024] {\r\n        let poly_a = Polynomial {\r\n            coeffs: vec![1i64; *degree],\r\n            modulus: q,\r\n            degree: *degree,\r\n        };\r\n        let poly_b = Polynomial {\r\n            coeffs: vec![2i64; *degree],\r\n            modulus: q,\r\n            degree: *degree,\r\n        };\r\n        \r\n        // Addition\r\n        group.bench_function(\r\n            BenchmarkId::new(\"Addition\", degree),\r\n            |b| b.iter(|| poly_add(black_box(\u0026poly_a), black_box(\u0026poly_b), q))\r\n        );\r\n        \r\n        // Subtraction\r\n        group.bench_function(\r\n            BenchmarkId::new(\"Subtraction\", degree),\r\n            |b| b.iter(|| poly_sub(black_box(\u0026poly_a), black_box(\u0026poly_b), q))\r\n        );\r\n        \r\n        // Schoolbook Multiplication\r\n        group.bench_function(\r\n            BenchmarkId::new(\"Mult-Schoolbook\", degree),\r\n            |b| b.iter(|| poly_mult_schoolbook(black_box(\u0026poly_a), black_box(\u0026poly_b), q))\r\n        );\r\n        \r\n        // NTT Transform\r\n        let primitive_root = find_primitive_root(*degree, q).unwrap();\r\n        group.bench_function(\r\n            BenchmarkId::new(\"NTT-Forward\", degree),\r\n            |b| b.iter(|| ntt(black_box(\u0026poly_a), q, primitive_root))\r\n        );\r\n    }\r\n    \r\n    group.finish();\r\n}\r\n\r\n// ============================================================================\r\n// Proof System Benchmarks\r\n// ============================================================================\r\n\r\nfn benchmark_proof_operations(c: \u0026mut Criterion) {\r\n    let mut group = c.benchmark_group(\"Proof Operations\");\r\n    \r\n    // Discrete Log Proof Generation\r\n    let generator = vec![2u8; 32];\r\n    let secret = vec![42u8; 32];\r\n    let modulus_bytes = vec![0xFF; 32];\r\n    let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n    let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n    let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n    let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n    \r\n    let statement = StatementBuilder::new()\r\n        .discrete_log(generator, public_value)\r\n        .build()\r\n        .unwrap();\r\n    let witness = Witness::discrete_log(secret);\r\n    \r\n    group.bench_function(\"Discrete-Log-Prove\", |b| {\r\n        b.iter(|| prove(black_box(\u0026statement), black_box(\u0026witness)))\r\n    });\r\n    \r\n    // Discrete Log Proof Verification\r\n    let proof = prove(\u0026statement, \u0026witness).unwrap();\r\n    group.bench_function(\"Discrete-Log-Verify\", |b| {\r\n        b.iter(|| verify(black_box(\u0026statement), black_box(\u0026proof)))\r\n    });\r\n    \r\n    // Preimage Proof\r\n    use sha3::{Digest, Sha3_256};\r\n    let preimage = b\"benchmark_message\".to_vec();\r\n    let mut hasher = Sha3_256::new();\r\n    hasher.update(\u0026preimage);\r\n    let hash = hasher.finalize().to_vec();\r\n    \r\n    let preimage_statement = StatementBuilder::new()\r\n        .preimage(HashFunction::SHA3_256, hash)\r\n        .build()\r\n        .unwrap();\r\n    let preimage_witness = Witness::preimage(preimage);\r\n    \r\n    group.bench_function(\"Preimage-Prove\", |b| {\r\n        b.iter(|| prove(black_box(\u0026preimage_statement), black_box(\u0026preimage_witness)))\r\n    });\r\n    \r\n    let preimage_proof = prove(\u0026preimage_statement, \u0026preimage_witness).unwrap();\r\n    group.bench_function(\"Preimage-Verify\", |b| {\r\n        b.iter(|| verify(black_box(\u0026preimage_statement), black_box(\u0026preimage_proof)))\r\n    });\r\n    \r\n    // Proof Serialization\r\n    group.bench_function(\"Proof-Serialize\", |b| {\r\n        b.iter(|| proof.to_bytes())\r\n    });\r\n    \r\n    // Proof Deserialization\r\n    let serialized = proof.to_bytes().unwrap();\r\n    group.bench_function(\"Proof-Deserialize\", |b| {\r\n        b.iter(|| Proof::from_bytes(black_box(\u0026serialized)))\r\n    });\r\n    \r\n    group.finish();\r\n}\r\n\r\n// ============================================================================\r\n// End-to-End Workflow Benchmarks\r\n// ============================================================================\r\n\r\nfn benchmark_e2e_workflows(c: \u0026mut Criterion) {\r\n    let mut group = c.benchmark_group(\"End-to-End Workflows\");\r\n    \r\n    // Complete LWE encryption workflow\r\n    group.bench_function(\"LWE-Full-Workflow\", |b| {\r\n        b.iter(|| {\r\n            let params = LWEParameters::new(256, 512, 12289, 3.2);\r\n            let mut rng = thread_rng();\r\n            let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n            let ct = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n            let _pt = decrypt(\u0026sk, \u0026ct, \u0026params);\r\n        })\r\n    });\r\n    \r\n    // Complete Ring-LWE encryption workflow\r\n    group.bench_function(\"Ring-LWE-Full-Workflow\", |b| {\r\n        b.iter(|| {\r\n            let params = RingLWEParameters::new_128bit_security();\r\n            let (sk, pk) = ring_keygen(\u0026params).unwrap();\r\n            let message = vec![true, false, true, false, true];\r\n            let ct = ring_encrypt(\u0026pk, \u0026message, \u0026params).unwrap();\r\n            let _dec = ring_decrypt(\u0026sk, \u0026ct, \u0026params);\r\n        })\r\n    });\r\n    \r\n    // Complete proof generation and verification workflow\r\n    group.bench_function(\"Proof-Full-Workflow\", |b| {\r\n        b.iter(|| {\r\n            let generator = vec![2u8; 32];\r\n            let secret = vec![42u8; 32];\r\n            let modulus_bytes = vec![0xFF; 32];\r\n            let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n            let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n            let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n            let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n            \r\n            let statement = StatementBuilder::new()\r\n                .discrete_log(generator, public_value)\r\n                .build()\r\n                .unwrap();\r\n            let witness = Witness::discrete_log(secret);\r\n            let proof = prove(\u0026statement, \u0026witness).unwrap();\r\n            let _result = verify(\u0026statement, \u0026proof);\r\n        })\r\n    });\r\n    \r\n    group.finish();\r\n}\r\n\r\ncriterion_group!(\r\n    benches,\r\n    benchmark_lwe_operations,\r\n    benchmark_ring_lwe_operations,\r\n    benchmark_polynomial_operations,\r\n    benchmark_proof_operations,\r\n    benchmark_e2e_workflows\r\n);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","benches","crypto_benchmarks.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\r\nuse nexuszero_crypto::lattice::{LWEParameters, keygen, encrypt, decrypt};\r\n\r\nfn bench_lwe_encryption(c: \u0026mut Criterion) {\r\n    let params = LWEParameters::new(256, 512, 12289, 3.2);\r\n    let mut rng = rand::thread_rng();\r\n    let (_, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n\r\n    c.bench_function(\"lwe_encrypt_128bit\", |b| {\r\n        b.iter(|| {\r\n            encrypt(black_box(\u0026pk), black_box(true), black_box(\u0026params), black_box(\u0026mut rng))\r\n        });\r\n    });\r\n}\r\n\r\nfn bench_lwe_decryption(c: \u0026mut Criterion) {\r\n    let params = LWEParameters::new(256, 512, 12289, 3.2);\r\n    let mut rng = rand::thread_rng();\r\n    let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n    let ct = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n\r\n    c.bench_function(\"lwe_decrypt_128bit\", |b| {\r\n        b.iter(|| {\r\n            decrypt(black_box(\u0026sk), black_box(\u0026ct), black_box(\u0026params))\r\n        });\r\n    });\r\n}\r\n\r\ncriterion_group!(benches, bench_lwe_encryption, bench_lwe_decryption);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","examples","parameter_selection.rs"],"content":"/// Example: Advanced Parameter Selection\r\n/// \r\n/// Demonstrates the ParameterSelector with various configurations:\r\n/// - Basic parameter generation for different security levels\r\n/// - Custom constraints (dimension, modulus ranges)\r\n/// - Prime modulus selection using Miller-Rabin\r\n/// - Security level estimation\r\n\r\nuse nexuszero_crypto::{\r\n    params::{ParameterSelector, SecurityLevel, is_prime_miller_rabin, generate_prime},\r\n    CryptoResult,\r\n};\r\n\r\nfn main() -\u003e CryptoResult\u003c()\u003e {\r\n    println!(\"=== NexusZero Parameter Selection Examples ===\\n\");\r\n\r\n    // Example 1: Basic LWE parameter selection\r\n    basic_lwe_selection()?;\r\n\r\n    // Example 2: Basic Ring-LWE parameter selection\r\n    basic_ring_lwe_selection()?;\r\n\r\n    // Example 3: Custom constraints\r\n    custom_constraints()?;\r\n\r\n    // Example 4: Prime modulus selection\r\n    prime_modulus_selection()?;\r\n\r\n    // Example 5: Security estimation\r\n    security_estimation();\r\n\r\n    // Example 6: Primality testing\r\n    primality_testing();\r\n\r\n    // Example 7: Prime generation\r\n    prime_generation()?;\r\n\r\n    Ok(())\r\n}\r\n\r\nfn basic_lwe_selection() -\u003e CryptoResult\u003c()\u003e {\r\n    println!(\"=== Example 1: Basic LWE Parameter Selection ===\");\r\n    \r\n    for \u0026security_level in \u0026[SecurityLevel::Bit128, SecurityLevel::Bit192, SecurityLevel::Bit256] {\r\n        let selector = ParameterSelector::new()\r\n            .target_security(security_level);\r\n        \r\n        let params = selector.build_lwe()?;\r\n        \r\n        println!(\"Security Level: {:?}\", security_level);\r\n        println!(\"  n (dimension): {}\", params.n);\r\n        println!(\"  m (samples):   {}\", params.m);\r\n        println!(\"  q (modulus):   {}\", params.q);\r\n        println!(\"  σ (sigma):     {:.2}\", params.sigma);\r\n        \r\n        // Estimate actual security\r\n        let estimated_security = ParameterSelector::estimate_security(\r\n            params.n, \r\n            params.q, \r\n            params.sigma\r\n        );\r\n        println!(\"  Estimated security: {} bits\\n\", estimated_security);\r\n    }\r\n    \r\n    Ok(())\r\n}\r\n\r\nfn basic_ring_lwe_selection() -\u003e CryptoResult\u003c()\u003e {\r\n    println!(\"=== Example 2: Basic Ring-LWE Parameter Selection ===\");\r\n    \r\n    for \u0026security_level in \u0026[SecurityLevel::Bit128, SecurityLevel::Bit192, SecurityLevel::Bit256] {\r\n        let selector = ParameterSelector::new()\r\n            .target_security(security_level);\r\n        \r\n        let params = selector.build_ring_lwe()?;\r\n        \r\n        println!(\"Security Level: {:?}\", security_level);\r\n        println!(\"  n (degree):    {}\", params.n);\r\n        println!(\"  q (modulus):   {}\", params.q);\r\n        println!(\"  σ (sigma):     {:.2}\", params.sigma);\r\n        println!(\"  Power of 2:    {}\", params.n.is_power_of_two());\r\n        \r\n        let estimated_security = ParameterSelector::estimate_security(\r\n            params.n, \r\n            params.q, \r\n            params.sigma\r\n        );\r\n        println!(\"  Estimated security: {} bits\\n\", estimated_security);\r\n    }\r\n    \r\n    Ok(())\r\n}\r\n\r\nfn custom_constraints() -\u003e CryptoResult\u003c()\u003e {\r\n    println!(\"=== Example 3: Custom Constraints ===\");\r\n    \r\n    // Scenario: Need at least 512-bit dimension but no more than 1024\r\n    let selector = ParameterSelector::new()\r\n        .target_security(SecurityLevel::Bit128)\r\n        .min_dimension(512)\r\n        .max_dimension(1024);\r\n    \r\n    let params = selector.build_lwe()?;\r\n    \r\n    println!(\"Constrained LWE Parameters:\");\r\n    println!(\"  n (dimension): {} (within [512, 1024])\", params.n);\r\n    println!(\"  m (samples):   {}\", params.m);\r\n    println!(\"  q (modulus):   {}\", params.q);\r\n    println!(\"  σ (sigma):     {:.2}\\n\", params.sigma);\r\n    \r\n    // Scenario: Custom m/n ratio\r\n    let selector = ParameterSelector::new()\r\n        .target_security(SecurityLevel::Bit128)\r\n        .custom_ratio(3.0); // More samples for extra security\r\n    \r\n    let params = selector.build_lwe()?;\r\n    \r\n    println!(\"Custom Ratio (m/n = 3.0):\");\r\n    println!(\"  n: {}\", params.n);\r\n    println!(\"  m: {} (3× dimension)\", params.m);\r\n    println!(\"  Ratio: {:.2}\\n\", params.m as f64 / params.n as f64);\r\n    \r\n    Ok(())\r\n}\r\n\r\nfn prime_modulus_selection() -\u003e CryptoResult\u003c()\u003e {\r\n    println!(\"=== Example 4: Prime Modulus Selection ===\");\r\n    \r\n    // Without prime preference\r\n    let selector = ParameterSelector::new()\r\n        .target_security(SecurityLevel::Bit128);\r\n    \r\n    let params = selector.build_lwe()?;\r\n    \r\n    println!(\"Standard modulus:\");\r\n    println!(\"  q: {}\", params.q);\r\n    println!(\"  Is prime: {}\\n\", is_prime_miller_rabin(params.q, 20));\r\n    \r\n    // With prime preference\r\n    let selector = ParameterSelector::new()\r\n        .target_security(SecurityLevel::Bit128)\r\n        .prefer_prime_modulus(true);\r\n    \r\n    let params = selector.build_lwe()?;\r\n    \r\n    println!(\"Prime modulus:\");\r\n    println!(\"  q: {}\", params.q);\r\n    println!(\"  Is prime: {} (verified with Miller-Rabin)\\n\", \r\n        is_prime_miller_rabin(params.q, 20));\r\n    \r\n    Ok(())\r\n}\r\n\r\nfn security_estimation() {\r\n    println!(\"=== Example 5: Security Estimation ===\");\r\n    \r\n    // Compare different parameter sets\r\n    let test_cases = vec![\r\n        (256, 12289, 3.2, \"Small (128-bit target)\"),\r\n        (384, 16411, 3.8, \"Medium (192-bit target)\"),\r\n        (512, 20483, 4.0, \"Large (256-bit target)\"),\r\n        (1024, 40961, 4.5, \"Extra Large\"),\r\n    ];\r\n    \r\n    for (n, q, sigma, description) in test_cases {\r\n        let security = ParameterSelector::estimate_security(n, q, sigma);\r\n        println!(\"{}\", description);\r\n        println!(\"  Parameters: n={}, q={}, σ={:.1}\", n, q, sigma);\r\n        println!(\"  Estimated security: {} bits\\n\", security);\r\n    }\r\n}\r\n\r\nfn primality_testing() {\r\n    println!(\"=== Example 6: Primality Testing (Miller-Rabin) ===\");\r\n    \r\n    let test_numbers = vec![\r\n        (2, \"Small prime\"),\r\n        (97, \"Two-digit prime\"),\r\n        (541, \"Three-digit prime\"),\r\n        (7919, \"Four-digit prime\"),\r\n        (12289, \"Common in lattice crypto\"),\r\n        (100, \"Composite\"),\r\n        (1001, \"Composite (7 × 11 × 13)\"),\r\n    ];\r\n    \r\n    for (n, description) in test_numbers {\r\n        let is_prime = is_prime_miller_rabin(n, 20);\r\n        let result = if is_prime { \"PRIME\" } else { \"COMPOSITE\" };\r\n        println!(\"{:5} - {} [{}]\", n, description, result);\r\n    }\r\n    println!();\r\n}\r\n\r\nfn prime_generation() -\u003e CryptoResult\u003c()\u003e {\r\n    println!(\"=== Example 7: Prime Generation ===\");\r\n    \r\n    for bit_length in \u0026[10, 12, 14, 16] {\r\n        let prime = generate_prime(*bit_length)?;\r\n        let min = 1u64 \u003c\u003c (bit_length - 1);\r\n        let max = (1u64 \u003c\u003c bit_length) - 1;\r\n        \r\n        println!(\"{}-bit prime: {}\", bit_length, prime);\r\n        println!(\"  Range: [{}, {}]\", min, max);\r\n        println!(\"  Verified: {}\\n\", is_prime_miller_rabin(prime, 20));\r\n    }\r\n    \r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","lattice","lwe.rs"],"content":"//! Learning With Errors (LWE) primitives\r\n//!\r\n//! This module implements the LWE cryptographic scheme, which forms\r\n//! the security foundation for quantum-resistant cryptography.\r\n\r\nuse crate::{CryptoError, CryptoResult, LatticeParameters};\r\nuse ndarray::{Array1, Array2};\r\nuse rand::{CryptoRng, Rng};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// LWE parameters defining security and operational characteristics\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct LWEParameters {\r\n    /// Dimension (security parameter)\r\n    pub n: usize,\r\n    /// Number of samples\r\n    pub m: usize,\r\n    /// Modulus\r\n    pub q: u64,\r\n    /// Error distribution standard deviation\r\n    pub sigma: f64,\r\n}\r\n\r\nimpl LWEParameters {\r\n    /// Create new LWE parameters\r\n    pub fn new(n: usize, m: usize, q: u64, sigma: f64) -\u003e Self {\r\n        Self { n, m, q, sigma }\r\n    }\r\n}\r\n\r\nimpl LatticeParameters for LWEParameters {\r\n    fn dimension(\u0026self) -\u003e usize {\r\n        self.n\r\n    }\r\n\r\n    fn modulus(\u0026self) -\u003e u64 {\r\n        self.q\r\n    }\r\n\r\n    fn sigma(\u0026self) -\u003e f64 {\r\n        self.sigma\r\n    }\r\n\r\n    fn validate(\u0026self) -\u003e CryptoResult\u003c()\u003e {\r\n        if self.n == 0 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Dimension must be positive\".to_string(),\r\n            ));\r\n        }\r\n        if self.m == 0 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Number of samples must be positive\".to_string(),\r\n            ));\r\n        }\r\n        if self.q \u003c 2 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Modulus must be at least 2\".to_string(),\r\n            ));\r\n        }\r\n        if self.sigma \u003c= 0.0 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Sigma must be positive\".to_string(),\r\n            ));\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n/// LWE public key\r\n#[derive(Clone, Debug)]\r\npub struct LWEPublicKey {\r\n    /// Random matrix A (m × n)\r\n    pub a: Array2\u003ci64\u003e,\r\n    /// Vector b = As + e (m-dimensional)\r\n    pub b: Array1\u003ci64\u003e,\r\n}\r\n\r\n/// LWE secret key\r\n#[derive(Clone, Debug)]\r\npub struct LWESecretKey {\r\n    /// Secret vector s (n-dimensional)\r\n    pub s: Array1\u003ci64\u003e,\r\n}\r\n\r\n/// LWE ciphertext\r\n#[derive(Clone, Debug)]\r\npub struct LWECiphertext {\r\n    /// Ciphertext component u\r\n    pub u: Array1\u003ci64\u003e,\r\n    /// Ciphertext component v\r\n    pub v: i64,\r\n}\r\n\r\n/// Generate LWE key pair\r\npub fn keygen\u003cR: Rng + CryptoRng\u003e(\r\n    params: \u0026LWEParameters,\r\n    rng: \u0026mut R,\r\n) -\u003e CryptoResult\u003c(LWESecretKey, LWEPublicKey)\u003e {\r\n    params.validate()?;\r\n\r\n    // Generate secret key s\r\n    let s = sample_secret(params.n, params.q, rng);\r\n\r\n    // Generate random matrix A\r\n    let a = sample_matrix(params.m, params.n, params.q, rng);\r\n\r\n    // Generate error vector e\r\n    let e = crate::lattice::sampling::sample_error(params.sigma, params.m);\r\n\r\n    // Compute b = As + e (mod q)\r\n    let as_product = a.dot(\u0026s);\r\n    let b = as_product\r\n        .iter()\r\n        .zip(e.iter())\r\n        .map(|(as_i, e_i)| (as_i + e_i).rem_euclid(params.q as i64))\r\n        .collect::\u003cArray1\u003ci64\u003e\u003e();\r\n\r\n    let sk = LWESecretKey { s };\r\n    let pk = LWEPublicKey { a, b };\r\n\r\n    Ok((sk, pk))\r\n}\r\n\r\n/// Encrypt a message bit\r\npub fn encrypt\u003cR: Rng + CryptoRng\u003e(\r\n    pk: \u0026LWEPublicKey,\r\n    message: bool,\r\n    params: \u0026LWEParameters,\r\n    rng: \u0026mut R,\r\n) -\u003e CryptoResult\u003cLWECiphertext\u003e {\r\n    // Sample random vector r\r\n    let r = sample_binary_vector(params.m, rng);\r\n\r\n    // Compute u = A^T r (mod q)\r\n    let u = pk\r\n        .a\r\n        .t()\r\n        .dot(\u0026r)\r\n        .mapv(|x| x.rem_euclid(params.q as i64));\r\n\r\n    // Encode message (0 -\u003e 0, 1 -\u003e q/2)\r\n    let encoded_msg = if message { (params.q / 2) as i64 } else { 0 };\r\n\r\n    // Compute v = b^T r + encoded_msg (mod q)\r\n    let v = (pk.b.dot(\u0026r) + encoded_msg).rem_euclid(params.q as i64);\r\n\r\n    Ok(LWECiphertext { u, v })\r\n}\r\n\r\n/// Decrypt a ciphertext\r\npub fn decrypt(\r\n    sk: \u0026LWESecretKey,\r\n    ct: \u0026LWECiphertext,\r\n    params: \u0026LWEParameters,\r\n) -\u003e CryptoResult\u003cbool\u003e {\r\n    // Compute m' = v - s^T u (mod q)\r\n    let m_prime = (ct.v - sk.s.dot(\u0026ct.u)).rem_euclid(params.q as i64);\r\n\r\n    // Decode: if m' is closer to q/2 than to 0, message is 1\r\n    let _threshold = (params.q / 4) as i64;\r\n    let distance_to_zero = m_prime.min(params.q as i64 - m_prime);\r\n    let distance_to_half = (m_prime - (params.q / 2) as i64)\r\n        .abs()\r\n        .min((params.q / 2) as i64);\r\n\r\n    Ok(distance_to_half \u003c distance_to_zero)\r\n}\r\n\r\n// Helper functions\r\n\r\nfn sample_secret\u003cR: Rng + CryptoRng\u003e(n: usize, q: u64, rng: \u0026mut R) -\u003e Array1\u003ci64\u003e {\r\n    Array1::from_shape_fn(n, |_| rng.gen_range(0..q) as i64)\r\n}\r\n\r\nfn sample_matrix\u003cR: Rng + CryptoRng\u003e(\r\n    m: usize,\r\n    n: usize,\r\n    q: u64,\r\n    rng: \u0026mut R,\r\n) -\u003e Array2\u003ci64\u003e {\r\n    Array2::from_shape_fn((m, n), |_| rng.gen_range(0..q) as i64)\r\n}\r\n\r\nfn sample_binary_vector\u003cR: Rng + CryptoRng\u003e(m: usize, rng: \u0026mut R) -\u003e Array1\u003ci64\u003e {\r\n    Array1::from_shape_fn(m, |_| if rng.gen_bool(0.5) { 1 } else { 0 })\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_lwe_parameters_validation() {\r\n        let params = LWEParameters::new(256, 512, 12289, 3.2);\r\n        assert!(params.validate().is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn test_lwe_encrypt_decrypt() {\r\n        let params = LWEParameters::new(32, 64, 97, 2.0);\r\n        let mut rng = rand::thread_rng();\r\n\r\n        let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n\r\n        // Test encrypting false\r\n        let ct_false = encrypt(\u0026pk, false, \u0026params, \u0026mut rng).unwrap();\r\n        let decrypted_false = decrypt(\u0026sk, \u0026ct_false, \u0026params).unwrap();\r\n        assert_eq!(decrypted_false, false);\r\n\r\n        // Test encrypting true\r\n        let ct_true = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n        let decrypted_true = decrypt(\u0026sk, \u0026ct_true, \u0026params).unwrap();\r\n        assert_eq!(decrypted_true, true);\r\n    }\r\n    \r\n    #[test]\r\n    fn test_keygen_with_various_parameters() {\r\n        let mut rng = rand::thread_rng();\r\n        \r\n        // Test with minimal parameters\r\n        let params = LWEParameters::new(8, 16, 11, 1.0);\r\n        let result = keygen(\u0026params, \u0026mut rng);\r\n        assert!(result.is_ok());\r\n        \r\n        // Test with large parameters\r\n        let params = LWEParameters::new(512, 1024, 40961, 5.0);\r\n        let result = keygen(\u0026params, \u0026mut rng);\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn test_decrypt_edge_values() {\r\n        // Test decryption with reliable parameters\r\n        let params = LWEParameters::new(64, 128, 257, 2.0);\r\n        let mut rng = rand::thread_rng();\r\n        let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n        \r\n        // Test multiple encryptions and decryptions\r\n        for _ in 0..10 {\r\n            let ct_false = encrypt(\u0026pk, false, \u0026params, \u0026mut rng).unwrap();\r\n            let ct_true = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n            \r\n            assert_eq!(decrypt(\u0026sk, \u0026ct_false, \u0026params).unwrap(), false);\r\n            assert_eq!(decrypt(\u0026sk, \u0026ct_true, \u0026params).unwrap(), true);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_lwe_with_small_modulus() {\r\n        // Test with small but secure modulus\r\n        let params = LWEParameters::new(32, 64, 127, 1.5);\r\n        let mut rng = rand::thread_rng();\r\n        \r\n        let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n        let ct = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n        let decrypted = decrypt(\u0026sk, \u0026ct, \u0026params).unwrap();\r\n        assert_eq!(decrypted, true);\r\n        \r\n        // Test false as well\r\n        let ct_false = encrypt(\u0026pk, false, \u0026params, \u0026mut rng).unwrap();\r\n        let decrypted_false = decrypt(\u0026sk, \u0026ct_false, \u0026params).unwrap();\r\n        assert_eq!(decrypted_false, false);\r\n    }\r\n\r\n    #[test]\r\n    fn test_error_distribution_statistical_properties() {\r\n        use crate::lattice::sampling::sample_error;\r\n        let sigma = 3.2;\r\n        let n = 1000;\r\n        \r\n        // Sample error vector\r\n        let samples = sample_error(sigma, n);\r\n        \r\n        // Check mean is close to 0\r\n        let mean: f64 = samples.iter().map(|\u0026x| x as f64).sum::\u003cf64\u003e() / n as f64;\r\n        assert!(mean.abs() \u003c 1.0, \"Mean should be close to 0: {}\", mean);\r\n        \r\n        // Check standard deviation is close to sigma\r\n        let variance: f64 = samples.iter().map(|\u0026x| {\r\n            let x_f = x as f64;\r\n            (x_f - mean).powi(2)\r\n        }).sum::\u003cf64\u003e() / n as f64;\r\n        let std_dev = variance.sqrt();\r\n        assert!((std_dev - sigma).abs() \u003c 1.0, \"Std dev should be close to {}: {}\", sigma, std_dev);\r\n        \r\n        // Check distribution is roughly bell-shaped (most values within 3 sigma)\r\n        let within_3sigma = samples.iter().filter(|\u0026\u0026x| (x as f64).abs() \u003c= 3.0 * sigma).count();\r\n        let ratio = within_3sigma as f64 / n as f64;\r\n        assert!(ratio \u003e 0.95, \"At least 95% of samples should be within 3 sigma: {}\", ratio);\r\n    }\r\n\r\n    #[test]\r\n    fn test_error_magnitude_bounds() {\r\n        use crate::lattice::sampling::sample_error;\r\n        let sigma = 2.0;\r\n        \r\n        // Sample error vector and check all values are bounded\r\n        for _ in 0..10 {\r\n            let errors = sample_error(sigma, 100);\r\n            for \u0026error in errors.iter() {\r\n                // In practice, errors beyond 6*sigma are extremely rare\r\n                let error_f = (error as f64).abs();\r\n                assert!(error_f \u003c 6.0 * sigma, \"Error magnitude too large: {}\", error_f);\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_lwe_invalid_parameters() {\r\n        // Zero dimension\r\n        let params = LWEParameters::new(0, 64, 97, 2.0);\r\n        assert!(params.validate().is_err());\r\n        \r\n        // Zero samples\r\n        let params = LWEParameters::new(32, 0, 97, 2.0);\r\n        assert!(params.validate().is_err());\r\n        \r\n        // Invalid modulus\r\n        let params = LWEParameters::new(32, 64, 1, 2.0);\r\n        assert!(params.validate().is_err());\r\n        \r\n        // Negative/zero sigma\r\n        let params = LWEParameters::new(32, 64, 97, 0.0);\r\n        assert!(params.validate().is_err());\r\n        \r\n        let params = LWEParameters::new(32, 64, 97, -1.0);\r\n        assert!(params.validate().is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_encryption_produces_different_ciphertexts() {\r\n        let params = LWEParameters::new(32, 64, 97, 2.0);\r\n        let mut rng = rand::thread_rng();\r\n        let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n        \r\n        // Encrypt same message multiple times\r\n        let ct1 = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n        let ct2 = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n        \r\n        // Ciphertexts should be different (probabilistic encryption)\r\n        let same_u = ct1.u.iter().zip(ct2.u.iter()).all(|(a, b)| a == b);\r\n        let same_v = ct1.v == ct2.v;\r\n        assert!(!(same_u \u0026\u0026 same_v), \"Ciphertexts should differ due to randomness\");\r\n        \r\n        // But both decrypt to the same plaintext\r\n        assert_eq!(decrypt(\u0026sk, \u0026ct1, \u0026params).unwrap(), true);\r\n        assert_eq!(decrypt(\u0026sk, \u0026ct2, \u0026params).unwrap(), true);\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":45,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":47,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":50,"address":[],"length":0,"stats":{"Line":3098476543630901247}},{"line":51,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":52,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":55,"address":[],"length":0,"stats":{"Line":3026418949592973311}},{"line":56,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":57,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":60,"address":[],"length":0,"stats":{"Line":2954361355555045375}},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":62,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":65,"address":[],"length":0,"stats":{"Line":2810246167479189503}},{"line":95,"address":[],"length":0,"stats":{"Line":1441151880758558721}},{"line":99,"address":[],"length":0,"stats":{"Line":2882303761517117443}},{"line":102,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":105,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":108,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":111,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":112,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":114,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":115,"address":[],"length":0,"stats":{"Line":14123288431433876383}},{"line":118,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":119,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":121,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":125,"address":[],"length":0,"stats":{"Line":3314649325744685061}},{"line":132,"address":[],"length":0,"stats":{"Line":13258597302978740244}},{"line":135,"address":[],"length":0,"stats":{"Line":9943947977234055183}},{"line":136,"address":[],"length":0,"stats":{"Line":6629298651489370122}},{"line":138,"address":[],"length":0,"stats":{"Line":3314649325744685061}},{"line":139,"address":[],"length":0,"stats":{"Line":14843864371813156543}},{"line":142,"address":[],"length":0,"stats":{"Line":9943947977234055183}},{"line":145,"address":[],"length":0,"stats":{"Line":1441151880758558750}},{"line":147,"address":[],"length":0,"stats":{"Line":3314649325744685061}},{"line":151,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":157,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":160,"address":[],"length":0,"stats":{"Line":6629298651489370112}},{"line":161,"address":[],"length":0,"stats":{"Line":13258597302978740224}},{"line":162,"address":[],"length":0,"stats":{"Line":6629298651489370112}},{"line":164,"address":[],"length":0,"stats":{"Line":6629298651489370112}},{"line":166,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":171,"address":[],"length":0,"stats":{"Line":1441151880758558726}},{"line":172,"address":[],"length":0,"stats":{"Line":9223372036855357988}},{"line":175,"address":[],"length":0,"stats":{"Line":1441151880758558722}},{"line":181,"address":[],"length":0,"stats":{"Line":12105675798371893252}},{"line":184,"address":[],"length":0,"stats":{"Line":3314649325744687161}},{"line":185,"address":[],"length":0,"stats":{"Line":6629298651489375470}}],"covered":51,"coverable":55},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","lattice","mod.rs"],"content":"//! Lattice-based cryptographic primitives\r\n//!\r\n//! This module provides implementations of:\r\n//! - Learning With Errors (LWE)\r\n//! - Ring Learning With Errors (Ring-LWE)\r\n//! - Error sampling from discrete Gaussian distributions\r\n\r\npub mod lwe;\r\npub mod ring_lwe;\r\npub mod sampling;\r\n\r\n// Re-export main types\r\npub use lwe::{LWECiphertext, LWEParameters, LWEPublicKey, LWESecretKey};\r\npub use ring_lwe::{\r\n    Polynomial, RingLWECiphertext, RingLWEParameters, RingLWEPublicKey, RingLWESecretKey,\r\n};\r\npub use sampling::{sample_error, sample_uniform};\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","lattice","ring_lwe.rs"],"content":"//! Ring Learning With Errors (Ring-LWE) primitives\r\n//!\r\n//! This module implements Ring-LWE, a more efficient variant of LWE\r\n//! that operates in polynomial rings.\r\n\r\nuse crate::{CryptoError, CryptoResult, LatticeParameters};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// Polynomial in the ring Z_q[X]/(X^n + 1)\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct Polynomial {\r\n    /// Coefficients [a_0, a_1, ..., a_{n-1}]\r\n    pub coeffs: Vec\u003ci64\u003e,\r\n    /// Degree (must be power of 2)\r\n    pub degree: usize,\r\n    /// Coefficient modulus\r\n    pub modulus: u64,\r\n}\r\n\r\nimpl Polynomial {\r\n    /// Create a polynomial from coefficients\r\n    pub fn from_coeffs(coeffs: Vec\u003ci64\u003e, modulus: u64) -\u003e Self {\r\n        let degree = coeffs.len();\r\n        Self {\r\n            coeffs,\r\n            degree,\r\n            modulus,\r\n        }\r\n    }\r\n\r\n    /// Create a zero polynomial\r\n    pub fn zero(degree: usize, modulus: u64) -\u003e Self {\r\n        Self {\r\n            coeffs: vec![0; degree],\r\n            degree,\r\n            modulus,\r\n        }\r\n    }\r\n}\r\n\r\n/// Ring-LWE parameters\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct RingLWEParameters {\r\n    /// Polynomial degree (must be power of 2)\r\n    pub n: usize,\r\n    /// Coefficient modulus\r\n    pub q: u64,\r\n    /// Error distribution standard deviation\r\n    pub sigma: f64,\r\n}\r\n\r\nimpl RingLWEParameters {\r\n    /// Create new Ring-LWE parameters\r\n    pub fn new(n: usize, q: u64, sigma: f64) -\u003e Self {\r\n        Self { n, q, sigma }\r\n    }\r\n\r\n    /// Standard 128-bit security parameters\r\n    pub fn new_128bit_security() -\u003e Self {\r\n        Self {\r\n            n: 512,\r\n            q: 12289,\r\n            sigma: 3.2,\r\n        }\r\n    }\r\n\r\n    /// Standard 192-bit security parameters\r\n    pub fn new_192bit_security() -\u003e Self {\r\n        Self {\r\n            n: 1024,\r\n            q: 40961,\r\n            sigma: 3.2,\r\n        }\r\n    }\r\n\r\n    /// Standard 256-bit security parameters\r\n    pub fn new_256bit_security() -\u003e Self {\r\n        Self {\r\n            n: 2048,\r\n            q: 65537,\r\n            sigma: 3.2,\r\n        }\r\n    }\r\n}\r\n\r\nimpl LatticeParameters for RingLWEParameters {\r\n    fn dimension(\u0026self) -\u003e usize {\r\n        self.n\r\n    }\r\n\r\n    fn modulus(\u0026self) -\u003e u64 {\r\n        self.q\r\n    }\r\n\r\n    fn sigma(\u0026self) -\u003e f64 {\r\n        self.sigma\r\n    }\r\n\r\n    fn validate(\u0026self) -\u003e CryptoResult\u003c()\u003e {\r\n        if !self.n.is_power_of_two() {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Dimension must be power of 2\".to_string(),\r\n            ));\r\n        }\r\n        if self.q \u003c 2 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Modulus must be at least 2\".to_string(),\r\n            ));\r\n        }\r\n        if self.sigma \u003c= 0.0 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Sigma must be positive\".to_string(),\r\n            ));\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n/// Ring-LWE public key\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct RingLWEPublicKey {\r\n    /// Random polynomial a\r\n    pub a: Polynomial,\r\n    /// Polynomial b = a*s + e\r\n    pub b: Polynomial,\r\n}\r\n\r\n/// Ring-LWE secret key\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct RingLWESecretKey {\r\n    /// Secret polynomial s\r\n    pub s: Polynomial,\r\n}\r\n\r\n/// Ring-LWE ciphertext\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct RingLWECiphertext {\r\n    /// Ciphertext component u = a*r + e1\r\n    pub u: Polynomial,\r\n    /// Ciphertext component v = b*r + e2 + encode(m)\r\n    pub v: Polynomial,\r\n}\r\n\r\n// ============================================================================\r\n// Polynomial Arithmetic Operations\r\n// ============================================================================\r\n\r\nuse rand::Rng;\r\nuse super::sampling::sample_error;\r\n\r\n/// Polynomial addition in R_q\r\npub fn poly_add(a: \u0026Polynomial, b: \u0026Polynomial, q: u64) -\u003e Polynomial {\r\n    assert_eq!(a.degree, b.degree, \"Polynomials must have same degree\");\r\n    \r\n    let coeffs: Vec\u003ci64\u003e = a.coeffs\r\n        .iter()\r\n        .zip(b.coeffs.iter())\r\n        .map(|(\u0026ai, \u0026bi)| (ai + bi).rem_euclid(q as i64))\r\n        .collect();\r\n    \r\n    Polynomial::from_coeffs(coeffs, q)\r\n}\r\n\r\n/// Polynomial subtraction in R_q\r\npub fn poly_sub(a: \u0026Polynomial, b: \u0026Polynomial, q: u64) -\u003e Polynomial {\r\n    assert_eq!(a.degree, b.degree, \"Polynomials must have same degree\");\r\n    \r\n    let coeffs: Vec\u003ci64\u003e = a.coeffs\r\n        .iter()\r\n        .zip(b.coeffs.iter())\r\n        .map(|(\u0026ai, \u0026bi)| (ai - bi).rem_euclid(q as i64))\r\n        .collect();\r\n    \r\n    Polynomial::from_coeffs(coeffs, q)\r\n}\r\n\r\n/// Scalar multiplication\r\npub fn poly_scalar_mult(poly: \u0026Polynomial, scalar: i64, q: u64) -\u003e Polynomial {\r\n    let coeffs: Vec\u003ci64\u003e = poly.coeffs\r\n        .iter()\r\n        .map(|\u0026c| ((c as i128 * scalar as i128) % q as i128) as i64)\r\n        .collect();\r\n    \r\n    Polynomial::from_coeffs(coeffs, q)\r\n}\r\n\r\n/// Sample polynomial with coefficients from error distribution\r\npub fn sample_poly_error(n: usize, sigma: f64, q: u64) -\u003e Polynomial {\r\n    let errors = sample_error(sigma, n);\r\n    let coeffs: Vec\u003ci64\u003e = errors\r\n        .iter()\r\n        .map(|\u0026e| e.rem_euclid(q as i64))\r\n        .collect();\r\n    \r\n    Polynomial::from_coeffs(coeffs, q)\r\n}\r\n\r\n/// Sample uniform random polynomial in R_q\r\npub fn sample_poly_uniform(n: usize, q: u64) -\u003e Polynomial {\r\n    let mut rng = rand::thread_rng();\r\n    let coeffs: Vec\u003ci64\u003e = (0..n)\r\n        .map(|_| rng.gen_range(0..q as i64))\r\n        .collect();\r\n    \r\n    Polynomial::from_coeffs(coeffs, q)\r\n}\r\n\r\n// ============================================================================\r\n// Number Theoretic Transform (NTT) Implementation\r\n// ============================================================================\r\n\r\n/// Find primitive nth root of unity mod q\r\n/// For NTT, we need q ≡ 1 (mod 2n) and ω^n ≡ -1 (mod q)\r\npub fn find_primitive_root(n: usize, q: u64) -\u003e Option\u003cu64\u003e {\r\n    // Known roots for common parameter sets\r\n    if q == 12289 {\r\n        if n == 512 { return Some(49); }\r\n        else if n == 256 { return Some(2401); }\r\n    } else if q == 40961 \u0026\u0026 n == 1024 {\r\n        return Some(3);\r\n    } else if q == 65537 \u0026\u0026 n == 2048 {\r\n        return Some(3);\r\n    }\r\n    \r\n    // General case: search for primitive root\r\n    for candidate in 2..std::cmp::min(1000, q) {\r\n        if is_primitive_root(candidate, n, q) {\r\n            return Some(candidate);\r\n        }\r\n    }\r\n    \r\n    None\r\n}\r\n\r\n/// Check if omega is a primitive 2n-th root of unity mod q\r\nfn is_primitive_root(omega: u64, n: usize, q: u64) -\u003e bool {\r\n    // ω^n ≡ -1 (mod q)\r\n    let half_order = mod_exp(omega, n as u64, q);\r\n    if half_order != q - 1 {\r\n        return false;\r\n    }\r\n    \r\n    // ω^(2n) ≡ 1 (mod q)\r\n    let full_order = mod_exp(omega, (2 * n) as u64, q);\r\n    full_order == 1\r\n}\r\n\r\n/// Modular exponentiation: base^exp mod modulus\r\nfn mod_exp(mut base: u64, mut exp: u64, modulus: u64) -\u003e u64 {\r\n    let mut result = 1u64;\r\n    base %= modulus;\r\n    \r\n    while exp \u003e 0 {\r\n        if exp % 2 == 1 {\r\n            result = ((result as u128 * base as u128) % modulus as u128) as u64;\r\n        }\r\n        exp \u003e\u003e= 1;\r\n        base = ((base as u128 * base as u128) % modulus as u128) as u64;\r\n    }\r\n    \r\n    result\r\n}\r\n\r\n/// Number Theoretic Transform (NTT) - Forward transform\r\n/// Implements Cooley-Tukey FFT-style algorithm for NTT\r\npub fn ntt(poly: \u0026Polynomial, q: u64, primitive_root: u64) -\u003e Vec\u003ci64\u003e {\r\n    let n = poly.degree;\r\n    assert!(n.is_power_of_two(), \"Degree must be power of 2 for NTT\");\r\n    \r\n    let mut result = poly.coeffs.clone();\r\n    let mut len = 1;\r\n    \r\n    while len \u003c n {\r\n        let step = n / (len * 2);\r\n        let mut k = 0;\r\n        \r\n        while k \u003c n {\r\n            let omega = mod_exp(primitive_root, step as u64, q);\r\n            let mut omega_pow = 1u64;\r\n            \r\n            for j in 0..len {\r\n                let u = result[k + j];\r\n                let v = ((result[k + j + len] as i128 * omega_pow as i128) \r\n                        % q as i128) as i64;\r\n                \r\n                result[k + j] = (u + v).rem_euclid(q as i64);\r\n                result[k + j + len] = (u - v).rem_euclid(q as i64);\r\n                \r\n                omega_pow = ((omega_pow as u128 * omega as u128) % q as u128) as u64;\r\n            }\r\n            \r\n            k += len * 2;\r\n        }\r\n        \r\n        len *= 2;\r\n    }\r\n    \r\n    result\r\n}\r\n\r\n/// Inverse Number Theoretic Transform (INTT)\r\npub fn intt(transformed: \u0026[i64], n: usize, q: u64, primitive_root: u64) -\u003e Polynomial {\r\n    assert!(n.is_power_of_two(), \"Size must be power of 2 for INTT\");\r\n    \r\n    // Find inverse of primitive root\r\n    let omega_inv = mod_inverse(primitive_root as i64, q as i64) as u64;\r\n    \r\n    // Apply NTT with inverse root\r\n    let mut result = transformed.to_vec();\r\n    let mut len = n / 2;\r\n    \r\n    while len \u003e 0 {\r\n        let step = n / (len * 2);\r\n        let mut k = 0;\r\n        \r\n        while k \u003c n {\r\n            let omega = mod_exp(omega_inv, step as u64, q);\r\n            let mut omega_pow = 1u64;\r\n            \r\n            for j in 0..len {\r\n                let u = result[k + j];\r\n                let v = result[k + j + len];\r\n                \r\n                result[k + j] = (u + v).rem_euclid(q as i64);\r\n                \r\n                let diff = (u - v).rem_euclid(q as i64);\r\n                result[k + j + len] = ((diff as i128 * omega_pow as i128) \r\n                                       % q as i128) as i64;\r\n                \r\n                omega_pow = ((omega_pow as u128 * omega as u128) % q as u128) as u64;\r\n            }\r\n            \r\n            k += len * 2;\r\n        }\r\n        \r\n        len /= 2;\r\n    }\r\n    \r\n    // Divide by n\r\n    let n_inv = mod_inverse(n as i64, q as i64);\r\n    for coeff in result.iter_mut() {\r\n        *coeff = ((*coeff as i128 * n_inv as i128) % q as i128) as i64;\r\n    }\r\n    \r\n    Polynomial::from_coeffs(result, q)\r\n}\r\n\r\n/// Modular multiplicative inverse using extended Euclidean algorithm\r\nfn mod_inverse(a: i64, m: i64) -\u003e i64 {\r\n    let (gcd, x, _) = extended_gcd(a, m);\r\n    assert_eq!(gcd, 1, \"Modular inverse does not exist\");\r\n    (x % m + m) % m\r\n}\r\n\r\n/// Extended Euclidean algorithm\r\nfn extended_gcd(a: i64, b: i64) -\u003e (i64, i64, i64) {\r\n    if a == 0 {\r\n        return (b, 0, 1);\r\n    }\r\n    let (gcd, x1, y1) = extended_gcd(b % a, a);\r\n    let x = y1 - (b / a) * x1;\r\n    let y = x1;\r\n    (gcd, x, y)\r\n}\r\n\r\n/// Polynomial multiplication in R_q = Z_q[X]/(X^n + 1) using schoolbook method\r\n/// This is a simple O(n^2) implementation. NTT can be added later for O(n log n)\r\npub fn poly_mult_schoolbook(a: \u0026Polynomial, b: \u0026Polynomial, q: u64) -\u003e Polynomial {\r\n    assert_eq!(a.degree, b.degree, \"Polynomials must have same degree\");\r\n    let n = a.degree;\r\n    \r\n    // Result has degree 2n-2 before reduction\r\n    let mut result = vec![0i128; 2 * n - 1];\r\n    \r\n    // Multiply coefficients\r\n    for i in 0..n {\r\n        for j in 0..n {\r\n            result[i + j] += a.coeffs[i] as i128 * b.coeffs[j] as i128;\r\n        }\r\n    }\r\n    \r\n    // Reduce by X^n + 1: X^(n+k) = -X^k\r\n    let mut reduced = vec![0i64; n];\r\n    for i in 0..n {\r\n        reduced[i] = (result[i] % q as i128) as i64;\r\n    }\r\n    for i in n..(2*n-1) {\r\n        let k = i - n;\r\n        reduced[k] = ((reduced[k] as i128 - result[i]) % q as i128) as i64;\r\n    }\r\n    \r\n    // Normalize to [0, q)\r\n    for i in 0..n {\r\n        reduced[i] = ((reduced[i] % q as i64) + q as i64) % q as i64;\r\n    }\r\n    \r\n    Polynomial::from_coeffs(reduced, q)\r\n}\r\n\r\n/// Fast polynomial multiplication using NTT\r\n/// Complexity: O(n log n) vs O(n²) for naive multiplication\r\n/// Note: NTT implementation needs debugging, using schoolbook for now\r\npub fn poly_mult_ntt(a: \u0026Polynomial, b: \u0026Polynomial, q: u64) -\u003e Polynomial {\r\n    // TODO: Fix NTT implementation\r\n    // For now, use schoolbook multiplication\r\n    poly_mult_schoolbook(a, b, q)\r\n}\r\n\r\n// ============================================================================\r\n// Message Encoding/Decoding\r\n// ============================================================================\r\n\r\n/// Encode message bits into polynomial coefficients\r\n/// Each bit is scaled to q/2 for robust decryption\r\npub fn encode_message(message: \u0026[bool], n: usize, q: u64) -\u003e Polynomial {\r\n    let scale = q / 2;\r\n    let mut coeffs = vec![0i64; n];\r\n    \r\n    for (i, \u0026bit) in message.iter().enumerate().take(n) {\r\n        coeffs[i] = if bit { scale as i64 } else { 0 };\r\n    }\r\n    \r\n    Polynomial::from_coeffs(coeffs, q)\r\n}\r\n\r\n/// Decode polynomial coefficients back to message bits\r\n/// Decoding uses rounding: if coefficient is closer to q/2 than to 0, it's a 1\r\npub fn decode_message(poly: \u0026Polynomial) -\u003e Vec\u003cbool\u003e {\r\n    let q = poly.modulus;\r\n    let quarter = q / 4;\r\n    \r\n    poly.coeffs\r\n        .iter()\r\n        .map(|\u0026c| {\r\n            // Normalize to [0, q)\r\n            let val = ((c % (q as i64)) + (q as i64)) as u64 % q;\r\n            // Check if closer to q/2 than to 0 or q\r\n            val \u003e= quarter \u0026\u0026 val \u003c (3 * quarter)\r\n        })\r\n        .collect()\r\n}\r\n\r\n// ============================================================================\r\n// Ring-LWE Cryptographic Operations\r\n// ============================================================================\r\n\r\n/// Generate Ring-LWE key pair\r\npub fn ring_keygen(params: \u0026RingLWEParameters) -\u003e CryptoResult\u003c(RingLWESecretKey, RingLWEPublicKey)\u003e {\r\n    params.validate()?;\r\n    \r\n    // Sample secret polynomial s with small coefficients\r\n    let s = sample_poly_error(params.n, params.sigma, params.q);\r\n    \r\n    // Sample random polynomial a\r\n    let a = sample_poly_uniform(params.n, params.q);\r\n    \r\n    // Sample error e\r\n    let e = sample_poly_error(params.n, params.sigma, params.q);\r\n    \r\n    // Compute b = a*s + e (mod q, mod X^n+1)\r\n    let as_prod = poly_mult_ntt(\u0026a, \u0026s, params.q);\r\n    let b = poly_add(\u0026as_prod, \u0026e, params.q);\r\n    \r\n    let sk = RingLWESecretKey { s };\r\n    let pk = RingLWEPublicKey { a, b };\r\n    \r\n    Ok((sk, pk))\r\n}\r\n\r\n/// Encrypt message bits using Ring-LWE\r\npub fn ring_encrypt(\r\n    pk: \u0026RingLWEPublicKey,\r\n    message: \u0026[bool],\r\n    params: \u0026RingLWEParameters,\r\n) -\u003e CryptoResult\u003cRingLWECiphertext\u003e {\r\n    params.validate()?;\r\n    \r\n    if message.len() \u003e params.n {\r\n        return Err(CryptoError::InvalidParameter(\r\n            format!(\"Message too long: {} bits, max {}\", message.len(), params.n),\r\n        ));\r\n    }\r\n    \r\n    // Sample ephemeral random polynomial r\r\n    let r = sample_poly_error(params.n, params.sigma, params.q);\r\n    \r\n    // Sample error polynomials e1, e2\r\n    let e1 = sample_poly_error(params.n, params.sigma, params.q);\r\n    let e2 = sample_poly_error(params.n, params.sigma, params.q);\r\n    \r\n    // Encode message\r\n    let m_poly = encode_message(message, params.n, params.q);\r\n    \r\n    // Compute u = a*r + e1\r\n    let ar_prod = poly_mult_ntt(\u0026pk.a, \u0026r, params.q);\r\n    let u = poly_add(\u0026ar_prod, \u0026e1, params.q);\r\n    \r\n    // Compute v = b*r + e2 + m\r\n    let br_prod = poly_mult_ntt(\u0026pk.b, \u0026r, params.q);\r\n    let br_e2 = poly_add(\u0026br_prod, \u0026e2, params.q);\r\n    let v = poly_add(\u0026br_e2, \u0026m_poly, params.q);\r\n    \r\n    Ok(RingLWECiphertext { u, v })\r\n}\r\n\r\n/// Decrypt Ring-LWE ciphertext\r\npub fn ring_decrypt(\r\n    sk: \u0026RingLWESecretKey,\r\n    ct: \u0026RingLWECiphertext,\r\n    params: \u0026RingLWEParameters,\r\n) -\u003e CryptoResult\u003cVec\u003cbool\u003e\u003e {\r\n    params.validate()?;\r\n    \r\n    // Compute m' = v - u*s\r\n    let us_prod = poly_mult_ntt(\u0026ct.u, \u0026sk.s, params.q);\r\n    let m_noisy = poly_sub(\u0026ct.v, \u0026us_prod, params.q);\r\n    \r\n    // Decode message bits\r\n    let message = decode_message(\u0026m_noisy);\r\n    \r\n    Ok(message)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_ring_lwe_parameters() {\r\n        let params = RingLWEParameters::new_128bit_security();\r\n        assert!(params.validate().is_ok());\r\n        assert_eq!(params.n, 512);\r\n    }\r\n\r\n    #[test]\r\n    fn test_polynomial_creation() {\r\n        let poly = Polynomial::zero(512, 12289);\r\n        assert_eq!(poly.degree, 512);\r\n        assert_eq!(poly.coeffs.len(), 512);\r\n    }\r\n\r\n    #[test]\r\n    fn test_polynomial_arithmetic() {\r\n        let q = 12289;\r\n        let a = Polynomial::from_coeffs(vec![1, 2, 3, 4], q);\r\n        let b = Polynomial::from_coeffs(vec![5, 6, 7, 8], q);\r\n        \r\n        // Test addition\r\n        let c = poly_add(\u0026a, \u0026b, q);\r\n        assert_eq!(c.coeffs, vec![6, 8, 10, 12]);\r\n        \r\n        // Test subtraction\r\n        let d = poly_sub(\u0026b, \u0026a, q);\r\n        assert_eq!(d.coeffs, vec![4, 4, 4, 4]);\r\n        \r\n        // Test scalar multiplication\r\n        let e = poly_scalar_mult(\u0026a, 3, q);\r\n        assert_eq!(e.coeffs, vec![3, 6, 9, 12]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_ntt_primitive_root() {\r\n        // Test known primitive roots\r\n        let root_512 = find_primitive_root(512, 12289);\r\n        assert!(root_512.is_some());\r\n        \r\n        let omega = root_512.unwrap();\r\n        // Verify ω^512 ≡ -1 (mod 12289)\r\n        let half_order = mod_exp(omega, 512, 12289);\r\n        assert_eq!(half_order, 12288); // q - 1 = -1 mod q\r\n        \r\n        // Verify ω^1024 ≡ 1 (mod 12289)\r\n        let full_order = mod_exp(omega, 1024, 12289);\r\n        assert_eq!(full_order, 1);\r\n    }\r\n\r\n    #[test]\r\n    fn test_ntt_intt_correctness() {\r\n        let q = 12289;\r\n        let n = 512;\r\n        \r\n        // Create test polynomial\r\n        let coeffs: Vec\u003ci64\u003e = (0..n).map(|i| (i % 100) as i64).collect();\r\n        let poly = Polynomial::from_coeffs(coeffs.clone(), q);\r\n        \r\n        // Find primitive root\r\n        let root = find_primitive_root(n, q).unwrap();\r\n        \r\n        // Transform and inverse transform\r\n        let transformed = ntt(\u0026poly, q, root);\r\n        let recovered = intt(\u0026transformed, n, q, root);\r\n        \r\n        // Verify we get back original coefficients\r\n        for (i, (\u0026orig, \u0026rec)) in coeffs.iter().zip(recovered.coeffs.iter()).enumerate() {\r\n            assert_eq!(\r\n                orig, rec,\r\n                \"Coefficient {} mismatch: original {} != recovered {}\",\r\n                i, orig, rec\r\n            );\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_ntt_multiplication() {\r\n        let q = 12289;\r\n        let n = 512; // Use standard parameter size\r\n        \r\n        // Create two simple polynomials\r\n        let mut a_coeffs = vec![0i64; n];\r\n        let mut b_coeffs = vec![0i64; n];\r\n        a_coeffs[0] = 1;\r\n        a_coeffs[1] = 2;\r\n        b_coeffs[0] = 3;\r\n        b_coeffs[1] = 4;\r\n        \r\n        let a = Polynomial::from_coeffs(a_coeffs, q);\r\n        let b = Polynomial::from_coeffs(b_coeffs, q);\r\n        \r\n        // Multiply using NTT\r\n        let c = poly_mult_ntt(\u0026a, \u0026b, q);\r\n        \r\n        // (1 + 2x) * (3 + 4x) = 3 + 10x + 8x^2 in normal multiplication\r\n        // In ring R_q, this should match\r\n        assert_eq!(c.coeffs[0], 3);  // Constant term\r\n        assert_eq!(c.coeffs[1], 10); // x term\r\n        assert_eq!(c.coeffs[2], 8);  // x^2 term\r\n    }\r\n\r\n    #[test]\r\n    fn test_message_encoding_decoding() {\r\n        let q = 12289;\r\n        let n = 512;\r\n        \r\n        // Test message\r\n        let message = vec![true, false, true, true, false];\r\n        \r\n        // Encode and decode\r\n        let poly = encode_message(\u0026message, n, q);\r\n        let decoded = decode_message(\u0026poly);\r\n        \r\n        // Verify first 5 bits match\r\n        assert_eq!(\u0026decoded[0..5], \u0026message[..]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_keygen() {\r\n        let params = RingLWEParameters::new_128bit_security();\r\n        let result = ring_keygen(\u0026params);\r\n        \r\n        assert!(result.is_ok());\r\n        let (sk, pk) = result.unwrap();\r\n        \r\n        // Verify key dimensions\r\n        assert_eq!(sk.s.degree, params.n);\r\n        assert_eq!(pk.a.degree, params.n);\r\n        assert_eq!(pk.b.degree, params.n);\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_encrypt_decrypt() {\r\n        let params = RingLWEParameters::new_128bit_security();\r\n        let (sk, pk) = ring_keygen(\u0026params).unwrap();\r\n        \r\n        // Test message\r\n        let message = vec![true, false, true, true, false, true, false, false];\r\n        \r\n        // Encrypt\r\n        let ct = ring_encrypt(\u0026pk, \u0026message, \u0026params).unwrap();\r\n        \r\n        // Decrypt\r\n        let decrypted = ring_decrypt(\u0026sk, \u0026ct, \u0026params).unwrap();\r\n        \r\n        // Verify decryption correctness (first message.len() bits)\r\n        assert_eq!(\u0026decrypted[0..message.len()], \u0026message[..]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_multiple_messages() {\r\n        let params = RingLWEParameters::new_128bit_security();\r\n        let (sk, pk) = ring_keygen(\u0026params).unwrap();\r\n        \r\n        // Test multiple different messages\r\n        let messages = vec![\r\n            vec![true; 10],\r\n            vec![false; 10],\r\n            vec![true, false, true, false, true, false],\r\n        ];\r\n        \r\n        for message in messages {\r\n            let ct = ring_encrypt(\u0026pk, \u0026message, \u0026params).unwrap();\r\n            let decrypted = ring_decrypt(\u0026sk, \u0026ct, \u0026params).unwrap();\r\n            \r\n            assert_eq!(\u0026decrypted[0..message.len()], \u0026message[..]);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_error_handling() {\r\n        let params = RingLWEParameters::new_128bit_security();\r\n        let (_, pk) = ring_keygen(\u0026params).unwrap();\r\n        \r\n        // Message too long\r\n        let long_message = vec![true; params.n + 1];\r\n        let result = ring_encrypt(\u0026pk, \u0026long_message, \u0026params);\r\n        \r\n        assert!(result.is_err());\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":1152921504606848712}},{"line":23,"address":[],"length":0,"stats":{"Line":3458764513820546136}},{"line":32,"address":[],"length":0,"stats":{"Line":216172782113783835}},{"line":34,"address":[],"length":0,"stats":{"Line":648518346341351505}},{"line":54,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":59,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":68,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":77,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":100,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":101,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":102,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":105,"address":[],"length":0,"stats":{"Line":3819052484010180611}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":110,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":152,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":153,"address":[],"length":0,"stats":{"Line":5476377146882523126}},{"line":155,"address":[],"length":0,"stats":{"Line":16429131440647569438}},{"line":157,"address":[],"length":0,"stats":{"Line":10952754293765046292}},{"line":158,"address":[],"length":0,"stats":{"Line":6269010681299730451}},{"line":161,"address":[],"length":0,"stats":{"Line":16429131440647569438}},{"line":165,"address":[],"length":0,"stats":{"Line":1152921504606846986}},{"line":166,"address":[],"length":0,"stats":{"Line":1152921504606846995}},{"line":168,"address":[],"length":0,"stats":{"Line":3458764513820540931}},{"line":170,"address":[],"length":0,"stats":{"Line":2305843009213693954}},{"line":171,"address":[],"length":0,"stats":{"Line":2882303761517124137}},{"line":174,"address":[],"length":0,"stats":{"Line":3458764513820540931}},{"line":178,"address":[],"length":0,"stats":{"Line":144115188075855873}},{"line":179,"address":[],"length":0,"stats":{"Line":432345564227567619}},{"line":181,"address":[],"length":0,"stats":{"Line":720575940379279916}},{"line":184,"address":[],"length":0,"stats":{"Line":432345564227567619}},{"line":188,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":189,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":190,"address":[],"length":0,"stats":{"Line":14267403619509731328}},{"line":192,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":195,"address":[],"length":0,"stats":{"Line":14267403619509731328}},{"line":199,"address":[],"length":0,"stats":{"Line":864691128455135237}},{"line":200,"address":[],"length":0,"stats":{"Line":1729382256910270474}},{"line":201,"address":[],"length":0,"stats":{"Line":2594073385365405711}},{"line":202,"address":[],"length":0,"stats":{"Line":864691128455143490}},{"line":205,"address":[],"length":0,"stats":{"Line":2594073385365405711}},{"line":214,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":216,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":217,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":4539628424389459970}},{"line":227,"address":[],"length":0,"stats":{"Line":17582052945254416384}},{"line":228,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":238,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":239,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":240,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":244,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":245,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":249,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":250,"address":[],"length":0,"stats":{"Line":10088063165309911040}},{"line":251,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":253,"address":[],"length":0,"stats":{"Line":12970366926827028495}},{"line":254,"address":[],"length":0,"stats":{"Line":16357073846609641633}},{"line":255,"address":[],"length":0,"stats":{"Line":5044031582654955666}},{"line":257,"address":[],"length":0,"stats":{"Line":11313042263954685967}},{"line":258,"address":[],"length":0,"stats":{"Line":11313042263954685967}},{"line":261,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":266,"address":[],"length":0,"stats":{"Line":432345564227567631}},{"line":267,"address":[],"length":0,"stats":{"Line":864691128455135262}},{"line":268,"address":[],"length":0,"stats":{"Line":1297036692682702908}},{"line":270,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":271,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":273,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":274,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":275,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":277,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":278,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":279,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":281,"address":[],"length":0,"stats":{"Line":4179340454199820304}},{"line":282,"address":[],"length":0,"stats":{"Line":6917529027641081888}},{"line":283,"address":[],"length":0,"stats":{"Line":6917529027641081888}},{"line":284,"address":[],"length":0,"stats":{"Line":3458764513820540944}},{"line":286,"address":[],"length":0,"stats":{"Line":8646911284551352360}},{"line":287,"address":[],"length":0,"stats":{"Line":8646911284551352360}},{"line":289,"address":[],"length":0,"stats":{"Line":1729382256910270472}},{"line":292,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":295,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":298,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":302,"address":[],"length":0,"stats":{"Line":288230376151711786}},{"line":303,"address":[],"length":0,"stats":{"Line":864691128455135400}},{"line":306,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":309,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":310,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":312,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":313,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":314,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":316,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":317,"address":[],"length":0,"stats":{"Line":17005592192950992896}},{"line":318,"address":[],"length":0,"stats":{"Line":17870283321406128128}},{"line":320,"address":[],"length":0,"stats":{"Line":18158513697557839888}},{"line":321,"address":[],"length":0,"stats":{"Line":32}},{"line":322,"address":[],"length":0,"stats":{"Line":32}},{"line":324,"address":[],"length":0,"stats":{"Line":40}},{"line":326,"address":[],"length":0,"stats":{"Line":40}},{"line":327,"address":[],"length":0,"stats":{"Line":32}},{"line":328,"address":[],"length":0,"stats":{"Line":16}},{"line":330,"address":[],"length":0,"stats":{"Line":8}},{"line":333,"address":[],"length":0,"stats":{"Line":18158513697557839872}},{"line":336,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":340,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":341,"address":[],"length":0,"stats":{"Line":576460752303423572}},{"line":342,"address":[],"length":0,"stats":{"Line":42}},{"line":345,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":349,"address":[],"length":0,"stats":{"Line":576460752303423496}},{"line":350,"address":[],"length":0,"stats":{"Line":2305843009213693984}},{"line":351,"address":[],"length":0,"stats":{"Line":576460752303423504}},{"line":352,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":356,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":357,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":358,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":360,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":361,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":362,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":363,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":368,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":369,"address":[],"length":0,"stats":{"Line":3963167672086036476}},{"line":370,"address":[],"length":0,"stats":{"Line":7926335344172072968}},{"line":373,"address":[],"length":0,"stats":{"Line":11889503016258109452}},{"line":376,"address":[],"length":0,"stats":{"Line":3963167672086036484}},{"line":377,"address":[],"length":0,"stats":{"Line":4428}},{"line":378,"address":[],"length":0,"stats":{"Line":8856}},{"line":383,"address":[],"length":0,"stats":{"Line":11889503016258109452}},{"line":384,"address":[],"length":0,"stats":{"Line":3963167672088502592}},{"line":385,"address":[],"length":0,"stats":{"Line":2466108}},{"line":387,"address":[],"length":0,"stats":{"Line":4428}},{"line":388,"address":[],"length":0,"stats":{"Line":6557241057451448806}},{"line":389,"address":[],"length":0,"stats":{"Line":6557241057451448806}},{"line":393,"address":[],"length":0,"stats":{"Line":3963167672086040896}},{"line":394,"address":[],"length":0,"stats":{"Line":4412}},{"line":397,"address":[],"length":0,"stats":{"Line":11889503016258109452}},{"line":403,"address":[],"length":0,"stats":{"Line":3963167672086038694}},{"line":406,"address":[],"length":0,"stats":{"Line":15852670688344154776}},{"line":415,"address":[],"length":0,"stats":{"Line":1080863910568919044}},{"line":416,"address":[],"length":0,"stats":{"Line":2161727821137838088}},{"line":417,"address":[],"length":0,"stats":{"Line":3242591731706757132}},{"line":419,"address":[],"length":0,"stats":{"Line":12898309332789100558}},{"line":420,"address":[],"length":0,"stats":{"Line":11817445422220181502}},{"line":423,"address":[],"length":0,"stats":{"Line":3242591731706757132}},{"line":428,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":429,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":430,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":432,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":434,"address":[],"length":0,"stats":{"Line":1080863910568919583}},{"line":436,"address":[],"length":0,"stats":{"Line":1086}},{"line":438,"address":[],"length":0,"stats":{"Line":13186539708940813388}},{"line":448,"address":[],"length":0,"stats":{"Line":864691128455135233}},{"line":449,"address":[],"length":0,"stats":{"Line":1729382256910270467}},{"line":452,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":455,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":458,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":461,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":462,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":464,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":465,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":467,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":471,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":476,"address":[],"length":0,"stats":{"Line":2161727821137838081}},{"line":478,"address":[],"length":0,"stats":{"Line":2161727821137838078}},{"line":479,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":480,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":485,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":488,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":489,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":492,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":495,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":496,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":499,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":500,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":501,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":503,"address":[],"length":0,"stats":{"Line":1008806316530991103}},{"line":507,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":512,"address":[],"length":0,"stats":{"Line":2017612633061982209}},{"line":515,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":516,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":519,"address":[],"length":0,"stats":{"Line":3026418949592973309}},{"line":521,"address":[],"length":0,"stats":{"Line":1008806316530991103}}],"covered":185,"coverable":197},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","lattice","sampling.rs"],"content":"//! Error sampling from discrete Gaussian distributions\r\n//!\r\n//! This module implements sampling from discrete Gaussian distributions,\r\n//! which is crucial for LWE security.\r\n\r\nuse ndarray::Array1;\r\nuse rand::Rng;\r\n\r\n/// Sample error vector from discrete Gaussian distribution\r\n///\r\n/// Uses Box-Muller transform to generate continuous Gaussian,\r\n/// then rounds to nearest integer for discrete Gaussian.\r\npub fn sample_error(sigma: f64, dimension: usize) -\u003e Array1\u003ci64\u003e {\r\n    let mut rng = rand::thread_rng();\r\n    Array1::from_shape_fn(dimension, |_| sample_gaussian_int(sigma, \u0026mut rng))\r\n}\r\n\r\n/// Sample a single integer from discrete Gaussian\r\nfn sample_gaussian_int\u003cR: Rng\u003e(sigma: f64, rng: \u0026mut R) -\u003e i64 {\r\n    // Box-Muller transform for continuous Gaussian\r\n    let u1: f64 = rng.gen();\r\n    let u2: f64 = rng.gen();\r\n\r\n    let z = (-2.0 * u1.ln()).sqrt() * (2.0 * std::f64::consts::PI * u2).cos();\r\n    let scaled = z * sigma;\r\n\r\n    // Round to nearest integer\r\n    scaled.round() as i64\r\n}\r\n\r\n/// Sample uniform random values\r\npub fn sample_uniform(min: i64, max: i64, dimension: usize) -\u003e Array1\u003ci64\u003e {\r\n    let mut rng = rand::thread_rng();\r\n    Array1::from_shape_fn(dimension, |_| rng.gen_range(min..max))\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_error_sampling() {\r\n        let errors = sample_error(3.2, 1000);\r\n\r\n        // Check dimension\r\n        assert_eq!(errors.len(), 1000);\r\n\r\n        // Compute empirical mean (should be close to 0)\r\n        let mean: f64 = errors.iter().map(|\u0026x| x as f64).sum::\u003cf64\u003e() / 1000.0;\r\n        assert!(mean.abs() \u003c 1.0, \"Mean {} too far from 0\", mean);\r\n\r\n        // Compute empirical standard deviation (should be close to sigma)\r\n        let variance: f64 = errors\r\n            .iter()\r\n            .map(|\u0026x| {\r\n                let diff = x as f64 - mean;\r\n                diff * diff\r\n            })\r\n            .sum::\u003cf64\u003e()\r\n            / 1000.0;\r\n        let std_dev = variance.sqrt();\r\n        assert!(\r\n            (std_dev - 3.2).abs() \u003c 0.5,\r\n            \"Std dev {} too far from 3.2\",\r\n            std_dev\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_uniform_sampling() {\r\n        let values = sample_uniform(0, 100, 1000);\r\n        assert_eq!(values.len(), 1000);\r\n\r\n        // All values should be in range [0, 100)\r\n        for \u0026val in values.iter() {\r\n            assert!(val \u003e= 0 \u0026\u0026 val \u003c 100);\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":14,"address":[],"length":0,"stats":{"Line":14123288431433875456}},{"line":15,"address":[],"length":0,"stats":{"Line":11240984669916758022}},{"line":19,"address":[],"length":0,"stats":{"Line":5188146770730814734}},{"line":21,"address":[],"length":0,"stats":{"Line":2305843009213707320}},{"line":22,"address":[],"length":0,"stats":{"Line":2305843009213707320}},{"line":24,"address":[],"length":0,"stats":{"Line":2305843009213707320}},{"line":25,"address":[],"length":0,"stats":{"Line":10376293541461629468}},{"line":28,"address":[],"length":0,"stats":{"Line":5188146770730814734}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927942}},{"line":33,"address":[],"length":0,"stats":{"Line":144115188075855884}},{"line":34,"address":[],"length":0,"stats":{"Line":13402712491054606134}}],"covered":12,"coverable":12},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","lib.rs"],"content":"//! Nexuszero Crypto - Quantum-Resistant Zero-Knowledge Proof System\n//!\n//! This library provides lattice-based cryptographic primitives for building\n//! zero-knowledge proof systems that are resistant to quantum attacks.\n//!\n//! # Features\n//!\n//! - **LWE Encryption**: Learning With Errors based encryption\n//! - **Ring-LWE**: Efficient ring-based variant with NTT optimization\n//! - **Zero-Knowledge Proofs**: Statement/Witness/Proof system\n//! - **Parameter Selection**: Automatic security parameter optimization\n//!\n//! # Example\n//!\n//! ```rust,no_run\n//! use nexuszero_crypto::{SecurityLevel, CryptoParameters};\n//!\n//! // Select security parameters\n//! let params = CryptoParameters::from_security_level(SecurityLevel::Bit128);\n//!\n//! // Create statement and witness (examples to be implemented)\n//! // let statement = ...;\n//! // let witness = ...;\n//! // let proof = prove(\u0026statement, \u0026witness, \u0026params)?;\n//! // verify(\u0026statement, \u0026proof, \u0026params)?;\n//! ```\n\n#![warn(missing_docs)]\n#![warn(clippy::all)]\n\npub mod lattice;\npub mod params;\npub mod proof;\npub mod utils;\n\n// Re-export commonly used types\npub use params::{CryptoParameters, SecurityLevel};\n\n/// Custom error type for cryptographic operations\n#[derive(Debug, thiserror::Error)]\npub enum CryptoError {\n    /// Invalid security parameter\n    #[error(\"Invalid security parameter: {0}\")]\n    InvalidParameter(String),\n\n    /// Encryption/Decryption error\n    #[error(\"Encryption error: {0}\")]\n    EncryptionError(String),\n\n    /// Proof generation error\n    #[error(\"Proof generation failed: {0}\")]\n    ProofError(String),\n\n    /// Verification error\n    #[error(\"Verification failed: {0}\")]\n    VerificationError(String),\n\n    /// Serialization error\n    #[error(\"Serialization error: {0}\")]\n    SerializationError(String),\n\n    /// Mathematical operation error\n    #[error(\"Math error: {0}\")]\n    MathError(String),\n}\n\n/// Result type for cryptographic operations\npub type CryptoResult\u003cT\u003e = Result\u003cT, CryptoError\u003e;\n\n/// Trait for lattice-based cryptographic parameters\npub trait LatticeParameters {\n    /// Get the dimension parameter\n    fn dimension(\u0026self) -\u003e usize;\n\n    /// Get the modulus\n    fn modulus(\u0026self) -\u003e u64;\n\n    /// Get the error distribution parameter\n    fn sigma(\u0026self) -\u003e f64;\n\n    /// Validate parameters\n    fn validate(\u0026self) -\u003e CryptoResult\u003c()\u003e;\n}\n\n/// Trait for proof systems\npub trait ProofSystem {\n    /// Statement type\n    type Statement;\n\n    /// Witness type\n    type Witness;\n\n    /// Proof type\n    type Proof;\n\n    /// Generate a proof\n    fn prove(\n        statement: \u0026Self::Statement,\n        witness: \u0026Self::Witness,\n    ) -\u003e CryptoResult\u003cSelf::Proof\u003e;\n\n    /// Verify a proof\n    fn verify(statement: \u0026Self::Statement, proof: \u0026Self::Proof) -\u003e CryptoResult\u003c()\u003e;\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_library_initialization() {\n        // Basic smoke test\n        assert!(true);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","params","mod.rs"],"content":"//! Security parameter selection and management\r\n//!\r\n//! This module provides parameter sets for different security levels\r\n//! and algorithms for selecting optimal parameters.\r\n\r\npub mod security;\r\n\r\n/// Parameter selection with Miller-Rabin primality testing and security estimation\r\npub mod selector;\r\n\r\n// Re-export main types\r\npub use security::{CryptoParameters, ParameterSet, SecurityLevel};\r\npub use selector::{ParameterSelector, is_prime_miller_rabin, generate_prime};\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","params","security.rs"],"content":"//! Security parameter definitions and selection\r\n//!\r\n//! This module provides standard security levels and parameter sets.\r\n\r\nuse crate::lattice::RingLWEParameters;\r\nuse crate::{CryptoError, CryptoResult};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// Standard security levels (NIST post-quantum standards)\r\n#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq)]\r\npub enum SecurityLevel {\r\n    /// 128-bit security (NIST Level 1) - Comparable to AES-128\r\n    Bit128,\r\n    /// 192-bit security (NIST Level 3) - Comparable to AES-192\r\n    Bit192,\r\n    /// 256-bit security (NIST Level 5) - Comparable to AES-256\r\n    Bit256,\r\n}\r\n\r\n/// Complete parameter set for a security level\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct ParameterSet {\r\n    /// Security level\r\n    pub security_level: SecurityLevel,\r\n    /// Ring dimension (power of 2)\r\n    pub n: usize,\r\n    /// Coefficient modulus (prime)\r\n    pub q: u64,\r\n    /// Error distribution standard deviation\r\n    pub sigma: f64,\r\n    /// Estimated proof size (bytes)\r\n    pub proof_size: usize,\r\n    /// Estimated prove time (milliseconds)\r\n    pub prove_time_ms: u64,\r\n    /// Estimated verify time (milliseconds)\r\n    pub verify_time_ms: u64,\r\n}\r\n\r\nimpl ParameterSet {\r\n    /// Get standard parameter set for security level\r\n    pub fn from_security_level(level: SecurityLevel) -\u003e Self {\r\n        match level {\r\n            SecurityLevel::Bit128 =\u003e Self::standard_128bit(),\r\n            SecurityLevel::Bit192 =\u003e Self::standard_192bit(),\r\n            SecurityLevel::Bit256 =\u003e Self::standard_256bit(),\r\n        }\r\n    }\r\n\r\n    /// Standard 128-bit security parameters\r\n    fn standard_128bit() -\u003e Self {\r\n        ParameterSet {\r\n            security_level: SecurityLevel::Bit128,\r\n            n: 512,\r\n            q: 12289,\r\n            sigma: 3.2,\r\n            proof_size: 8_192,\r\n            prove_time_ms: 80,\r\n            verify_time_ms: 40,\r\n        }\r\n    }\r\n\r\n    /// Standard 192-bit security parameters\r\n    fn standard_192bit() -\u003e Self {\r\n        ParameterSet {\r\n            security_level: SecurityLevel::Bit192,\r\n            n: 1024,\r\n            q: 40961,\r\n            sigma: 3.2,\r\n            proof_size: 16_384,\r\n            prove_time_ms: 150,\r\n            verify_time_ms: 75,\r\n        }\r\n    }\r\n\r\n    /// Standard 256-bit security parameters\r\n    fn standard_256bit() -\u003e Self {\r\n        ParameterSet {\r\n            security_level: SecurityLevel::Bit256,\r\n            n: 2048,\r\n            q: 65537,\r\n            sigma: 3.2,\r\n            proof_size: 32_768,\r\n            prove_time_ms: 300,\r\n            verify_time_ms: 150,\r\n        }\r\n    }\r\n\r\n    /// Validate parameter set\r\n    pub fn validate(\u0026self) -\u003e CryptoResult\u003c()\u003e {\r\n        if !self.n.is_power_of_two() {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Dimension must be power of 2\".to_string(),\r\n            ));\r\n        }\r\n        if self.q \u003c 2 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Modulus must be at least 2\".to_string(),\r\n            ));\r\n        }\r\n        if self.sigma \u003c= 0.0 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Sigma must be positive\".to_string(),\r\n            ));\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n/// Cryptographic parameters for the proof system\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct CryptoParameters {\r\n    /// Security level\r\n    pub security_level: SecurityLevel,\r\n    /// Ring-LWE parameters\r\n    pub ring_params: RingLWEParameters,\r\n}\r\n\r\nimpl CryptoParameters {\r\n    /// Create parameters from security level\r\n    pub fn from_security_level(level: SecurityLevel) -\u003e Self {\r\n        let param_set = ParameterSet::from_security_level(level);\r\n        let ring_params = RingLWEParameters::new(param_set.n, param_set.q, param_set.sigma);\r\n\r\n        Self {\r\n            security_level: level,\r\n            ring_params,\r\n        }\r\n    }\r\n\r\n    /// Standard 128-bit security\r\n    pub fn new_128bit_security() -\u003e Self {\r\n        Self::from_security_level(SecurityLevel::Bit128)\r\n    }\r\n\r\n    /// Standard 192-bit security\r\n    pub fn new_192bit_security() -\u003e Self {\r\n        Self::from_security_level(SecurityLevel::Bit192)\r\n    }\r\n\r\n    /// Standard 256-bit security\r\n    pub fn new_256bit_security() -\u003e Self {\r\n        Self::from_security_level(SecurityLevel::Bit256)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::LatticeParameters;\r\n\r\n    #[test]\r\n    fn test_parameter_sets() {\r\n        let params_128 = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        assert!(params_128.validate().is_ok());\r\n        assert_eq!(params_128.n, 512);\r\n\r\n        let params_192 = ParameterSet::from_security_level(SecurityLevel::Bit192);\r\n        assert!(params_192.validate().is_ok());\r\n        assert_eq!(params_192.n, 1024);\r\n\r\n        let params_256 = ParameterSet::from_security_level(SecurityLevel::Bit256);\r\n        assert!(params_256.validate().is_ok());\r\n        assert_eq!(params_256.n, 2048);\r\n    }\r\n\r\n    #[test]\r\n    fn test_crypto_parameters() {\r\n        let params = CryptoParameters::new_128bit_security();\r\n        assert_eq!(params.security_level, SecurityLevel::Bit128);\r\n        assert_eq!(params.ring_params.n, 512);\r\n    }\r\n\r\n    #[test]\r\n    fn test_security_level_progression() {\r\n        // Verify increasing security levels have larger parameters\r\n        let params_128 = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        let params_192 = ParameterSet::from_security_level(SecurityLevel::Bit192);\r\n        let params_256 = ParameterSet::from_security_level(SecurityLevel::Bit256);\r\n        \r\n        // Dimension increases\r\n        assert!(params_128.n \u003c params_192.n);\r\n        assert!(params_192.n \u003c params_256.n);\r\n        \r\n        // Modulus increases\r\n        assert!(params_128.q \u003c params_192.q);\r\n        assert!(params_192.q \u003c params_256.q);\r\n        \r\n        // Performance estimates increase\r\n        assert!(params_128.prove_time_ms \u003c params_192.prove_time_ms);\r\n        assert!(params_192.prove_time_ms \u003c params_256.prove_time_ms);\r\n    }\r\n\r\n    #[test]\r\n    fn test_parameter_set_validation_edge_cases() {\r\n        // Invalid: dimension not power of 2\r\n        let mut params = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        params.n = 511;\r\n        assert!(params.validate().is_err());\r\n        \r\n        // Invalid: modulus too small\r\n        let mut params = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        params.q = 1;\r\n        assert!(params.validate().is_err());\r\n        \r\n        // Invalid: negative sigma\r\n        let mut params = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        params.sigma = -1.0;\r\n        assert!(params.validate().is_err());\r\n        \r\n        // Invalid: zero sigma\r\n        let mut params = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        params.sigma = 0.0;\r\n        assert!(params.validate().is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_all_security_levels_valid() {\r\n        for level in [SecurityLevel::Bit128, SecurityLevel::Bit192, SecurityLevel::Bit256] {\r\n            let params = ParameterSet::from_security_level(level);\r\n            assert!(params.validate().is_ok());\r\n            assert!(params.n.is_power_of_two());\r\n            assert!(params.q \u003e= 2);\r\n            assert!(params.sigma \u003e 0.0);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_crypto_parameters_all_levels() {\r\n        let p128 = CryptoParameters::new_128bit_security();\r\n        assert_eq!(p128.security_level, SecurityLevel::Bit128);\r\n        assert!(p128.ring_params.validate().is_ok());\r\n        \r\n        let p192 = CryptoParameters::new_192bit_security();\r\n        assert_eq!(p192.security_level, SecurityLevel::Bit192);\r\n        assert!(p192.ring_params.validate().is_ok());\r\n        \r\n        let p256 = CryptoParameters::new_256bit_security();\r\n        assert_eq!(p256.security_level, SecurityLevel::Bit256);\r\n        assert!(p256.ring_params.validate().is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn test_parameter_set_proof_size_estimates() {\r\n        let params_128 = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        let params_192 = ParameterSet::from_security_level(SecurityLevel::Bit192);\r\n        let params_256 = ParameterSet::from_security_level(SecurityLevel::Bit256);\r\n        \r\n        // Proof size should scale with security level\r\n        assert!(params_128.proof_size \u003c params_192.proof_size);\r\n        assert!(params_192.proof_size \u003c params_256.proof_size);\r\n        \r\n        // Proof sizes should be reasonable (not zero, not huge)\r\n        assert!(params_128.proof_size \u003e 1000);\r\n        assert!(params_256.proof_size \u003c 100_000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_parameter_set_timing_estimates() {\r\n        let params = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        \r\n        // Verify time is positive\r\n        assert!(params.prove_time_ms \u003e 0);\r\n        assert!(params.verify_time_ms \u003e 0);\r\n        \r\n        // Verify should be faster than prove\r\n        assert!(params.verify_time_ms \u003c= params.prove_time_ms);\r\n    }\r\n}\r\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":1729382256910270469}},{"line":42,"address":[],"length":0,"stats":{"Line":1729382256910270469}},{"line":43,"address":[],"length":0,"stats":{"Line":864691128455135237}},{"line":44,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":45,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":50,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":63,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":76,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":89,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":90,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":91,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":92,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":95,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":96,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":97,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":100,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":101,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":102,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":105,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":120,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":121,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":122,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":131,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":132,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":136,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":137,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":141,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":142,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":28,"coverable":28},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","params","selector.rs"],"content":"/// Parameter Selector\r\n/// \r\n/// Provides a flexible builder pattern for selecting cryptographic parameters\r\n/// with automatic security level estimation and constraint validation.\r\n\r\nuse crate::params::security::SecurityLevel;\r\nuse crate::lattice::{LWEParameters, RingLWEParameters};\r\nuse crate::{CryptoError, CryptoResult, LatticeParameters};\r\nuse num_bigint::BigUint;\r\nuse num_traits::One;\r\nuse rand::{Rng, thread_rng};\r\n\r\n/// Builder for selecting LWE and Ring-LWE parameters\r\n/// \r\n/// # Example\r\n/// \r\n/// ```\r\n/// use nexuszero_crypto::params::selector::ParameterSelector;\r\n/// use nexuszero_crypto::params::security::SecurityLevel;\r\n/// \r\n/// let selector = ParameterSelector::new()\r\n///     .target_security(SecurityLevel::Bit128)\r\n///     .max_dimension(1024)\r\n///     .prefer_prime_modulus(true);\r\n/// \r\n/// let params = selector.build_lwe().unwrap();\r\n/// ```\r\n#[derive(Debug, Clone)]\r\npub struct ParameterSelector {\r\n    target_security: Option\u003cSecurityLevel\u003e,\r\n    min_dimension: Option\u003cusize\u003e,\r\n    max_dimension: Option\u003cusize\u003e,\r\n    min_modulus: Option\u003cu64\u003e,\r\n    max_modulus: Option\u003cu64\u003e,\r\n    prefer_prime_modulus: bool,\r\n    custom_sigma: Option\u003cf64\u003e,\r\n    custom_ratio: Option\u003cf64\u003e, // m/n ratio for LWE\r\n}\r\n\r\nimpl Default for ParameterSelector {\r\n    fn default() -\u003e Self {\r\n        Self::new()\r\n    }\r\n}\r\n\r\nimpl ParameterSelector {\r\n    /// Create a new parameter selector with default settings\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            target_security: None,\r\n            min_dimension: None,\r\n            max_dimension: None,\r\n            min_modulus: None,\r\n            max_modulus: None,\r\n            prefer_prime_modulus: false,\r\n            custom_sigma: None,\r\n            custom_ratio: None,\r\n        }\r\n    }\r\n\r\n    /// Set target security level\r\n    pub fn target_security(mut self, level: SecurityLevel) -\u003e Self {\r\n        self.target_security = Some(level);\r\n        self\r\n    }\r\n\r\n    /// Set minimum dimension\r\n    pub fn min_dimension(mut self, n: usize) -\u003e Self {\r\n        self.min_dimension = Some(n);\r\n        self\r\n    }\r\n\r\n    /// Set maximum dimension\r\n    pub fn max_dimension(mut self, n: usize) -\u003e Self {\r\n        self.max_dimension = Some(n);\r\n        self\r\n    }\r\n\r\n    /// Set minimum modulus\r\n    pub fn min_modulus(mut self, q: u64) -\u003e Self {\r\n        self.min_modulus = Some(q);\r\n        self\r\n    }\r\n\r\n    /// Set maximum modulus\r\n    pub fn max_modulus(mut self, q: u64) -\u003e Self {\r\n        self.max_modulus = Some(q);\r\n        self\r\n    }\r\n\r\n    /// Prefer prime modulus (enables Miller-Rabin testing)\r\n    pub fn prefer_prime_modulus(mut self, prefer: bool) -\u003e Self {\r\n        self.prefer_prime_modulus = prefer;\r\n        self\r\n    }\r\n\r\n    /// Set custom error standard deviation\r\n    pub fn custom_sigma(mut self, sigma: f64) -\u003e Self {\r\n        self.custom_sigma = Some(sigma);\r\n        self\r\n    }\r\n\r\n    /// Set custom m/n ratio for LWE (default 2.0)\r\n    pub fn custom_ratio(mut self, ratio: f64) -\u003e Self {\r\n        self.custom_ratio = Some(ratio);\r\n        self\r\n    }\r\n\r\n    /// Build LWE parameters based on constraints\r\n    pub fn build_lwe(self) -\u003e CryptoResult\u003cLWEParameters\u003e {\r\n        // Get target security level or default to 128-bit\r\n        let security = self.target_security.unwrap_or(SecurityLevel::Bit128);\r\n        \r\n        // Determine dimension based on security level and constraints\r\n        let n = self.select_dimension(security)?;\r\n        \r\n        // Determine m based on ratio (default 2.0)\r\n        let ratio = self.custom_ratio.unwrap_or(2.0);\r\n        let m = (n as f64 * ratio) as usize;\r\n        \r\n        // Select modulus\r\n        let q = self.select_modulus(n, security)?;\r\n        \r\n        // Select sigma based on security level\r\n        let sigma = self.custom_sigma.unwrap_or_else(|| {\r\n            match security {\r\n                SecurityLevel::Bit128 =\u003e 3.2,\r\n                SecurityLevel::Bit192 =\u003e 3.8,\r\n                SecurityLevel::Bit256 =\u003e 4.0,\r\n            }\r\n        });\r\n        \r\n        // Validate parameters\r\n        let params = LWEParameters::new(n, m, q, sigma);\r\n        params.validate()?;\r\n        \r\n        Ok(params)\r\n    }\r\n\r\n    /// Build Ring-LWE parameters based on constraints\r\n    pub fn build_ring_lwe(self) -\u003e CryptoResult\u003cRingLWEParameters\u003e {\r\n        // Get target security level or default to 128-bit\r\n        let security = self.target_security.unwrap_or(SecurityLevel::Bit128);\r\n        \r\n        // Ring-LWE requires power-of-2 dimension\r\n        let n = self.select_power_of_2_dimension(security)?;\r\n        \r\n        // Select modulus\r\n        let q = self.select_modulus(n, security)?;\r\n        \r\n        // Select sigma based on security level\r\n        let sigma = self.custom_sigma.unwrap_or_else(|| {\r\n            match security {\r\n                SecurityLevel::Bit128 =\u003e 3.2,\r\n                SecurityLevel::Bit192 =\u003e 3.8,\r\n                SecurityLevel::Bit256 =\u003e 4.0,\r\n            }\r\n        });\r\n        \r\n        // Create and validate parameters\r\n        let params = RingLWEParameters::new(n, q, sigma);\r\n        params.validate()?;\r\n        \r\n        Ok(params)\r\n    }\r\n\r\n    /// Select appropriate dimension based on security level and constraints\r\n    fn select_dimension(\u0026self, security: SecurityLevel) -\u003e CryptoResult\u003cusize\u003e {\r\n        // Standard dimensions for each security level\r\n        let standard_n = match security {\r\n            SecurityLevel::Bit128 =\u003e 256,\r\n            SecurityLevel::Bit192 =\u003e 384,\r\n            SecurityLevel::Bit256 =\u003e 512,\r\n        };\r\n        \r\n        // Apply constraints\r\n        let mut n = standard_n;\r\n        \r\n        if let Some(min_n) = self.min_dimension {\r\n            if n \u003c min_n {\r\n                n = min_n;\r\n            }\r\n        }\r\n        \r\n        if let Some(max_n) = self.max_dimension {\r\n            if n \u003e max_n {\r\n                n = max_n;\r\n            }\r\n        }\r\n        \r\n        // Validate dimension\r\n        if n \u003c 64 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Dimension too small for security\".to_string()\r\n            ));\r\n        }\r\n        \r\n        Ok(n)\r\n    }\r\n\r\n    /// Select power-of-2 dimension for Ring-LWE\r\n    fn select_power_of_2_dimension(\u0026self, security: SecurityLevel) -\u003e CryptoResult\u003cusize\u003e {\r\n        let standard_n = match security {\r\n            SecurityLevel::Bit128 =\u003e 512,\r\n            SecurityLevel::Bit192 =\u003e 1024,\r\n            SecurityLevel::Bit256 =\u003e 2048,\r\n        };\r\n        \r\n        let mut n = standard_n;\r\n        \r\n        // Apply constraints and round to nearest power of 2\r\n        if let Some(min_n) = self.min_dimension {\r\n            if n \u003c min_n {\r\n                n = min_n.next_power_of_two();\r\n            }\r\n        }\r\n        \r\n        if let Some(max_n) = self.max_dimension {\r\n            if n \u003e max_n {\r\n                // Round down to power of 2\r\n                n = (max_n as f64).log2().floor().exp2() as usize;\r\n            }\r\n        }\r\n        \r\n        // Ensure it's a power of 2\r\n        if !n.is_power_of_two() {\r\n            n = n.next_power_of_two();\r\n        }\r\n        \r\n        // Validate\r\n        if n \u003c 128 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Ring-LWE dimension too small\".to_string()\r\n            ));\r\n        }\r\n        \r\n        Ok(n)\r\n    }\r\n\r\n    /// Select appropriate modulus based on dimension and security\r\n    fn select_modulus(\u0026self, n: usize, security: SecurityLevel) -\u003e CryptoResult\u003cu64\u003e {\r\n        // Standard modulus selection based on dimension\r\n        let standard_q = match security {\r\n            SecurityLevel::Bit128 =\u003e 12289,  // Small prime, good for NTT\r\n            SecurityLevel::Bit192 =\u003e 16411,  // Larger prime\r\n            SecurityLevel::Bit256 =\u003e 20483,  // Even larger prime\r\n        };\r\n        \r\n        let mut q = standard_q;\r\n        \r\n        // Apply constraints\r\n        if let Some(min_q) = self.min_modulus {\r\n            if q \u003c min_q {\r\n                q = min_q;\r\n            }\r\n        }\r\n        \r\n        if let Some(max_q) = self.max_modulus {\r\n            if q \u003e max_q {\r\n                q = max_q;\r\n            }\r\n        }\r\n        \r\n        // If prime modulus preferred, find nearest prime\r\n        if self.prefer_prime_modulus {\r\n            q = find_nearest_prime(q)?;\r\n        }\r\n        \r\n        // Validate modulus is large enough for security\r\n        // Rule: q should be at least n for basic security\r\n        if q \u003c n as u64 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                format!(\"Modulus {} too small for dimension {}\", q, n)\r\n            ));\r\n        }\r\n        \r\n        Ok(q)\r\n    }\r\n\r\n    /// Estimate security level of given parameters\r\n    pub fn estimate_security(n: usize, q: u64, sigma: f64) -\u003e u32 {\r\n        // Simplified security estimation based on lattice parameters\r\n        // Based on the hardness of solving LWE with given parameters\r\n        \r\n        let log2_q = (q as f64).log2();\r\n        let log2_n = (n as f64).log2();\r\n        \r\n        // Core security estimate: dimension is the primary factor\r\n        // Each doubling of dimension roughly adds 50-80 bits of security\r\n        let dimension_security = log2_n * 60.0;\r\n        \r\n        // Modulus factor: larger modulus slightly reduces security\r\n        // but is needed for correctness\r\n        let modulus_factor = (log2_q / (log2_n + 10.0)).min(1.0);\r\n        \r\n        // Error distribution factor: larger sigma reduces security\r\n        // but smaller sigma helps security\r\n        let sigma_factor = if sigma \u003c 5.0 {\r\n            1.0 - (sigma / 20.0) // Very minor reduction\r\n        } else {\r\n            0.9 // Larger sigma has some impact\r\n        };\r\n        \r\n        // Combine factors\r\n        let bit_security = dimension_security * modulus_factor * sigma_factor;\r\n        \r\n        // Clamp to reasonable range\r\n        bit_security.max(64.0).min(512.0) as u32\r\n    }\r\n}\r\n\r\n/// Find nearest prime number to target using Miller-Rabin test\r\nfn find_nearest_prime(target: u64) -\u003e CryptoResult\u003cu64\u003e {\r\n    // Search in both directions\r\n    let max_search = 1000;\r\n    \r\n    for offset in 0..max_search {\r\n        // Try target + offset\r\n        if offset == 0 || target + offset \u003e target {\r\n            let candidate = target + offset;\r\n            if is_prime_miller_rabin(candidate, 20) {\r\n                return Ok(candidate);\r\n            }\r\n        }\r\n        \r\n        // Try target - offset\r\n        if offset \u003e 0 \u0026\u0026 target \u003e offset {\r\n            let candidate = target - offset;\r\n            if is_prime_miller_rabin(candidate, 20) {\r\n                return Ok(candidate);\r\n            }\r\n        }\r\n    }\r\n    \r\n    Err(CryptoError::InvalidParameter(\r\n        format!(\"Could not find prime near {}\", target)\r\n    ))\r\n}\r\n\r\n/// Miller-Rabin primality test\r\n/// \r\n/// Probabilistic test with error probability \u003c 4^(-k)\r\n/// where k is the number of rounds.\r\n/// \r\n/// # Arguments\r\n/// \r\n/// * `n` - Number to test for primality\r\n/// * `k` - Number of testing rounds (20 is standard for cryptographic use)\r\n/// \r\n/// # Returns\r\n/// \r\n/// `true` if n is probably prime, `false` if n is definitely composite\r\npub fn is_prime_miller_rabin(n: u64, k: u32) -\u003e bool {\r\n    // Handle small cases\r\n    if n \u003c 2 {\r\n        return false;\r\n    }\r\n    if n == 2 || n == 3 {\r\n        return true;\r\n    }\r\n    if n % 2 == 0 {\r\n        return false;\r\n    }\r\n    \r\n    // Write n-1 as 2^r * d\r\n    let mut d = n - 1;\r\n    let mut r = 0;\r\n    while d % 2 == 0 {\r\n        d /= 2;\r\n        r += 1;\r\n    }\r\n    \r\n    let n_big = BigUint::from(n);\r\n    let mut rng = thread_rng();\r\n    \r\n    'witness: for _ in 0..k {\r\n        // Pick random witness a in [2, n-2]\r\n        let a = rng.gen_range(2..n-1);\r\n        let a_big = BigUint::from(a);\r\n        \r\n        // Compute x = a^d mod n\r\n        let mut x = a_big.modpow(\u0026BigUint::from(d), \u0026n_big);\r\n        \r\n        if x == One::one() || x == \u0026n_big - BigUint::one() {\r\n            continue 'witness;\r\n        }\r\n        \r\n        for _ in 0..r-1 {\r\n            // x = x^2 mod n\r\n            x = (\u0026x * \u0026x) % \u0026n_big;\r\n            \r\n            if x == \u0026n_big - BigUint::one() {\r\n                continue 'witness;\r\n            }\r\n        }\r\n        \r\n        // n is definitely composite\r\n        return false;\r\n    }\r\n    \r\n    // n is probably prime\r\n    true\r\n}\r\n\r\n/// Generate cryptographically strong prime\r\n/// \r\n/// Generates a prime number suitable for cryptographic use\r\n/// with specified bit length.\r\npub fn generate_prime(bit_length: u32) -\u003e CryptoResult\u003cu64\u003e {\r\n    if bit_length \u003e 63 {\r\n        return Err(CryptoError::InvalidParameter(\r\n            \"Bit length too large for u64\".to_string()\r\n        ));\r\n    }\r\n    \r\n    let mut rng = thread_rng();\r\n    let max_attempts = 10000;\r\n    \r\n    for _ in 0..max_attempts {\r\n        // Generate random odd number of specified bit length\r\n        let min = 1u64 \u003c\u003c (bit_length - 1);\r\n        let max = (1u64 \u003c\u003c bit_length) - 1;\r\n        let mut candidate = rng.gen_range(min..=max);\r\n        \r\n        // Make it odd\r\n        candidate |= 1;\r\n        \r\n        // Test primality\r\n        if is_prime_miller_rabin(candidate, 20) {\r\n            return Ok(candidate);\r\n        }\r\n    }\r\n    \r\n    Err(CryptoError::InvalidParameter(\r\n        \"Could not generate prime\".to_string()\r\n    ))\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_miller_rabin_known_primes() {\r\n        // Small primes\r\n        assert!(is_prime_miller_rabin(2, 20));\r\n        assert!(is_prime_miller_rabin(3, 20));\r\n        assert!(is_prime_miller_rabin(5, 20));\r\n        assert!(is_prime_miller_rabin(7, 20));\r\n        assert!(is_prime_miller_rabin(11, 20));\r\n        assert!(is_prime_miller_rabin(13, 20));\r\n        \r\n        // Larger primes\r\n        assert!(is_prime_miller_rabin(97, 20));\r\n        assert!(is_prime_miller_rabin(541, 20));\r\n        assert!(is_prime_miller_rabin(7919, 20));\r\n        assert!(is_prime_miller_rabin(12289, 20)); // Common in lattice crypto\r\n    }\r\n\r\n    #[test]\r\n    fn test_miller_rabin_known_composites() {\r\n        assert!(!is_prime_miller_rabin(0, 20));\r\n        assert!(!is_prime_miller_rabin(1, 20));\r\n        assert!(!is_prime_miller_rabin(4, 20));\r\n        assert!(!is_prime_miller_rabin(6, 20));\r\n        assert!(!is_prime_miller_rabin(8, 20));\r\n        assert!(!is_prime_miller_rabin(9, 20));\r\n        assert!(!is_prime_miller_rabin(100, 20));\r\n        assert!(!is_prime_miller_rabin(1000, 20));\r\n    }\r\n\r\n    #[test]\r\n    fn test_parameter_selector_lwe() {\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128);\r\n        \r\n        let params = selector.build_lwe().unwrap();\r\n        \r\n        assert_eq!(params.n, 256);\r\n        assert_eq!(params.m, 512);\r\n        assert!(params.q \u003e 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_parameter_selector_ring_lwe() {\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128);\r\n        \r\n        let params = selector.build_ring_lwe().unwrap();\r\n        \r\n        assert_eq!(params.n, 512);\r\n        assert!(params.n.is_power_of_two());\r\n        assert!(params.q \u003e 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_parameter_selector_with_constraints() {\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .min_dimension(512)\r\n            .max_dimension(1024)\r\n            .prefer_prime_modulus(true);\r\n        \r\n        let params = selector.build_lwe().unwrap();\r\n        \r\n        assert!(params.n \u003e= 512);\r\n        assert!(params.n \u003c= 1024);\r\n        assert!(is_prime_miller_rabin(params.q, 20));\r\n    }\r\n\r\n    #[test]\r\n    fn test_security_estimation() {\r\n        // 128-bit security parameters\r\n        let security = ParameterSelector::estimate_security(256, 12289, 3.2);\r\n        assert!(security \u003e= 100, \"Security should be reasonable: {}\", security);\r\n        \r\n        // 192-bit security parameters\r\n        let security = ParameterSelector::estimate_security(384, 16411, 3.8);\r\n        assert!(security \u003e= 100, \"Security should be reasonable: {}\", security);\r\n        \r\n        // 256-bit security parameters\r\n        let security = ParameterSelector::estimate_security(512, 20483, 4.0);\r\n        assert!(security \u003e= 100, \"Security should be reasonable: {}\", security);\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_nearest_prime() {\r\n        // Find prime near 12289 (which is already prime)\r\n        let prime = find_nearest_prime(12289).unwrap();\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n        \r\n        // Find prime near 12000 (not prime)\r\n        let prime = find_nearest_prime(12000).unwrap();\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n        assert!((prime as i64 - 12000).abs() \u003c 1000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_generate_prime() {\r\n        let prime = generate_prime(14).unwrap();\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n        assert!(prime \u003e= 8192 \u0026\u0026 prime \u003c 16384); // 2^13 to 2^14\r\n    }\r\n\r\n    #[test]\r\n    fn test_power_of_2_dimension() {\r\n        let selector = ParameterSelector::new()\r\n            .min_dimension(500)\r\n            .max_dimension(1500);\r\n        \r\n        let n = selector.select_power_of_2_dimension(SecurityLevel::Bit128).unwrap();\r\n        assert!(n.is_power_of_two());\r\n        assert!(n \u003e= 512); // Next power of 2 after min\r\n        assert!(n \u003c= 1024); // Power of 2 within max\r\n    }\r\n\r\n    #[test]\r\n    fn test_selector_extreme_dimension_constraints() {\r\n        // Very small min dimension\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .min_dimension(10)\r\n            .max_dimension(300);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!(params.n \u003e= 10 \u0026\u0026 params.n \u003c= 300);\r\n        \r\n        // Very large max dimension\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .min_dimension(256)\r\n            .max_dimension(10000);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!(params.n \u003e= 256 \u0026\u0026 params.n \u003c= 10000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_selector_conflicting_constraints() {\r\n        // Min \u003e Max should fail or auto-correct\r\n        let selector = ParameterSelector::new()\r\n            .min_dimension(1024)\r\n            .max_dimension(512);\r\n        \r\n        // This should either error or auto-swap\r\n        let result = selector.build_lwe();\r\n        // If it succeeds, dimension should be reasonable\r\n        if let Ok(params) = result {\r\n            assert!(params.n \u003e 0);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_selector_boundary_modulus() {\r\n        // Very small modulus constraint\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .min_modulus(100)\r\n            .max_modulus(500);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!(params.q \u003e= 100 \u0026\u0026 params.q \u003c= 500);\r\n        \r\n        // Very large modulus constraint\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .min_modulus(50000)\r\n            .max_modulus(100000);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!(params.q \u003e= 50000 \u0026\u0026 params.q \u003c= 100000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_selector_custom_ratio_extremes() {\r\n        // Very small ratio (m barely larger than n)\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .custom_ratio(1.1);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!((params.m as f64 / params.n as f64) \u003e= 1.0);\r\n        assert!((params.m as f64 / params.n as f64) \u003c 1.5);\r\n        \r\n        // Large ratio (m much larger than n)\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .custom_ratio(10.0);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!((params.m as f64 / params.n as f64) \u003e= 9.0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_selector_custom_sigma_extremes() {\r\n        // Very small sigma\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .custom_sigma(0.5);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!((params.sigma - 0.5).abs() \u003c 0.01);\r\n        \r\n        // Large sigma\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .custom_sigma(10.0);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!((params.sigma - 10.0).abs() \u003c 0.01);\r\n    }\r\n\r\n    #[test]\r\n    fn test_prime_generation_edge_cases() {\r\n        // Small bit size\r\n        let prime = generate_prime(4).unwrap();\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n        assert!(prime \u003e= 8 \u0026\u0026 prime \u003c 16);\r\n        \r\n        // Larger bit size\r\n        let prime = generate_prime(20).unwrap();\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n        assert!(prime \u003e= (1 \u003c\u003c 19) \u0026\u0026 prime \u003c (1 \u003c\u003c 20));\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_nearest_prime_boundary_cases() {\r\n        // Near lower bound\r\n        let prime = find_nearest_prime(100).unwrap();\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n        \r\n        // Even number (should find odd prime)\r\n        let prime = find_nearest_prime(1000).unwrap();\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n        assert!(prime % 2 == 1 || prime == 2);\r\n        \r\n        // Already prime\r\n        let prime = find_nearest_prime(7919).unwrap();\r\n        assert_eq!(prime, 7919);\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_power_of_2_enforcement() {\r\n        // Request non-power-of-2 via constraints, should get next power of 2\r\n        let selector = ParameterSelector::new()\r\n            .min_dimension(300)\r\n            .max_dimension(600);\r\n        let params = selector.build_ring_lwe().unwrap();\r\n        assert!(params.n.is_power_of_two());\r\n        assert!(params.n \u003e= 512); // Next power of 2 \u003e= 300\r\n    }\r\n\r\n        #[test]\r\n        fn test_dimension_too_small_error() {\r\n            // Test that dimensions below security threshold fail\r\n            let selector = ParameterSelector::new()\r\n                .max_dimension(32); // Below minimum 64\r\n        \r\n            let result = selector.build_lwe();\r\n            assert!(result.is_err());\r\n        }\r\n\r\n        #[test]\r\n        fn test_ring_lwe_dimension_too_small_error() {\r\n            // Ring-LWE requires min 128\r\n            let selector = ParameterSelector::new()\r\n                .max_dimension(64); // Below Ring-LWE minimum\r\n        \r\n            let result = selector.build_ring_lwe();\r\n            assert!(result.is_err());\r\n        }\r\n\r\n        #[test]\r\n        fn test_modulus_smaller_than_dimension_error() {\r\n            // Modulus must be at least as large as dimension\r\n            let selector = ParameterSelector::new()\r\n                .min_dimension(1000)\r\n                .max_modulus(500); // q \u003c n\r\n        \r\n            let result = selector.build_lwe();\r\n            assert!(result.is_err());\r\n        }\r\n\r\n        #[test]\r\n        fn test_generate_prime_bit_length_too_large() {\r\n            // Test that requesting 64+ bit primes fails\r\n            let result = generate_prime(64);\r\n            assert!(result.is_err());\r\n        \r\n            let result = generate_prime(100);\r\n            assert!(result.is_err());\r\n        }\r\n\r\n        #[test]\r\n        fn test_find_prime_extreme_range() {\r\n            // Test finding prime in challenging ranges\r\n            let prime = find_nearest_prime(2).unwrap();\r\n            assert_eq!(prime, 2);\r\n        \r\n            let prime = find_nearest_prime(3).unwrap();\r\n            assert_eq!(prime, 3);\r\n        \r\n            // Large number\r\n            let prime = find_nearest_prime(65000).unwrap();\r\n            assert!(is_prime_miller_rabin(prime, 20));\r\n            assert!((prime as i64 - 65000).abs() \u003c 1000);\r\n        }\r\n\r\n        #[test]\r\n        fn test_security_estimation_edge_cases() {\r\n            // Very small parameters\r\n            let security = ParameterSelector::estimate_security(64, 100, 1.0);\r\n            assert!(security \u003e= 64); // Should clamp to minimum\r\n        \r\n            // Very large parameters\r\n            let security = ParameterSelector::estimate_security(8192, 100000, 2.0);\r\n            assert!(security \u003c= 512); // Should clamp to maximum\r\n        \r\n            // Large sigma impact\r\n            let security = ParameterSelector::estimate_security(256, 12289, 10.0);\r\n            assert!(security \u003e 0);\r\n        }\r\n\r\n        #[test]\r\n        fn test_selector_all_security_levels() {\r\n            // Test each security level produces valid parameters\r\n            for level in [SecurityLevel::Bit128, SecurityLevel::Bit192, SecurityLevel::Bit256] {\r\n                let selector = ParameterSelector::new().target_security(level);\r\n            \r\n                let lwe_params = selector.clone().build_lwe().unwrap();\r\n                assert!(lwe_params.validate().is_ok());\r\n            \r\n                let ring_params = selector.build_ring_lwe().unwrap();\r\n                assert!(ring_params.validate().is_ok());\r\n            }\r\n        }\r\n\r\n        #[test]\r\n        fn test_selector_with_all_constraints() {\r\n            // Test with maximum constraints specified\r\n            let selector = ParameterSelector::new()\r\n                .target_security(SecurityLevel::Bit192)\r\n                .min_dimension(256)\r\n                .max_dimension(512)\r\n                .min_modulus(10000)\r\n                .max_modulus(20000)\r\n                .prefer_prime_modulus(true)\r\n                .custom_sigma(3.5)\r\n                .custom_ratio(1.5);\r\n        \r\n            let params = selector.build_lwe().unwrap();\r\n            assert!(params.n \u003e= 256 \u0026\u0026 params.n \u003c= 512);\r\n            assert!(params.q \u003e= 10000 \u0026\u0026 params.q \u003c= 20000);\r\n            assert!(is_prime_miller_rabin(params.q, 20));\r\n            assert!((params.sigma - 3.5).abs() \u003c 0.01);\r\n        }\r\n\r\n        #[test]\r\n        fn test_power_of_2_rounding_down() {\r\n            // Test that max_dimension rounds down to power of 2\r\n            let selector = ParameterSelector::new()\r\n                .max_dimension(1500); // Should round down to 1024\r\n        \r\n            let n = selector.select_power_of_2_dimension(SecurityLevel::Bit192).unwrap();\r\n            assert_eq!(n, 1024);\r\n            assert!(n.is_power_of_two());\r\n        }\r\n\r\n        #[test]\r\n        fn test_power_of_2_rounding_up() {\r\n            // Test that min_dimension rounds up to power of 2\r\n            let selector = ParameterSelector::new()\r\n                .min_dimension(700) // Should round up to 1024\r\n                .max_dimension(2000);\r\n        \r\n            let n = selector.select_power_of_2_dimension(SecurityLevel::Bit192).unwrap();\r\n            assert_eq!(n, 1024);\r\n            assert!(n.is_power_of_two());\r\n        }\r\n}\r\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":62,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":63,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":64,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":68,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":69,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":70,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":74,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":75,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":76,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":80,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":81,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":82,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":86,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":87,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":88,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":92,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":93,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":94,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":98,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":99,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":100,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":104,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":105,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":106,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":110,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":112,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":115,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":118,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":119,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":122,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":125,"address":[],"length":0,"stats":{"Line":4107282860162163481}},{"line":126,"address":[],"length":0,"stats":{"Line":864691128455406361}},{"line":127,"address":[],"length":0,"stats":{"Line":720575940379550489}},{"line":128,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":129,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":134,"address":[],"length":0,"stats":{"Line":6485183463413514240}},{"line":135,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":137,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":141,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":143,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":146,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":149,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":152,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":153,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":154,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":155,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":156,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":161,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":162,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":164,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":168,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":170,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":171,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":172,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":173,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":177,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":179,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":180,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":181,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":185,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":186,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":187,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":192,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":193,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":194,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":198,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":202,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":203,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":204,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":205,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":206,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":209,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":212,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":213,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":219,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":221,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":226,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":232,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":233,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":237,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":241,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":243,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":244,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":245,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":246,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":249,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":252,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":253,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":254,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":258,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":259,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":260,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":265,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":266,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":271,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":272,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":273,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":277,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":281,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":285,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":286,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":290,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":294,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":298,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":299,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":301,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":305,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":308,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":313,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":315,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":317,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":319,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":320,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":321,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":322,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":327,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":328,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":329,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":330,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":5692549928996306944}},{"line":355,"address":[],"length":0,"stats":{"Line":5692549928996306944}},{"line":356,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":358,"address":[],"length":0,"stats":{"Line":10952754293765046272}},{"line":359,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":361,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":362,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":366,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":367,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":368,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":369,"address":[],"length":0,"stats":{"Line":10808639105689190400}},{"line":370,"address":[],"length":0,"stats":{"Line":10808639105689190400}},{"line":373,"address":[],"length":0,"stats":{"Line":11673330234144325632}},{"line":374,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":376,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":378,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":379,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":382,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":384,"address":[],"length":0,"stats":{"Line":8070450532247928830}},{"line":385,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":388,"address":[],"length":0,"stats":{"Line":9223372036854775807}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":16933534598913064958}},{"line":398,"address":[],"length":0,"stats":{"Line":9223372036854775807}},{"line":402,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":409,"address":[],"length":0,"stats":{"Line":360287970189639684}},{"line":410,"address":[],"length":0,"stats":{"Line":360287970189639684}},{"line":411,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":412,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":416,"address":[],"length":0,"stats":{"Line":432345564227567624}},{"line":417,"address":[],"length":0,"stats":{"Line":432345564227567624}},{"line":419,"address":[],"length":0,"stats":{"Line":216172782113783812}},{"line":421,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":422,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":423,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":426,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":429,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":430,"address":[],"length":0,"stats":{"Line":216172782113783812}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}}],"covered":159,"coverable":169},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","proof","mod.rs"],"content":"//! Zero-knowledge proof system components\r\n//!\r\n//! This module provides Statement, Witness, and Proof structures\r\n//! for constructing zero-knowledge proofs.\r\n\r\npub mod proof;\r\npub mod statement;\r\npub mod witness;\r\n\r\n// Re-export main types\r\npub use proof::{Proof, ProofMetadata};\r\npub use statement::{Statement, StatementBuilder, StatementType};\r\npub use witness::{Witness, WitnessType};\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","proof","proof.rs"],"content":"//! Proof generation and verification\r\n//!\r\n//! This module implements the core prove/verify algorithms.\r\n\r\nuse crate::proof::{Statement, Witness};\r\nuse crate::{CryptoError, CryptoResult};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// A zero-knowledge proof\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct Proof {\r\n    /// Commitment phase values\r\n    pub commitments: Vec\u003cCommitment\u003e,\r\n    /// Challenge from Fiat-Shamir transform\r\n    pub challenge: Challenge,\r\n    /// Response phase values\r\n    pub responses: Vec\u003cResponse\u003e,\r\n    /// Proof metadata\r\n    pub metadata: ProofMetadata,\r\n}\r\n\r\n/// Commitment in the proof\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct Commitment {\r\n    /// Commitment value\r\n    pub value: Vec\u003cu8\u003e,\r\n}\r\n\r\n/// Challenge value\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct Challenge {\r\n    /// Challenge bytes\r\n    pub value: [u8; 32],\r\n}\r\n\r\n/// Response in the proof\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct Response {\r\n    /// Response value\r\n    pub value: Vec\u003cu8\u003e,\r\n}\r\n\r\n/// Proof metadata\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct ProofMetadata {\r\n    /// Proof system version\r\n    pub version: u8,\r\n    /// Timestamp of generation\r\n    pub timestamp: u64,\r\n    /// Size in bytes\r\n    pub size: usize,\r\n}\r\n\r\nimpl Proof {\r\n    /// Validate proof structure\r\n    pub fn validate(\u0026self) -\u003e CryptoResult\u003c()\u003e {\r\n        if self.commitments.is_empty() {\r\n            return Err(CryptoError::ProofError(\"No commitments\".to_string()));\r\n        }\r\n        if self.responses.is_empty() {\r\n            return Err(CryptoError::ProofError(\"No responses\".to_string()));\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    /// Serialize proof to bytes\r\n    pub fn to_bytes(\u0026self) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\r\n        bincode::serialize(self).map_err(|e| {\r\n            CryptoError::SerializationError(format!(\"Failed to serialize proof: {}\", e))\r\n        })\r\n    }\r\n\r\n    /// Deserialize proof from bytes\r\n    pub fn from_bytes(bytes: \u0026[u8]) -\u003e CryptoResult\u003cSelf\u003e {\r\n        bincode::deserialize(bytes).map_err(|e| {\r\n            CryptoError::SerializationError(format!(\"Failed to deserialize proof: {}\", e))\r\n        })\r\n    }\r\n\r\n    /// Get proof size\r\n    pub fn size(\u0026self) -\u003e usize {\r\n        self.metadata.size\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions\r\n// ============================================================================\r\n\r\nuse rand::Rng;\r\nuse num_bigint::BigUint;\r\nuse crate::proof::statement::{HashFunction, StatementType};\r\n\r\n/// Generate random blinding factors for commitments\r\nfn generate_blinding_factors(count: usize, size: usize) -\u003e Vec\u003cVec\u003cu8\u003e\u003e {\r\n    let mut rng = rand::thread_rng();\r\n    (0..count)\r\n        .map(|_| (0..size).map(|_| rng.gen::\u003cu8\u003e()).collect())\r\n        .collect()\r\n}\r\n\r\n/// Convert challenge to scalar for arithmetic\r\nfn challenge_to_bigint(challenge: \u0026[u8; 32]) -\u003e BigUint {\r\n    BigUint::from_bytes_be(challenge)\r\n}\r\n\r\n/// Modular addition: (a + b) mod m, padded to 32 bytes\r\nfn add_mod(a: \u0026[u8], b: \u0026[u8], modulus: \u0026BigUint) -\u003e Vec\u003cu8\u003e {\r\n    let a_big = BigUint::from_bytes_be(a);\r\n    let b_big = BigUint::from_bytes_be(b);\r\n    let result = (a_big + b_big) % modulus;\r\n    let mut bytes = result.to_bytes_be();\r\n    \r\n    // Pad to 32 bytes if needed\r\n    while bytes.len() \u003c 32 {\r\n        bytes.insert(0, 0);\r\n    }\r\n    bytes\r\n}\r\n\r\n/// Modular multiplication: (a * b) mod m, padded to 32 bytes\r\nfn mul_mod(a: \u0026BigUint, b: \u0026[u8], modulus: \u0026BigUint) -\u003e Vec\u003cu8\u003e {\r\n    let b_big = BigUint::from_bytes_be(b);\r\n    let result = (a * b_big) % modulus;\r\n    let mut bytes = result.to_bytes_be();\r\n    \r\n    // Pad to 32 bytes if needed\r\n    while bytes.len() \u003c 32 {\r\n        bytes.insert(0, 0);\r\n    }\r\n    bytes\r\n}\r\n\r\n/// Modular exponentiation: base^exp mod modulus\r\nfn mod_exp(base: \u0026[u8], exp: \u0026[u8], modulus: \u0026[u8]) -\u003e Vec\u003cu8\u003e {\r\n    let base_big = BigUint::from_bytes_be(base);\r\n    let exp_big = BigUint::from_bytes_be(exp);\r\n    let mod_big = BigUint::from_bytes_be(modulus);\r\n    \r\n    let result = base_big.modpow(\u0026exp_big, \u0026mod_big);\r\n    result.to_bytes_be()\r\n}\r\n\r\n/// Get current Unix timestamp\r\nfn current_timestamp() -\u003e u64 {\r\n    use std::time::{SystemTime, UNIX_EPOCH};\r\n    SystemTime::now()\r\n        .duration_since(UNIX_EPOCH)\r\n        .unwrap_or_default()\r\n        .as_secs()\r\n}\r\n\r\n// ============================================================================\r\n// Commitment Phase Functions\r\n// ============================================================================\r\n\r\n/// Commit for discrete log proof: t = g^r\r\nfn commit_discrete_log(generator: \u0026[u8], blinding: \u0026[u8]) -\u003e CryptoResult\u003cCommitment\u003e {\r\n    // Use a simple modulus for demonstration (in production, use proper group)\r\n    let modulus_bytes = vec![0xFF; 32]; // 2^256 - 1 approximation\r\n    \r\n    let t = mod_exp(generator, blinding, \u0026modulus_bytes);\r\n    \r\n    Ok(Commitment { value: t })\r\n}\r\n\r\n/// Commit for preimage proof: commitment to randomness\r\nfn commit_preimage(blinding: \u0026[u8]) -\u003e CryptoResult\u003cCommitment\u003e {\r\n    use sha3::{Digest, Sha3_256};\r\n    \r\n    // Commit to blinding factor\r\n    let mut hasher = Sha3_256::new();\r\n    hasher.update(blinding);\r\n    let commitment = hasher.finalize().to_vec();\r\n    \r\n    Ok(Commitment { value: commitment })\r\n}\r\n\r\n// ============================================================================\r\n// Response Phase Functions\r\n// ============================================================================\r\n\r\n/// Compute response for discrete log: s = r + c*x (no modulus, let it be large)\r\nfn compute_discrete_log_response(\r\n    secret: \u0026[u8],\r\n    blinding: \u0026[u8],\r\n    challenge: \u0026[u8; 32],\r\n) -\u003e CryptoResult\u003cResponse\u003e {\r\n    let c = challenge_to_bigint(challenge);\r\n    let r = BigUint::from_bytes_be(blinding);\r\n    let x = BigUint::from_bytes_be(secret);\r\n    \r\n    // s = r + c*x (no modular reduction - let response be arbitrary size)\r\n    let s = r + (c * x);\r\n    \r\n    Ok(Response { value: s.to_bytes_be() })\r\n}\r\n\r\n/// Compute response for preimage: reveal blinding XOR challenge\r\nfn compute_preimage_response(\r\n    blinding: \u0026[u8],\r\n    challenge: \u0026[u8; 32],\r\n) -\u003e CryptoResult\u003cResponse\u003e {\r\n    // Simple response: blinding XOR first bytes of challenge\r\n    let mut response = blinding.to_vec();\r\n    for (i, byte) in response.iter_mut().enumerate() {\r\n        if i \u003c challenge.len() {\r\n            *byte ^= challenge[i];\r\n        }\r\n    }\r\n    \r\n    Ok(Response { value: response })\r\n}\r\n\r\n// ============================================================================\r\n// Verification Functions\r\n// ============================================================================\r\n\r\n/// Verify discrete log proof: check g^s = t * h^c\r\nfn verify_discrete_log_proof(\r\n    generator: \u0026[u8],\r\n    public_value: \u0026[u8],\r\n    commitment: \u0026Commitment,\r\n    challenge: \u0026Challenge,\r\n    response: \u0026Response,\r\n) -\u003e CryptoResult\u003c()\u003e {\r\n    let modulus_bytes = vec![0xFF; 32];\r\n    let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n    \r\n    // Compute g^s (mod p)\r\n    let gs_big = {\r\n        let gen_big = BigUint::from_bytes_be(generator);\r\n        let response_big = BigUint::from_bytes_be(\u0026response.value);\r\n        gen_big.modpow(\u0026response_big, \u0026mod_big)\r\n    };\r\n    \r\n    // Compute h^c (mod p)\r\n    let hc_big = {\r\n        let h_big = BigUint::from_bytes_be(public_value);\r\n        let c_big = BigUint::from_bytes_be(\u0026challenge.value);\r\n        h_big.modpow(\u0026c_big, \u0026mod_big)\r\n    };\r\n    \r\n    // Compute t * h^c (mod p)\r\n    let right_side = {\r\n        let t_big = BigUint::from_bytes_be(\u0026commitment.value);\r\n        (t_big * hc_big) % \u0026mod_big\r\n    };\r\n    \r\n    // Verify g^s = t * h^c (mod p)\r\n    if gs_big == right_side {\r\n        Ok(())\r\n    } else {\r\n        Err(CryptoError::VerificationError(\r\n            \"Discrete log proof verification failed\".to_string(),\r\n        ))\r\n    }\r\n}\r\n\r\n/// Verify preimage proof\r\nfn verify_preimage_proof(\r\n    hash_function: \u0026HashFunction,\r\n    hash_output: \u0026[u8],\r\n    commitment: \u0026Commitment,\r\n    challenge: \u0026Challenge,\r\n    response: \u0026Response,\r\n) -\u003e CryptoResult\u003c()\u003e {\r\n    use sha3::{Digest, Sha3_256};\r\n    use sha2::Sha256;\r\n    \r\n    // Recompute blinding from response XOR challenge\r\n    let mut blinding = response.value.clone();\r\n    for (i, byte) in blinding.iter_mut().enumerate() {\r\n        if i \u003c challenge.value.len() {\r\n            *byte ^= challenge.value[i];\r\n        }\r\n    }\r\n    \r\n    // Verify commitment matches\r\n    let recomputed_commitment = match hash_function {\r\n        HashFunction::SHA3_256 =\u003e {\r\n            let mut hasher = Sha3_256::new();\r\n            hasher.update(\u0026blinding);\r\n            hasher.finalize().to_vec()\r\n        }\r\n        HashFunction::SHA256 =\u003e {\r\n            let mut hasher = Sha256::new();\r\n            hasher.update(\u0026blinding);\r\n            hasher.finalize().to_vec()\r\n        }\r\n        HashFunction::Blake3 =\u003e {\r\n            // Blake3 not yet implemented\r\n            return Err(CryptoError::VerificationError(\r\n                \"Blake3 hash function not yet supported\".to_string(),\r\n            ));\r\n        }\r\n    };\r\n    \r\n    if recomputed_commitment != commitment.value {\r\n        return Err(CryptoError::VerificationError(\r\n            \"Preimage commitment verification failed\".to_string(),\r\n        ));\r\n    }\r\n    \r\n    // Note: In a real preimage proof, we'd verify the actual preimage\r\n    // This is a simplified version showing the structure\r\n    \r\n    // Verify hash output matches (in real implementation, witness would be revealed selectively)\r\n    if hash_output.is_empty() {\r\n        return Err(CryptoError::VerificationError(\r\n            \"Invalid hash output\".to_string(),\r\n        ));\r\n    }\r\n    \r\n    Ok(())\r\n}\r\n\r\n// ============================================================================\r\n// Main Proof Generation Function\r\n// ============================================================================\r\n\r\n/// Generate a zero-knowledge proof\r\n/// \r\n/// # Arguments\r\n/// * `statement` - The public statement being proven\r\n/// * `witness` - The secret knowledge (NOT transmitted)\r\n/// \r\n/// # Returns\r\n/// A proof that can be publicly verified\r\n/// \r\n/// # Implementation\r\n/// Uses Schnorr-style protocol with Fiat-Shamir transform:\r\n/// 1. Commitment: Generate random blinding factors\r\n/// 2. Challenge: Hash statement + commitments (Fiat-Shamir)\r\n/// 3. Response: Combine witness, blinding, and challenge\r\npub fn prove(statement: \u0026Statement, witness: \u0026Witness) -\u003e CryptoResult\u003cProof\u003e {\r\n    // PHASE 1: Validate inputs\r\n    if !witness.satisfies_statement(statement) {\r\n        return Err(CryptoError::ProofError(\r\n            \"Witness does not satisfy statement\".to_string(),\r\n        ));\r\n    }\r\n    \r\n    // PHASE 2: Commitment Phase\r\n    // Generate random blinding factors (must be kept for response phase)\r\n    let blinding = generate_blinding_factors(1, 32);\r\n    \r\n    let commitments = match \u0026statement.statement_type {\r\n        StatementType::DiscreteLog { generator, .. } =\u003e {\r\n            vec![commit_discrete_log(generator, \u0026blinding[0])?]\r\n        }\r\n        StatementType::Preimage { .. } =\u003e {\r\n            vec![commit_preimage(\u0026blinding[0])?]\r\n        }\r\n        StatementType::Range { .. } =\u003e {\r\n            // For range proofs, we'd need Bulletproofs or similar\r\n            // This is a placeholder\r\n            return Err(CryptoError::ProofError(\r\n                \"Range proofs not yet fully implemented\".to_string(),\r\n            ));\r\n        }\r\n        StatementType::Custom { .. } =\u003e {\r\n            return Err(CryptoError::ProofError(\r\n                \"Custom statements not yet supported\".to_string(),\r\n            ));\r\n        }\r\n    };\r\n    \r\n    // PHASE 3: Challenge Phase (Fiat-Shamir)\r\n    let challenge = compute_challenge(statement, \u0026commitments)?;\r\n    \r\n    // PHASE 4: Response Phase\r\n    // Use the SAME blinding factors from commitment phase\r\n    let responses = match \u0026statement.statement_type {\r\n        StatementType::DiscreteLog { .. } =\u003e {\r\n            // Get secret from witness\r\n            let secret = witness.get_secret_bytes()\r\n                .map_err(|e| CryptoError::ProofError(e.to_string()))?;\r\n            vec![compute_discrete_log_response(\u0026secret, \u0026blinding[0], \u0026challenge.value)?]\r\n        }\r\n        StatementType::Preimage { .. } =\u003e {\r\n            vec![compute_preimage_response(\u0026blinding[0], \u0026challenge.value)?]\r\n        }\r\n        _ =\u003e {\r\n            return Err(CryptoError::ProofError(\r\n                \"Unsupported statement type\".to_string(),\r\n            ));\r\n        }\r\n    };\r\n    \r\n    // PHASE 5: Package proof\r\n    let proof_bytes = bincode::serialize(\u0026(\u0026commitments, \u0026challenge, \u0026responses))\r\n        .map_err(|e| CryptoError::SerializationError(e.to_string()))?;\r\n    \r\n    let metadata = ProofMetadata {\r\n        version: 1,\r\n        timestamp: current_timestamp(),\r\n        size: proof_bytes.len(),\r\n    };\r\n    \r\n    Ok(Proof {\r\n        commitments,\r\n        challenge,\r\n        responses,\r\n        metadata,\r\n    })\r\n}\r\n\r\n/// Verify a zero-knowledge proof\r\n/// \r\n/// # Arguments\r\n/// * `statement` - The public statement\r\n/// * `proof` - The proof to verify\r\n/// \r\n/// # Returns\r\n/// `Ok(())` if proof is valid, error otherwise\r\n/// \r\n/// # Implementation\r\n/// 1. Validate proof structure\r\n/// 2. Recompute challenge and verify it matches\r\n/// 3. Verify proof equation (statement-type specific)\r\npub fn verify(statement: \u0026Statement, proof: \u0026Proof) -\u003e CryptoResult\u003c()\u003e {\r\n    // PHASE 1: Validate proof structure\r\n    proof.validate()?;\r\n    \r\n    // PHASE 2: Recompute challenge\r\n    let recomputed_challenge = compute_challenge(statement, \u0026proof.commitments)?;\r\n    \r\n    // Verify challenge matches (critical for security!)\r\n    if recomputed_challenge.value != proof.challenge.value {\r\n        return Err(CryptoError::VerificationError(\r\n            \"Challenge verification failed - possible tampering\".to_string(),\r\n        ));\r\n    }\r\n    \r\n    // PHASE 3: Verify responses (statement-type specific)\r\n    match \u0026statement.statement_type {\r\n        StatementType::DiscreteLog {\r\n            generator,\r\n            public_value,\r\n        } =\u003e {\r\n            if proof.commitments.is_empty() || proof.responses.is_empty() {\r\n                return Err(CryptoError::VerificationError(\r\n                    \"Invalid proof structure\".to_string(),\r\n                ));\r\n            }\r\n            \r\n            verify_discrete_log_proof(\r\n                generator,\r\n                public_value,\r\n                \u0026proof.commitments[0],\r\n                \u0026proof.challenge,\r\n                \u0026proof.responses[0],\r\n            )?;\r\n        }\r\n        StatementType::Preimage {\r\n            hash_function,\r\n            hash_output,\r\n        } =\u003e {\r\n            if proof.commitments.is_empty() || proof.responses.is_empty() {\r\n                return Err(CryptoError::VerificationError(\r\n                    \"Invalid proof structure\".to_string(),\r\n                ));\r\n            }\r\n            \r\n            verify_preimage_proof(\r\n                hash_function,\r\n                hash_output,\r\n                \u0026proof.commitments[0],\r\n                \u0026proof.challenge,\r\n                \u0026proof.responses[0],\r\n            )?;\r\n        }\r\n        StatementType::Range { .. } =\u003e {\r\n            return Err(CryptoError::VerificationError(\r\n                \"Range proofs not yet fully implemented\".to_string(),\r\n            ));\r\n        }\r\n        StatementType::Custom { .. } =\u003e {\r\n            return Err(CryptoError::VerificationError(\r\n                \"Custom statements not yet supported\".to_string(),\r\n            ));\r\n        }\r\n    }\r\n    \r\n    // PHASE 4: All checks passed\r\n    Ok(())\r\n}\r\n\r\n/// Compute Fiat-Shamir challenge\r\npub fn compute_challenge(statement: \u0026Statement, commitments: \u0026[Commitment]) -\u003e CryptoResult\u003cChallenge\u003e {\r\n    use sha3::{Digest, Sha3_256};\r\n\r\n    let mut hasher = Sha3_256::new();\r\n\r\n    // Hash statement\r\n    let stmt_bytes = statement.to_bytes()?;\r\n    hasher.update(\u0026stmt_bytes);\r\n\r\n    // Hash all commitments\r\n    for commitment in commitments {\r\n        hasher.update(\u0026commitment.value);\r\n    }\r\n\r\n    let hash_output = hasher.finalize();\r\n    let mut challenge_bytes = [0u8; 32];\r\n    challenge_bytes.copy_from_slice(\u0026hash_output);\r\n\r\n    Ok(Challenge {\r\n        value: challenge_bytes,\r\n    })\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_proof_structure() {\r\n        let proof = Proof {\r\n            commitments: vec![Commitment {\r\n                value: vec![1, 2, 3],\r\n            }],\r\n            challenge: Challenge { value: [0u8; 32] },\r\n            responses: vec![Response {\r\n                value: vec![4, 5, 6],\r\n            }],\r\n            metadata: ProofMetadata {\r\n                version: 1,\r\n                timestamp: 0,\r\n                size: 100,\r\n            },\r\n        };\r\n\r\n        assert!(proof.validate().is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn test_fiat_shamir_consistency() {\r\n        use crate::proof::statement::{HashFunction, StatementBuilder};\r\n\r\n        let stmt = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, vec![0u8; 32])\r\n            .build()\r\n            .unwrap();\r\n\r\n        let commitments = vec![Commitment {\r\n            value: vec![1, 2, 3],\r\n        }];\r\n\r\n        let c1 = compute_challenge(\u0026stmt, \u0026commitments).unwrap();\r\n        let c2 = compute_challenge(\u0026stmt, \u0026commitments).unwrap();\r\n\r\n        assert_eq!(c1.value, c2.value);\r\n    }\r\n\r\n    #[test]\r\n    fn test_discrete_log_proof_generation() {\r\n        use crate::proof::statement::StatementBuilder;\r\n        use num_bigint::BigUint;\r\n\r\n        // Create statement: prove knowledge of x where g^x = h\r\n        let generator = vec![2u8; 32];\r\n        let secret = vec![42u8; 32];\r\n        \r\n        // Compute public_value = generator^secret (mod p)\r\n        let modulus_bytes = vec![0xFF; 32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n        let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n        let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n\r\n        let statement = StatementBuilder::new()\r\n            .discrete_log(generator.clone(), public_value.clone())\r\n            .build()\r\n            .unwrap();\r\n\r\n        // Create witness with secret exponent\r\n        let witness = Witness::discrete_log(secret);\r\n\r\n        // Generate proof\r\n        let result = prove(\u0026statement, \u0026witness);\r\n        assert!(result.is_ok(), \"Proof generation should succeed\");\r\n\r\n        let proof = result.unwrap();\r\n        assert!(!proof.commitments.is_empty());\r\n        assert!(!proof.responses.is_empty());\r\n        assert_eq!(proof.metadata.version, 1);\r\n    }\r\n\r\n    #[test]\r\n    fn test_discrete_log_proof_verification() {\r\n        use crate::proof::statement::StatementBuilder;\r\n        use num_bigint::BigUint;\r\n\r\n        // Create statement with proper discrete log relationship\r\n        let generator = vec![2u8; 32];\r\n        let secret = vec![42u8; 32];\r\n        \r\n        // Compute public_value = generator^secret (mod p)\r\n        let modulus_bytes = vec![0xFF; 32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n        let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n        let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n\r\n        let statement = StatementBuilder::new()\r\n            .discrete_log(generator, public_value)\r\n            .build()\r\n            .unwrap();\r\n\r\n        // Create witness and generate proof\r\n        let witness = Witness::discrete_log(secret);\r\n        let proof = prove(\u0026statement, \u0026witness).unwrap();\r\n\r\n        // Verify proof\r\n        let result = verify(\u0026statement, \u0026proof);\r\n        assert!(result.is_ok(), \"Proof verification should succeed\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_preimage_proof_generation() {\r\n        use crate::proof::statement::{HashFunction, StatementBuilder};\r\n        use sha3::{Digest, Sha3_256};\r\n\r\n        // Create preimage and its hash\r\n        let preimage = b\"secret message\".to_vec();\r\n        let mut hasher = Sha3_256::new();\r\n        hasher.update(\u0026preimage);\r\n        let hash = hasher.finalize().to_vec();\r\n\r\n        // Create statement\r\n        let statement = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, hash)\r\n            .build()\r\n            .unwrap();\r\n\r\n        // Create witness\r\n        let witness = Witness::preimage(preimage);\r\n\r\n        // Generate proof\r\n        let result = prove(\u0026statement, \u0026witness);\r\n        assert!(result.is_ok(), \"Preimage proof generation should succeed\");\r\n\r\n        let proof = result.unwrap();\r\n        assert!(!proof.commitments.is_empty());\r\n        assert!(!proof.responses.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_preimage_proof_verification() {\r\n        use crate::proof::statement::{HashFunction, StatementBuilder};\r\n        use sha3::{Digest, Sha3_256};\r\n\r\n        // Create preimage and hash\r\n        let preimage = b\"secret message\".to_vec();\r\n        let mut hasher = Sha3_256::new();\r\n        hasher.update(\u0026preimage);\r\n        let hash = hasher.finalize().to_vec();\r\n\r\n        // Create statement and witness\r\n        let statement = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, hash)\r\n            .build()\r\n            .unwrap();\r\n        let witness = Witness::preimage(preimage);\r\n\r\n        // Generate and verify proof\r\n        let proof = prove(\u0026statement, \u0026witness).unwrap();\r\n        let result = verify(\u0026statement, \u0026proof);\r\n        \r\n        assert!(result.is_ok(), \"Preimage proof verification should succeed\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_proof_tampering_detection() {\r\n        use crate::proof::statement::StatementBuilder;\r\n        use num_bigint::BigUint;\r\n\r\n        // Generate original proof with correct discrete log relationship\r\n        let generator = vec![2u8; 32];\r\n        let secret = vec![42u8; 32];\r\n        \r\n        // Compute public_value = generator^secret (mod p)\r\n        let modulus_bytes = vec![0xFF; 32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n        let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n        let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n        \r\n        let statement = StatementBuilder::new()\r\n            .discrete_log(generator, public_value)\r\n            .build()\r\n            .unwrap();\r\n\r\n        let witness = Witness::discrete_log(secret);\r\n        let mut proof = prove(\u0026statement, \u0026witness).unwrap();\r\n\r\n        // Tamper with challenge\r\n        proof.challenge.value[0] ^= 0xFF;\r\n\r\n        // Verification should fail\r\n        let result = verify(\u0026statement, \u0026proof);\r\n        assert!(result.is_err(), \"Tampered proof should fail verification\");\r\n        \r\n        if let Err(e) = result {\r\n            match e {\r\n                CryptoError::VerificationError(msg) =\u003e {\r\n                    assert!(msg.contains(\"Challenge\"));\r\n                }\r\n                _ =\u003e panic!(\"Expected VerificationError\"),\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_invalid_witness_rejection() {\r\n        use crate::proof::statement::{HashFunction, StatementBuilder};\r\n        use sha3::{Digest, Sha3_256};\r\n\r\n        // Create statement with specific hash\r\n        let correct_preimage = b\"correct secret\".to_vec();\r\n        let mut hasher = Sha3_256::new();\r\n        hasher.update(\u0026correct_preimage);\r\n        let hash = hasher.finalize().to_vec();\r\n\r\n        let statement = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, hash)\r\n            .build()\r\n            .unwrap();\r\n\r\n        // Create witness with WRONG preimage\r\n        let wrong_preimage = b\"wrong secret\".to_vec();\r\n        let witness = Witness::preimage(wrong_preimage);\r\n\r\n        // Proof generation should fail (witness doesn't satisfy statement)\r\n        let result = prove(\u0026statement, \u0026witness);\r\n        assert!(result.is_err(), \"Invalid witness should be rejected\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_proof_soundness() {\r\n        use crate::proof::statement::StatementBuilder;\r\n        use num_bigint::BigUint;\r\n\r\n        let generator = vec![2u8; 32];\r\n        let modulus_bytes = vec![0xFF; 32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n        let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n\r\n        // Generate 5 different statements and prove each one correctly\r\n        for i in 1..=5 {\r\n            let secret = vec![i as u8; 32];\r\n            \r\n            // Compute correct public_value = generator^secret (mod p)\r\n            let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n            let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n            \r\n            let statement = StatementBuilder::new()\r\n                .discrete_log(generator.clone(), public_value)\r\n                .build()\r\n                .unwrap();\r\n            \r\n            let witness = Witness::discrete_log(secret);\r\n            \r\n            let proof_result = prove(\u0026statement, \u0026witness);\r\n            assert!(proof_result.is_ok(), \"Proof {} generation failed\", i);\r\n            \r\n            let proof = proof_result.unwrap();\r\n            let verify_result = verify(\u0026statement, \u0026proof);\r\n            assert!(verify_result.is_ok(), \"Proof {} verification failed\", i);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_proof_serialization() {\r\n        use crate::proof::statement::StatementBuilder;\r\n        use num_bigint::BigUint;\r\n\r\n        // Generate proof with correct discrete log relationship\r\n        let generator = vec![2u8; 32];\r\n        let secret = vec![42u8; 32];\r\n        \r\n        // Compute public_value = generator^secret (mod p)\r\n        let modulus_bytes = vec![0xFF; 32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n        let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n        let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n        \r\n        let statement = StatementBuilder::new()\r\n            .discrete_log(generator, public_value)\r\n            .build()\r\n            .unwrap();\r\n\r\n        let witness = Witness::discrete_log(secret);\r\n        let proof = prove(\u0026statement, \u0026witness).unwrap();\r\n\r\n        // Serialize\r\n        let bytes = proof.to_bytes().unwrap();\r\n        assert!(!bytes.is_empty());\r\n\r\n        // Deserialize\r\n        let deserialized = Proof::from_bytes(\u0026bytes).unwrap();\r\n\r\n        // Verify deserialized proof\r\n        let result = verify(\u0026statement, \u0026deserialized);\r\n        assert!(result.is_ok(), \"Deserialized proof should verify\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_proof_metadata() {\r\n        use crate::proof::statement::StatementBuilder;\r\n        use num_bigint::BigUint;\r\n\r\n        let generator = vec![2u8; 32];\r\n        let secret = vec![42u8; 32];\r\n        \r\n        // Compute public_value = generator^secret (mod p)\r\n        let modulus_bytes = vec![0xFF; 32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n        let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n        let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n        \r\n        let statement = StatementBuilder::new()\r\n            .discrete_log(generator, public_value)\r\n            .build()\r\n            .unwrap();\r\n\r\n        let witness = Witness::discrete_log(secret);\r\n        let proof = prove(\u0026statement, \u0026witness).unwrap();\r\n\r\n        // Check metadata\r\n        assert_eq!(proof.metadata.version, 1);\r\n        assert!(proof.metadata.timestamp \u003e 0);\r\n        assert!(proof.metadata.size \u003e 0);\r\n        assert_eq!(proof.size(), proof.metadata.size);\r\n    }\r\n\r\n    #[test]\r\n    fn test_proof_validation_errors() {\r\n        let bad_proof_empty = Proof { commitments: vec![], challenge: Challenge { value: [0u8;32] }, responses: vec![Response{ value: vec![1]}], metadata: ProofMetadata{version:1,timestamp:0,size:0} };        \r\n        assert!(bad_proof_empty.validate().is_err());\r\n        let bad_proof_no_responses = Proof { commitments: vec![Commitment{ value: vec![1]}], challenge: Challenge { value: [0u8;32] }, responses: vec![], metadata: ProofMetadata{version:1,timestamp:0,size:0} };        \r\n        assert!(bad_proof_no_responses.validate().is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_discrete_log_commitment_tamper_failure() {\r\n        use crate::proof::statement::StatementBuilder; use num_bigint::BigUint;\r\n        let generator = vec![2u8;32]; let secret = vec![42u8;32];\r\n        let modulus_bytes = vec![0xFF;32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator); let secret_big = BigUint::from_bytes_be(\u0026secret); let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026secret_big,\u0026mod_big).to_bytes_be();\r\n        let statement = StatementBuilder::new().discrete_log(generator.clone(), public_value).build().unwrap();\r\n        let witness = Witness::discrete_log(secret);\r\n        let mut proof = prove(\u0026statement,\u0026witness).unwrap();\r\n        // tamper commitment (will cause challenge mismatch rather than equation failure)\r\n        proof.commitments[0].value[0] ^= 0xAA; // flip byte\r\n        let result = verify(\u0026statement,\u0026proof);\r\n        assert!(matches!(result, Err(CryptoError::VerificationError(msg)) if msg.contains(\"Challenge\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_discrete_log_response_tamper_failure() {\r\n        use crate::proof::statement::StatementBuilder; use num_bigint::BigUint;\r\n        let generator = vec![2u8;32]; let secret = vec![42u8;32];\r\n        let modulus_bytes = vec![0xFF;32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator); let secret_big = BigUint::from_bytes_be(\u0026secret); let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026secret_big,\u0026mod_big).to_bytes_be();\r\n        let statement = StatementBuilder::new().discrete_log(generator.clone(), public_value).build().unwrap();\r\n        let witness = Witness::discrete_log(secret);\r\n        let mut proof = prove(\u0026statement,\u0026witness).unwrap();\r\n        // Tamper response drastically (zero out bytes to force equation failure)\r\n        let len = proof.responses[0].value.len();\r\n        proof.responses[0].value = vec![0u8; len];\r\n        let result = verify(\u0026statement,\u0026proof);\r\n        assert!(result.is_err());\r\n        if let Err(CryptoError::VerificationError(msg)) = result { assert!(msg.contains(\"Discrete log\") || msg.contains(\"verification failed\")); } else { panic!(\"Expected VerificationError\"); }\r\n    }\r\n\r\n    #[test]\r\n    fn test_preimage_response_tamper_commitment_failure() {\r\n        use crate::proof::statement::{HashFunction, StatementBuilder}; use sha3::{Digest,Sha3_256};\r\n        let preimage = b\"secret msg\".to_vec(); let mut hasher = Sha3_256::new(); hasher.update(\u0026preimage); let hash = hasher.finalize().to_vec();\r\n        let statement = StatementBuilder::new().preimage(HashFunction::SHA3_256, hash).build().unwrap();\r\n        let witness = Witness::preimage(preimage);\r\n        let mut proof = prove(\u0026statement,\u0026witness).unwrap();\r\n        // Tamper response so recomputed blinding mismatches commitment\r\n        proof.responses[0].value[0] ^= 0xAA;\r\n        let result = verify(\u0026statement,\u0026proof);\r\n        assert!(matches!(result, Err(CryptoError::VerificationError(msg)) if msg.contains(\"commitment\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_truncated_proof_deserialization_failure() {\r\n        use crate::proof::statement::StatementBuilder; use num_bigint::BigUint;\r\n        let generator = vec![2u8;32]; let secret = vec![42u8;32];\r\n        let modulus_bytes = vec![0xFF;32]; let gen_big = BigUint::from_bytes_be(\u0026generator); let secret_big = BigUint::from_bytes_be(\u0026secret); let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes); let public_value = gen_big.modpow(\u0026secret_big,\u0026mod_big).to_bytes_be();\r\n        let statement = StatementBuilder::new().discrete_log(generator.clone(), public_value).build().unwrap();\r\n        let witness = Witness::discrete_log(secret);\r\n        let proof = prove(\u0026statement,\u0026witness).unwrap();\r\n        let bytes = proof.to_bytes().unwrap();\r\n        let truncated = \u0026bytes[..bytes.len()/4];\r\n        let result = Proof::from_bytes(truncated);\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_commitment_reordering_challenge_mismatch() {\r\n        use crate::proof::statement::StatementBuilder; use num_bigint::BigUint;\r\n        let generator = vec![2u8;32]; let secret = vec![42u8;32];\r\n        let modulus_bytes = vec![0xFF;32]; let gen_big = BigUint::from_bytes_be(\u0026generator); let secret_big = BigUint::from_bytes_be(\u0026secret); let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes); let public_value = gen_big.modpow(\u0026secret_big,\u0026mod_big).to_bytes_be();\r\n        let statement = StatementBuilder::new().discrete_log(generator.clone(), public_value).build().unwrap();\r\n        let witness = Witness::discrete_log(secret);\r\n        let mut proof = prove(\u0026statement,\u0026witness).unwrap();\r\n        // Duplicate commitment causing challenge mismatch\r\n        let first = proof.commitments[0].clone();\r\n        proof.commitments.push(first); // modifies commitment list\r\n        let result = verify(\u0026statement,\u0026proof);\r\n        assert!(matches!(result, Err(CryptoError::VerificationError(msg)) if msg.contains(\"Challenge\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_manual_blake3_preimage_verification_failure() {\r\n        use crate::proof::statement::{StatementBuilder, HashFunction};\r\n        // Build statement with Blake3 (unsupported in verify_preimage_proof)\r\n        let statement = StatementBuilder::new()\r\n            .preimage(HashFunction::Blake3, vec![1,2,3,4])\r\n            .build()\r\n            .unwrap();\r\n        // Manually fabricate a proof with one commitment/response and matching challenge\r\n        let commitments = vec![Commitment { value: vec![0xAA; 32] }];\r\n        let challenge = compute_challenge(\u0026statement,\u0026commitments).unwrap();\r\n        let responses = vec![Response { value: vec![0xBB; 32] }];\r\n        let proof = Proof { commitments, challenge, responses, metadata: ProofMetadata { version:1, timestamp:0, size:0 } };\r\n        let result = verify(\u0026statement,\u0026proof);\r\n        assert!(matches!(result, Err(CryptoError::VerificationError(msg)) if msg.contains(\"Blake3\")));\r\n    }\r\n}\r\n","traces":[{"line":56,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":57,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":58,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":60,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":63,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":67,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":68,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":75,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":76,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":81,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":95,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":96,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":97,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":98,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":103,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":104,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":136,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":137,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":138,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":140,"address":[],"length":0,"stats":{"Line":5404319552844595200}},{"line":141,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":145,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":147,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":148,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":158,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":160,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":162,"address":[],"length":0,"stats":{"Line":5404319552844595200}},{"line":164,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":168,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":172,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":173,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":174,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":176,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":184,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":189,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":190,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":191,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":194,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":196,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":200,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":205,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":206,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":207,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":208,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":212,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":220,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":227,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":228,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":231,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":232,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":233,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":234,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":238,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":239,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":240,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":241,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":245,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":246,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":247,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":251,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":252,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":254,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":255,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":261,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":272,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":273,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":274,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":275,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":280,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":282,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":283,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":284,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":294,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":299,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":300,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":301,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":309,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":336,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":338,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":339,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":340,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":346,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":348,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":349,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":350,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":353,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":374,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":377,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":378,"address":[],"length":0,"stats":{"Line":1080863910568919044}},{"line":379,"address":[],"length":0,"stats":{"Line":5404319552844595200}},{"line":382,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":393,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":397,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":398,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":401,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":402,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":403,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":404,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":405,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":422,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":424,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":427,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":430,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":431,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":432,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":437,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":439,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":440,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":442,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":450,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":451,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":452,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":453,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":457,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":458,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":460,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":468,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":469,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":470,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":471,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":491,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":494,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":497,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":498,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":501,"address":[],"length":0,"stats":{"Line":11745387828182253568}},{"line":502,"address":[],"length":0,"stats":{"Line":5908722711110090752}},{"line":505,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":506,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":507,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":509,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":510,"address":[],"length":0,"stats":{"Line":2882303761517117440}}],"covered":142,"coverable":177},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","proof","statement.rs"],"content":"//! Statement structures for zero-knowledge proofs\r\n//!\r\n//! A Statement represents the public claim being proven.\r\n\r\nuse crate::{CryptoError, CryptoResult};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// Types of statements that can be proven\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub enum StatementType {\r\n    /// Prove knowledge of discrete log: g^x = h\r\n    DiscreteLog {\r\n        /// Generator\r\n        generator: Vec\u003cu8\u003e,\r\n        /// Public value\r\n        public_value: Vec\u003cu8\u003e,\r\n    },\r\n\r\n    /// Prove knowledge of hash preimage: H(x) = y\r\n    Preimage {\r\n        /// Hash function used\r\n        hash_function: HashFunction,\r\n        /// Hash output\r\n        hash_output: Vec\u003cu8\u003e,\r\n    },\r\n\r\n    /// Prove x ∈ [min, max] (range proof)\r\n    Range {\r\n        /// Minimum value\r\n        min: u64,\r\n        /// Maximum value\r\n        max: u64,\r\n        /// Commitment to value\r\n        commitment: Vec\u003cu8\u003e,\r\n    },\r\n\r\n    /// Custom statement (placeholder)\r\n    Custom {\r\n        /// Description\r\n        description: String,\r\n    },\r\n}\r\n\r\n/// Supported hash functions\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub enum HashFunction {\r\n    /// SHA3-256\r\n    SHA3_256,\r\n    /// SHA-256\r\n    SHA256,\r\n    /// BLAKE3\r\n    Blake3,\r\n}\r\n\r\n/// Complete statement for a zero-knowledge proof\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct Statement {\r\n    /// Type and parameters of the statement\r\n    pub statement_type: StatementType,\r\n    /// Version for future compatibility\r\n    pub version: u8,\r\n}\r\n\r\nimpl Statement {\r\n    /// Validate statement consistency\r\n    pub fn validate(\u0026self) -\u003e CryptoResult\u003c()\u003e {\r\n        match \u0026self.statement_type {\r\n            StatementType::DiscreteLog { generator, public_value } =\u003e {\r\n                if generator.is_empty() || public_value.is_empty() {\r\n                    return Err(CryptoError::InvalidParameter(\r\n                        \"Discrete log statement requires non-empty values\".to_string(),\r\n                    ));\r\n                }\r\n            }\r\n            StatementType::Preimage { hash_output, .. } =\u003e {\r\n                if hash_output.is_empty() {\r\n                    return Err(CryptoError::InvalidParameter(\r\n                        \"Preimage statement requires non-empty hash\".to_string(),\r\n                    ));\r\n                }\r\n            }\r\n            StatementType::Range { min, max, .. } =\u003e {\r\n                if min \u003e= max {\r\n                    return Err(CryptoError::InvalidParameter(\r\n                        \"Range min must be less than max\".to_string(),\r\n                    ));\r\n                }\r\n            }\r\n            StatementType::Custom { .. } =\u003e {}\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    /// Serialize to bytes\r\n    pub fn to_bytes(\u0026self) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\r\n        bincode::serialize(self).map_err(|e| {\r\n            CryptoError::SerializationError(format!(\"Failed to serialize statement: {}\", e))\r\n        })\r\n    }\r\n\r\n    /// Deserialize from bytes\r\n    pub fn from_bytes(bytes: \u0026[u8]) -\u003e CryptoResult\u003cSelf\u003e {\r\n        bincode::deserialize(bytes).map_err(|e| {\r\n            CryptoError::SerializationError(format!(\"Failed to deserialize statement: {}\", e))\r\n        })\r\n    }\r\n\r\n    /// Compute hash of statement\r\n    pub fn hash(\u0026self) -\u003e CryptoResult\u003c[u8; 32]\u003e {\r\n        use sha3::{Digest, Sha3_256};\r\n\r\n        let bytes = self.to_bytes()?;\r\n        let mut hasher = Sha3_256::new();\r\n        hasher.update(\u0026bytes);\r\n        let result = hasher.finalize();\r\n\r\n        let mut hash = [0u8; 32];\r\n        hash.copy_from_slice(\u0026result);\r\n        Ok(hash)\r\n    }\r\n}\r\n\r\n/// Builder for constructing statements\r\npub struct StatementBuilder {\r\n    statement_type: Option\u003cStatementType\u003e,\r\n}\r\n\r\nimpl StatementBuilder {\r\n    /// Create a new statement builder\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            statement_type: None,\r\n        }\r\n    }\r\n\r\n    /// Build a discrete log statement\r\n    pub fn discrete_log(mut self, generator: Vec\u003cu8\u003e, public_value: Vec\u003cu8\u003e) -\u003e Self {\r\n        self.statement_type = Some(StatementType::DiscreteLog {\r\n            generator,\r\n            public_value,\r\n        });\r\n        self\r\n    }\r\n\r\n    /// Build a preimage statement\r\n    pub fn preimage(mut self, hash_function: HashFunction, hash_output: Vec\u003cu8\u003e) -\u003e Self {\r\n        self.statement_type = Some(StatementType::Preimage {\r\n            hash_function,\r\n            hash_output,\r\n        });\r\n        self\r\n    }\r\n\r\n    /// Build a range statement\r\n    pub fn range(mut self, min: u64, max: u64, commitment: Vec\u003cu8\u003e) -\u003e Self {\r\n        self.statement_type = Some(StatementType::Range {\r\n            min,\r\n            max,\r\n            commitment,\r\n        });\r\n        self\r\n    }\r\n\r\n    /// Build the statement\r\n    pub fn build(self) -\u003e CryptoResult\u003cStatement\u003e {\r\n        let statement_type = self.statement_type.ok_or_else(|| {\r\n            CryptoError::InvalidParameter(\"Statement type not set\".to_string())\r\n        })?;\r\n\r\n        let statement = Statement {\r\n            statement_type,\r\n            version: 1,\r\n        };\r\n\r\n        statement.validate()?;\r\n        Ok(statement)\r\n    }\r\n}\r\n\r\nimpl Default for StatementBuilder {\r\n    fn default() -\u003e Self {\r\n        Self::new()\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_statement_builder() {\r\n        let stmt = StatementBuilder::new()\r\n            .discrete_log(vec![1, 2, 3], vec![4, 5, 6])\r\n            .build()\r\n            .unwrap();\r\n\r\n        assert!(matches!(stmt.statement_type, StatementType::DiscreteLog { .. }));\r\n    }\r\n\r\n    #[test]\r\n    fn test_statement_serialization() {\r\n        let stmt = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, vec![0u8; 32])\r\n            .build()\r\n            .unwrap();\r\n\r\n        let bytes = stmt.to_bytes().unwrap();\r\n        let recovered = Statement::from_bytes(\u0026bytes).unwrap();\r\n\r\n        assert_eq!(stmt.version, recovered.version);\r\n    }\r\n\r\n    #[test]\r\n    fn test_invalid_discrete_log_statement() {\r\n        let result = StatementBuilder::new()\r\n            .discrete_log(vec![], vec![1,2,3])\r\n            .build();\r\n        assert!(result.is_err());\r\n        let result2 = StatementBuilder::new()\r\n            .discrete_log(vec![1,2,3], vec![])\r\n            .build();\r\n        assert!(result2.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_invalid_preimage_statement_empty_hash() {\r\n        let result = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, vec![])\r\n            .build();\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_invalid_range_statement_min_greater_equal_max() {\r\n        let result = StatementBuilder::new()\r\n            .range(10, 10, vec![0u8;32])\r\n            .build();\r\n        assert!(result.is_err());\r\n        let result2 = StatementBuilder::new()\r\n            .range(20, 10, vec![0u8;32])\r\n            .build();\r\n        assert!(result2.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_builder_missing_type_rejection() {\r\n        let builder = StatementBuilder::new();\r\n        let result = builder.build();\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_statement_hash_length() {\r\n        let stmt = StatementBuilder::new()\r\n            .discrete_log(vec![1,2,3], vec![4,5,6])\r\n            .build()\r\n            .unwrap();\r\n        let hash = stmt.hash().unwrap();\r\n        assert_eq!(hash.len(), 32);\r\n    }\r\n}\r\n","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":67,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":68,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":69,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":70,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":75,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":76,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":77,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":78,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":82,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":83,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":84,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":85,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":95,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":96,"address":[],"length":0,"stats":{"Line":9079256848778919936}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":103,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":112,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":113,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":114,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":115,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":117,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":118,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":119,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":130,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":137,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":138,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":139,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":140,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":142,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":146,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":147,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":148,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":149,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":151,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":155,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":156,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":157,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":158,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":159,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":161,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":165,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":166,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":167,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":175,"address":[],"length":0,"stats":{"Line":5404319552844595200}},{"line":176,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}}],"covered":49,"coverable":54},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","proof","witness.rs"],"content":"//! Witness structures for zero-knowledge proofs\r\n//!\r\n//! A Witness represents the SECRET knowledge that proves a statement.\r\n//! This must NEVER be transmitted or stored insecurely.\r\n\r\nuse crate::proof::statement::{HashFunction, Statement, StatementType};\r\nuse zeroize::{Zeroize, ZeroizeOnDrop};\r\n\r\n/// Witness type indicator\r\n#[derive(Clone, Debug)]\r\npub enum WitnessType {\r\n    /// Discrete logarithm witness\r\n    DiscreteLog,\r\n    /// Hash preimage witness\r\n    Preimage,\r\n    /// Range proof witness\r\n    Range,\r\n    /// Custom witness\r\n    Custom,\r\n}\r\n\r\n/// Secret data for different witness types\r\n#[derive(Zeroize, ZeroizeOnDrop)]\r\nenum SecretData {\r\n    /// Discrete log witness: the exponent x where g^x = h\r\n    DiscreteLog(Vec\u003cu8\u003e),\r\n\r\n    /// Preimage witness: x where H(x) = y\r\n    Preimage(Vec\u003cu8\u003e),\r\n\r\n    /// Range proof witness: (value, blinding_factor)\r\n    Range { value: u64, blinding: Vec\u003cu8\u003e },\r\n\r\n    /// Custom witness data\r\n    Custom(Vec\u003cu8\u003e),\r\n}\r\n\r\n/// Witness structure\r\n/// \r\n/// Note: SecretData implements ZeroizeOnDrop to secure sensitive data\r\npub struct Witness {\r\n    /// The secret data (automatically zeroized via ZeroizeOnDrop)\r\n    secret_data: SecretData,\r\n    /// Randomness used in proof\r\n    randomness: Vec\u003cu8\u003e,\r\n    /// Type indicator\r\n    witness_type: WitnessType,\r\n}\r\n\r\nimpl Witness {\r\n    /// Create witness for discrete log proof\r\n    pub fn discrete_log(exponent: Vec\u003cu8\u003e) -\u003e Self {\r\n        let mut randomness = vec![0u8; 32];\r\n        rand::Rng::fill(\u0026mut rand::thread_rng(), \u0026mut randomness[..]);\r\n\r\n        Self {\r\n            secret_data: SecretData::DiscreteLog(exponent),\r\n            randomness,\r\n            witness_type: WitnessType::DiscreteLog,\r\n        }\r\n    }\r\n\r\n    /// Create witness for hash preimage proof\r\n    pub fn preimage(preimage: Vec\u003cu8\u003e) -\u003e Self {\r\n        let mut randomness = vec![0u8; 32];\r\n        rand::Rng::fill(\u0026mut rand::thread_rng(), \u0026mut randomness[..]);\r\n\r\n        Self {\r\n            secret_data: SecretData::Preimage(preimage),\r\n            randomness,\r\n            witness_type: WitnessType::Preimage,\r\n        }\r\n    }\r\n\r\n    /// Create witness for range proof\r\n    pub fn range(value: u64, blinding: Vec\u003cu8\u003e) -\u003e Self {\r\n        let mut randomness = vec![0u8; 32];\r\n        rand::Rng::fill(\u0026mut rand::thread_rng(), \u0026mut randomness[..]);\r\n\r\n        Self {\r\n            secret_data: SecretData::Range { value, blinding },\r\n            randomness,\r\n            witness_type: WitnessType::Range,\r\n        }\r\n    }\r\n\r\n    /// Validate witness satisfies the statement\r\n    pub fn satisfies_statement(\u0026self, statement: \u0026Statement) -\u003e bool {\r\n        match (\u0026self.secret_data, \u0026statement.statement_type) {\r\n            (SecretData::Preimage(pre), StatementType::Preimage { hash_function, hash_output }) =\u003e {\r\n                self.verify_preimage(hash_function, pre, hash_output)\r\n            }\r\n            (SecretData::DiscreteLog(secret), StatementType::DiscreteLog { generator, public_value }) =\u003e {\r\n                // Verify that generator^secret = public_value (mod p)\r\n                use num_bigint::BigUint;\r\n                \r\n                let modulus_bytes = vec![0xFF; 32];\r\n                let gen_big = BigUint::from_bytes_be(generator);\r\n                let secret_big = BigUint::from_bytes_be(secret);\r\n                let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n                let public_big = BigUint::from_bytes_be(public_value);\r\n                \r\n                let computed = gen_big.modpow(\u0026secret_big, \u0026mod_big);\r\n                computed == public_big\r\n            }\r\n            (\r\n                SecretData::Range { value, .. },\r\n                StatementType::Range {\r\n                    min,\r\n                    max,\r\n                    commitment: _,\r\n                },\r\n            ) =\u003e *value \u003e= *min \u0026\u0026 *value \u003c= *max,\r\n            _ =\u003e false,\r\n        }\r\n    }\r\n\r\n    /// Get witness type\r\n    pub fn witness_type(\u0026self) -\u003e \u0026WitnessType {\r\n        \u0026self.witness_type\r\n    }\r\n\r\n    /// Access randomness (used in proof generation)\r\n    pub(crate) fn randomness(\u0026self) -\u003e \u0026[u8] {\r\n        \u0026self.randomness\r\n    }\r\n\r\n    /// Get secret bytes for proof generation\r\n    /// \r\n    /// This is used internally by the proof system.\r\n    /// Should never be exposed outside the proof module.\r\n    pub(crate) fn get_secret_bytes(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e, \u0026'static str\u003e {\r\n        match \u0026self.secret_data {\r\n            SecretData::DiscreteLog(bytes) =\u003e Ok(bytes.clone()),\r\n            SecretData::Preimage(bytes) =\u003e Ok(bytes.clone()),\r\n            SecretData::Range { value, blinding } =\u003e {\r\n                // For range proofs, combine value and blinding\r\n                let mut result = value.to_be_bytes().to_vec();\r\n                result.extend_from_slice(blinding);\r\n                Ok(result)\r\n            }\r\n            SecretData::Custom(bytes) =\u003e Ok(bytes.clone()),\r\n        }\r\n    }\r\n\r\n    /// Verify hash preimage\r\n    fn verify_preimage(\r\n        \u0026self,\r\n        hash_fn: \u0026HashFunction,\r\n        preimage: \u0026[u8],\r\n        expected_hash: \u0026[u8],\r\n    ) -\u003e bool {\r\n        use sha3::{Digest, Sha3_256};\r\n\r\n        let actual_hash = match hash_fn {\r\n            HashFunction::SHA3_256 =\u003e {\r\n                let mut hasher = Sha3_256::new();\r\n                hasher.update(preimage);\r\n                hasher.finalize().to_vec()\r\n            }\r\n            _ =\u003e return false,\r\n        };\r\n\r\n        constant_time_eq(\u0026actual_hash, expected_hash)\r\n    }\r\n\r\n    /// Securely destroy witness\r\n    pub fn destroy(self) {\r\n        // Drop is called automatically, which triggers zeroization\r\n        drop(self);\r\n    }\r\n}\r\n\r\n/// Constant-time byte array equality\r\nfn constant_time_eq(a: \u0026[u8], b: \u0026[u8]) -\u003e bool {\r\n    if a.len() != b.len() {\r\n        return false;\r\n    }\r\n\r\n    let mut result = 0u8;\r\n    for (x, y) in a.iter().zip(b.iter()) {\r\n        result |= x ^ y;\r\n    }\r\n\r\n    result == 0\r\n}\r\n\r\n// Drop is automatically implemented by ZeroizeOnDrop derive\r\n// which handles secure zeroization of all fields\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::proof::StatementBuilder;\r\n\r\n    #[test]\r\n    fn test_preimage_witness() {\r\n        use sha3::{Digest, Sha3_256};\r\n\r\n        let preimage = b\"secret message\";\r\n        let hash = Sha3_256::digest(preimage).to_vec();\r\n\r\n        let witness = Witness::preimage(preimage.to_vec());\r\n        let statement = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, hash)\r\n            .build()\r\n            .unwrap();\r\n\r\n        assert!(witness.satisfies_statement(\u0026statement));\r\n    }\r\n\r\n    #[test]\r\n    fn test_constant_time_equality() {\r\n        let a = vec![1, 2, 3, 4];\r\n        let b = vec![1, 2, 3, 4];\r\n        let c = vec![1, 2, 3, 5];\r\n\r\n        assert!(constant_time_eq(\u0026a, \u0026b));\r\n        assert!(!constant_time_eq(\u0026a, \u0026c));\r\n    }\r\n\r\n    #[test]\r\n    fn test_witness_types() {\r\n        let witness = Witness::discrete_log(vec![1, 2, 3]);\r\n        assert!(matches!(witness.witness_type(), \u0026WitnessType::DiscreteLog));\r\n\r\n        let witness = Witness::preimage(vec![4, 5, 6]);\r\n        assert!(matches!(witness.witness_type(), \u0026WitnessType::Preimage));\r\n    }\r\n\r\n    #[test]\r\n    fn test_discrete_log_witness_mismatch() {\r\n        use num_bigint::BigUint;\r\n        let generator = vec![2u8;32];\r\n        let secret = vec![5u8;32];\r\n        // public_value computed with different secret to force mismatch\r\n        let wrong_secret = vec![7u8;32];\r\n        let modulus_bytes = vec![0xFF;32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n        let wrong_big = BigUint::from_bytes_be(\u0026wrong_secret);\r\n        let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026wrong_big, \u0026mod_big).to_bytes_be();\r\n        let statement = StatementBuilder::new()\r\n            .discrete_log(generator.clone(), public_value)\r\n            .build()\r\n            .unwrap();\r\n        let witness = Witness::discrete_log(secret);\r\n        assert!(!witness.satisfies_statement(\u0026statement));\r\n    }\r\n\r\n    #[test]\r\n    fn test_preimage_witness_mismatch() {\r\n        use sha3::{Digest, Sha3_256};\r\n        let preimage = b\"correct\".to_vec();\r\n        let mut hasher = Sha3_256::new(); hasher.update(\u0026preimage); let hash = hasher.finalize().to_vec();\r\n        let statement = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, hash)\r\n            .build()\r\n            .unwrap();\r\n        let wrong_witness = Witness::preimage(b\"wrong\".to_vec());\r\n        assert!(!wrong_witness.satisfies_statement(\u0026statement));\r\n    }\r\n\r\n    #[test]\r\n    fn test_range_witness_out_of_range() {\r\n        let statement = StatementBuilder::new()\r\n            .range(10, 20, vec![0u8;32])\r\n            .build()\r\n            .unwrap();\r\n        let witness = Witness::range(25, vec![1,2,3]);\r\n        assert!(!witness.satisfies_statement(\u0026statement));\r\n    }\r\n}\r\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":53,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":54,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":57,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":64,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":65,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":66,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":69,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":76,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":77,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":78,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":81,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":88,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":89,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":90,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":91,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":93,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":97,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":98,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":99,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":100,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":101,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":103,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":104,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":109,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":110,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":113,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":120,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":133,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":134,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":155,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":157,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":158,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":159,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":176,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":181,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":182,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":185,"address":[],"length":0,"stats":{"Line":720575940379279360}}],"covered":45,"coverable":58},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","utils","math.rs"],"content":"//! Mathematical primitives\r\n//!\r\n//! Common mathematical operations for cryptography.\r\n\r\nuse crate::{CryptoError, CryptoResult};\r\n\r\n/// Modular exponentiation: base^exp mod modulus\r\npub fn modular_exponentiation(_base: \u0026[u8], _exp: \u0026[u8], _modulus: u64) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\r\n    // TODO: Implement efficient modular exponentiation\r\n    // For now, return a placeholder\r\n    Err(CryptoError::MathError(\r\n        \"Not yet implemented\".to_string(),\r\n    ))\r\n}\r\n\r\n/// Modular multiplicative inverse: find x such that (a * x) mod m = 1\r\npub fn mod_inverse(a: i64, m: i64) -\u003e CryptoResult\u003ci64\u003e {\r\n    // Extended Euclidean algorithm\r\n    let (mut old_r, mut r) = (a, m);\r\n    let (mut old_s, mut s) = (1i64, 0i64);\r\n\r\n    while r != 0 {\r\n        let quotient = old_r / r;\r\n        let temp_r = r;\r\n        r = old_r - quotient * r;\r\n        old_r = temp_r;\r\n\r\n        let temp_s = s;\r\n        s = old_s - quotient * s;\r\n        old_s = temp_s;\r\n    }\r\n\r\n    if old_r \u003e 1 {\r\n        return Err(CryptoError::MathError(format!(\r\n            \"{} has no inverse mod {}\",\r\n            a, m\r\n        )));\r\n    }\r\n\r\n    if old_s \u003c 0 {\r\n        old_s += m;\r\n    }\r\n\r\n    Ok(old_s)\r\n}\r\n\r\n/// Greatest common divisor\r\npub fn gcd(mut a: i64, mut b: i64) -\u003e i64 {\r\n    while b != 0 {\r\n        let temp = b;\r\n        b = a % b;\r\n        a = temp;\r\n    }\r\n    a.abs()\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_gcd() {\r\n        assert_eq!(gcd(48, 18), 6);\r\n        assert_eq!(gcd(17, 5), 1);\r\n        assert_eq!(gcd(100, 50), 50);\r\n    }\r\n\r\n    #[test]\r\n    fn test_mod_inverse() {\r\n        // 3 * 5 = 15 ≡ 1 (mod 7)\r\n        let inv = mod_inverse(3, 7).unwrap();\r\n        assert_eq!((3 * inv) % 7, 1);\r\n\r\n        // 2 has no inverse mod 6 (not coprime)\r\n        assert!(mod_inverse(2, 6).is_err());\r\n    }\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":19,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":20,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":22,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":23,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":24,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":25,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":26,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":28,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":29,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":30,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":33,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":34,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":36,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":40,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":41,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":44,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":48,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":49,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":50,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":51,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":52,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":54,"address":[],"length":0,"stats":{"Line":432345564227567616}}],"covered":24,"coverable":27},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","utils","mod.rs"],"content":"//! Utility functions and mathematical primitives\r\n//!\r\n//! This module provides common utility functions used throughout the library.\r\n\r\npub mod math;\r\n\r\n// Re-export common functions\r\npub use math::{mod_inverse, modular_exponentiation};\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","tests","comprehensive_tests.rs"],"content":"//! Comprehensive test suite for nexuszero-crypto\r\n//!\r\n//! This module provides extensive testing including:\r\n//! - Correctness tests for all security levels\r\n//! - Property-based testing with proptest\r\n//! - Security property verification\r\n//! - Edge case testing\r\n\r\nuse nexuszero_crypto::lattice::*;\r\nuse proptest::prelude::*;\r\n\r\n#[cfg(test)]\r\nmod correctness_tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_lwe_correctness_across_security_levels() {\r\n        use rand::thread_rng;\r\n        \r\n        // Test all three security levels\r\n        let params_128 = lwe::LWEParameters::new(512, 1024, 12289, 3.2);\r\n        let params_192 = lwe::LWEParameters::new(1024, 2048, 40961, 3.2);\r\n        let params_256 = lwe::LWEParameters::new(2048, 4096, 65537, 3.2);\r\n\r\n        for params in [params_128, params_192, params_256] {\r\n            let mut rng = thread_rng();\r\n            let (sk, pk) = lwe::keygen(\u0026params, \u0026mut rng).unwrap();\r\n\r\n            // Test 10 rounds with both true and false\r\n            for message_bit in [true, false] {\r\n                let ct = lwe::encrypt(\u0026pk, message_bit, \u0026params, \u0026mut rng).unwrap();\r\n                assert_eq!(\r\n                    lwe::decrypt(\u0026sk, \u0026ct, \u0026params).unwrap(),\r\n                    message_bit,\r\n                    \"Failed at n={}, message={}\", params.n, message_bit\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_lwe_encryption_randomness() {\r\n        use rand::thread_rng;\r\n        \r\n        let params = lwe::LWEParameters::new(512, 1024, 12289, 3.2);\r\n        let mut rng = thread_rng();\r\n        let (sk, pk) = lwe::keygen(\u0026params, \u0026mut rng).unwrap();\r\n\r\n        let ct1 = lwe::encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n        let ct2 = lwe::encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n\r\n        // Ciphertexts should be different (probabilistic encryption)\r\n        assert_ne!(ct1.v, ct2.v, \"Encryption should be randomized\");\r\n\r\n        // But both should decrypt to the same value\r\n        assert_eq!(lwe::decrypt(\u0026sk, \u0026ct1, \u0026params).unwrap(), true);\r\n        assert_eq!(lwe::decrypt(\u0026sk, \u0026ct2, \u0026params).unwrap(), true);\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_polynomial_operations() {\r\n        let modulus = 17;\r\n        let a = ring_lwe::Polynomial::from_coeffs(vec![1, 2, 3, 4], modulus);\r\n        let b = ring_lwe::Polynomial::from_coeffs(vec![5, 6, 7, 8], modulus);\r\n\r\n        let sum = ring_lwe::poly_add(\u0026a, \u0026b, modulus);\r\n        assert_eq!(sum.coeffs[0], 6);\r\n        assert_eq!(sum.coeffs[1], 8);\r\n\r\n        let diff = ring_lwe::poly_sub(\u0026a, \u0026b, modulus);\r\n        assert_eq!(diff.coeffs[0], (1i64 - 5).rem_euclid(modulus as i64));\r\n\r\n        let scaled = ring_lwe::poly_scalar_mult(\u0026a, 2, modulus);\r\n        assert_eq!(scaled.coeffs[0], 2);\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_ntt_correctness() {\r\n        let params = ring_lwe::RingLWEParameters::new_128bit_security();\r\n\r\n        // Create a test polynomial\r\n        for _ in 0..3 {\r\n            let coeffs: Vec\u003ci64\u003e = (0..params.n).map(|i| (i % params.q as usize) as i64).collect();\r\n            let poly = ring_lwe::Polynomial::from_coeffs(coeffs.clone(), params.q);\r\n\r\n            // Transform forward and back (we need the primitive root)\r\n            let primitive_root = 3; // For modulus 12289\r\n            let ntt_poly = ring_lwe::ntt(\u0026poly, params.q, primitive_root);\r\n            let recovered = ring_lwe::intt(\u0026ntt_poly, params.n, params.q, primitive_root);\r\n\r\n            // Check coefficients are recovered (may differ by scaling)\r\n            assert_eq!(poly.coeffs.len(), recovered.coeffs.len(), \"NTT should preserve degree\");\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_encryption_correctness() {\r\n        let security_levels = [\r\n            ring_lwe::RingLWEParameters::new_128bit_security(),\r\n            ring_lwe::RingLWEParameters::new_192bit_security(),\r\n            ring_lwe::RingLWEParameters::new_256bit_security(),\r\n        ];\r\n\r\n        for params in \u0026security_levels {\r\n            let (sk, pk) = ring_lwe::ring_keygen(params).unwrap();\r\n\r\n            for msg_bool in [true, false] {\r\n                let message = vec![msg_bool];\r\n                let ciphertext = ring_lwe::ring_encrypt(\u0026pk, \u0026message, params).unwrap();\r\n                let decrypted = ring_lwe::ring_decrypt(\u0026sk, \u0026ciphertext, params).unwrap();\r\n\r\n                // Ring-LWE decodes all n coefficients, check first one matches message\r\n                assert!(decrypted.len() \u003e= 1, \"Should decrypt at least one bit\");\r\n                assert_eq!(decrypted[0], msg_bool,\r\n                    \"Failed to recover message {:?} at security level n={}\", msg_bool, params.n);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod property_based_tests {\r\n    use super::*;\r\n\r\n    proptest! {\r\n        #[test]\r\n        fn prop_lwe_encryption_decryption(message_bit in any::\u003cbool\u003e()) {\r\n            use rand::thread_rng;\r\n            \r\n            let params = lwe::LWEParameters::new(256, 512, 12289, 3.2);\r\n            let mut rng = thread_rng();\r\n            let (sk, pk) = lwe::keygen(\u0026params, \u0026mut rng).unwrap();\r\n\r\n            let ciphertext = lwe::encrypt(\u0026pk, message_bit, \u0026params, \u0026mut rng).unwrap();\r\n            let decrypted = lwe::decrypt(\u0026sk, \u0026ciphertext, \u0026params).unwrap();\r\n\r\n            prop_assert_eq!(decrypted, message_bit);\r\n        }\r\n\r\n        #[test]\r\n        fn prop_polynomial_addition_commutative(a in prop::collection::vec(0i64..17, 4), b in prop::collection::vec(0i64..17, 4)) {\r\n            let modulus = 17;\r\n            let poly_a = ring_lwe::Polynomial::from_coeffs(a, modulus);\r\n            let poly_b = ring_lwe::Polynomial::from_coeffs(b, modulus);\r\n\r\n            let sum1 = ring_lwe::poly_add(\u0026poly_a, \u0026poly_b, modulus);\r\n            let sum2 = ring_lwe::poly_add(\u0026poly_b, \u0026poly_a, modulus);\r\n\r\n            prop_assert_eq!(sum1.coeffs, sum2.coeffs);\r\n        }\r\n\r\n        #[test]\r\n        fn prop_polynomial_addition_associative(\r\n            a in prop::collection::vec(0i64..17, 4),\r\n            b in prop::collection::vec(0i64..17, 4),\r\n            c in prop::collection::vec(0i64..17, 4)\r\n        ) {\r\n            let modulus = 17;\r\n            let poly_a = ring_lwe::Polynomial::from_coeffs(a, modulus);\r\n            let poly_b = ring_lwe::Polynomial::from_coeffs(b, modulus);\r\n            let poly_c = ring_lwe::Polynomial::from_coeffs(c, modulus);\r\n\r\n            let sum1 = ring_lwe::poly_add(\u0026ring_lwe::poly_add(\u0026poly_a, \u0026poly_b, modulus), \u0026poly_c, modulus);\r\n            let sum2 = ring_lwe::poly_add(\u0026poly_a, \u0026ring_lwe::poly_add(\u0026poly_b, \u0026poly_c, modulus), modulus);\r\n\r\n            prop_assert_eq!(sum1.coeffs, sum2.coeffs);\r\n        }\r\n\r\n        #[test]\r\n        fn prop_ring_lwe_message_recovery(msg in any::\u003cbool\u003e()) {\r\n            let params = ring_lwe::RingLWEParameters::new_128bit_security();\r\n            let (sk, pk) = ring_lwe::ring_keygen(\u0026params).unwrap();\r\n\r\n            let message = vec![msg];\r\n            let ciphertext = ring_lwe::ring_encrypt(\u0026pk, \u0026message, \u0026params).unwrap();\r\n            let decrypted = ring_lwe::ring_decrypt(\u0026sk, \u0026ciphertext, \u0026params).unwrap();\r\n\r\n            // Ring-LWE decodes all n coefficients, check first one matches\r\n            prop_assert!(decrypted.len() \u003e= 1);\r\n            prop_assert_eq!(decrypted[0], message[0]);\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod security_tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_zeroization() {\r\n        use rand::thread_rng;\r\n        \r\n        // Test that secret keys can be inspected (zeroization would require ndarray support)\r\n        let params = lwe::LWEParameters::new(256, 512, 12289, 3.2);\r\n        let mut rng = thread_rng();\r\n        let (sk, _pk) = lwe::keygen(\u0026params, \u0026mut rng).unwrap();\r\n        \r\n        // Store original values\r\n        let has_nonzero = sk.s.iter().any(|\u0026x| x != 0);\r\n        assert!(has_nonzero, \"Secret key should have non-zero values\");\r\n        \r\n        // Verify secret key has expected properties\r\n        assert_eq!(sk.s.len(), params.n, \"Secret key should have correct dimension\");\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod edge_case_tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_empty_polynomial() {\r\n        let poly = ring_lwe::Polynomial::zero(4, 17);\r\n        assert_eq!(poly.coeffs.len(), 4);\r\n        assert!(poly.coeffs.iter().all(|\u0026x| x == 0));\r\n    }\r\n\r\n    #[test]\r\n    fn test_polynomial_zero_addition() {\r\n        let modulus = 17;\r\n        let poly = ring_lwe::Polynomial::from_coeffs(vec![1, 2, 3, 4], modulus);\r\n        let zero = ring_lwe::Polynomial::zero(4, modulus);\r\n\r\n        let result = ring_lwe::poly_add(\u0026poly, \u0026zero, modulus);\r\n        assert_eq!(result.coeffs, poly.coeffs);\r\n    }\r\n\r\n    #[test]\r\n    fn test_larger_dimension() {\r\n        use rand::thread_rng;\r\n        \r\n        // Test with larger dimension instead of large modulus\r\n        let params = lwe::LWEParameters::new(256, 512, 12289, 3.2);\r\n        let mut rng = thread_rng();\r\n        \r\n        // Should handle larger dimensions\r\n        let result = lwe::keygen(\u0026params, \u0026mut rng);\r\n        assert!(result.is_ok(), \"Should handle larger dimensions\");\r\n        \r\n        let (sk, pk) = result.unwrap();\r\n        let ct = lwe::encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n        let pt = lwe::decrypt(\u0026sk, \u0026ct, \u0026params).unwrap();\r\n        assert_eq!(pt, true, \"Should correctly encrypt/decrypt with larger dimensions\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_zero_message_encryption() {\r\n        use rand::thread_rng;\r\n        \r\n        let params = lwe::LWEParameters::new(256, 512, 12289, 3.2);\r\n        let mut rng = thread_rng();\r\n        let (sk, pk) = lwe::keygen(\u0026params, \u0026mut rng).unwrap();\r\n\r\n        let ciphertext = lwe::encrypt(\u0026pk, false, \u0026params, \u0026mut rng).unwrap();\r\n        let decrypted = lwe::decrypt(\u0026sk, \u0026ciphertext, \u0026params).unwrap();\r\n\r\n        assert_eq!(decrypted, false);\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","tests","integration_tests.rs"],"content":"//! Integration tests for nexuszero-crypto\r\n\r\nuse nexuszero_crypto::lattice::lwe::{LWEParameters, keygen, encrypt, decrypt};\r\nuse nexuszero_crypto::{CryptoParameters, SecurityLevel};\r\n\r\n#[test]\r\nfn test_lwe_integration() {\r\n    let params = LWEParameters::new(32, 64, 97, 2.0);\r\n    let mut rng = rand::thread_rng();\r\n\r\n    let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n\r\n    let message = true;\r\n    let ciphertext = encrypt(\u0026pk, message, \u0026params, \u0026mut rng).unwrap();\r\n    let decrypted = decrypt(\u0026sk, \u0026ciphertext, \u0026params).unwrap();\r\n\r\n    assert_eq!(message, decrypted);\r\n}\r\n\r\n#[test]\r\nfn test_security_parameters() {\r\n    let params_128 = CryptoParameters::new_128bit_security();\r\n    assert_eq!(params_128.security_level, SecurityLevel::Bit128);\r\n\r\n    let params_192 = CryptoParameters::new_192bit_security();\r\n    assert_eq!(params_192.security_level, SecurityLevel::Bit192);\r\n\r\n    let params_256 = CryptoParameters::new_256bit_security();\r\n    assert_eq!(params_256.security_level, SecurityLevel::Bit256);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","tests","test_vector_runner.rs"],"content":"/// Unified Test Vector Runner\r\n/// Adapts to nested JSON schemas for LWE, Ring-LWE, and Proof vectors.\r\nuse nexuszero_crypto::lattice::lwe::*;\r\nuse nexuszero_crypto::lattice::ring_lwe::*;\r\nuse nexuszero_crypto::proof::proof::*;\r\nuse nexuszero_crypto::proof::statement::*;\r\nuse nexuszero_crypto::proof::witness::*;\r\nuse serde::Deserialize;\r\nuse std::fs;\r\nuse rand::thread_rng;\r\nuse sha3::{Digest, Sha3_256};\r\n\r\n#[derive(Debug, Deserialize)]\r\nstruct GenericVectors\u003cT\u003e { vectors: Vec\u003cT\u003e }\r\n\r\n// LWE schema\r\n#[derive(Debug, Deserialize)]\r\nstruct LWEParametersJson { dimension: usize, modulus: u64, sigma: f64 }\r\n#[derive(Debug, Deserialize)]\r\nstruct LWETestCaseJson { plaintext_bit: u8, decryption_result: Option\u003cu8\u003e }\r\n#[derive(Debug, Deserialize)]\r\nstruct LWEVectorJson { name: String, security_level: u32, parameters: LWEParametersJson, test_cases: Vec\u003cLWETestCaseJson\u003e }\r\n\r\n// Ring-LWE schema\r\n#[derive(Debug, Deserialize)]\r\nstruct RingLWEParametersJson { degree: usize, modulus: u64, sigma: f64 }\r\n#[derive(Debug, Deserialize)]\r\nstruct EncryptionTestJson { message: Vec\u003cu8\u003e }\r\n#[derive(Debug, Deserialize)]\r\nstruct PolynomialTestJson { operation: Option\u003cString\u003e, poly_a: Option\u003cVec\u003ci64\u003e\u003e, poly_b: Option\u003cVec\u003ci64\u003e\u003e, expected: Option\u003cVec\u003ci64\u003e\u003e }\r\n#[derive(Debug, Deserialize)]\r\nstruct RingLWEVectorJson { name: String, security_level: u32, parameters: RingLWEParametersJson, encryption_tests: Option\u003cVec\u003cEncryptionTestJson\u003e\u003e, polynomial_tests: Option\u003cVec\u003cPolynomialTestJson\u003e\u003e }\r\n\r\n// Proof schema\r\n#[derive(Debug, Deserialize, Clone)]\r\nstruct ProofVectorJson { name: String }\r\n\r\n#[test]\r\nfn test_lwe_vectors() {\r\n    let json_data = fs::read_to_string(\"tests/test_vectors/lwe_test_vectors.json\").expect(\"read LWE vectors\");\r\n    let suite: GenericVectors\u003cLWEVectorJson\u003e = serde_json::from_str(\u0026json_data).expect(\"parse LWE vectors\");\r\n    for vector in \u0026suite.vectors {\r\n        let p = \u0026vector.parameters;\r\n        let m = p.dimension * 2; // derive samples\r\n        let params = LWEParameters::new(p.dimension, m, p.modulus, p.sigma);\r\n        let mut rng = thread_rng();\r\n        let (sk, pk) = keygen(\u0026params, \u0026mut rng).expect(\"keygen\");\r\n        for case in \u0026vector.test_cases {\r\n            let bit = case.plaintext_bit != 0;\r\n            let ct = encrypt(\u0026pk, bit, \u0026params, \u0026mut rng).expect(\"encrypt\");\r\n            let dec = decrypt(\u0026sk, \u0026ct, \u0026params).expect(\"decrypt\");\r\n            if let Some(expected) = case.decryption_result { assert_eq!(dec, expected != 0); } else { assert_eq!(dec, bit); }\r\n        }\r\n    }\r\n    println!(\"✓ LWE vectors OK\");\r\n}\r\n\r\n#[test]\r\nfn test_ring_lwe_vectors() {\r\n    let json_data = fs::read_to_string(\"tests/test_vectors/ring_lwe_test_vectors.json\").expect(\"read Ring-LWE vectors\");\r\n    let suite: GenericVectors\u003cRingLWEVectorJson\u003e = serde_json::from_str(\u0026json_data).expect(\"parse Ring-LWE vectors\");\r\n    for vector in \u0026suite.vectors {\r\n        let p = \u0026vector.parameters;\r\n        let params = RingLWEParameters::new(p.degree, p.modulus, p.sigma);\r\n        let (sk, pk) = ring_keygen(\u0026params).expect(\"ring keygen\");\r\n        if let Some(enc_tests) = \u0026vector.encryption_tests {\r\n            for t in enc_tests {\r\n                let bits: Vec\u003cbool\u003e = t.message.iter().map(|b| (b \u0026 1)==1).collect();\r\n                let ct = ring_encrypt(\u0026pk, \u0026bits, \u0026params).expect(\"ring encrypt\");\r\n                let dec = ring_decrypt(\u0026sk, \u0026ct, \u0026params).expect(\"ring decrypt\");\r\n                if !bits.is_empty() { assert_eq!(dec[0], bits[0]); }\r\n            }\r\n        }\r\n        if let Some(poly_tests) = \u0026vector.polynomial_tests {\r\n            for pt in poly_tests {\r\n                if pt.operation.as_deref() == Some(\"addition\") {\r\n                    if let (Some(a), Some(b), Some(exp)) = (\u0026pt.poly_a, \u0026pt.poly_b, \u0026pt.expected) {\r\n                        let pa = Polynomial { coeffs: a.clone(), modulus: p.modulus, degree: a.len() };\r\n                        let pb = Polynomial { coeffs: b.clone(), modulus: p.modulus, degree: b.len() };\r\n                        let sum = poly_add(\u0026pa, \u0026pb, p.modulus);\r\n                        for (i, e) in exp.iter().enumerate() { if i \u003c sum.coeffs.len() { assert_eq!(sum.coeffs[i], *e); } }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    println!(\"✓ Ring-LWE vectors OK\");\r\n}\r\n\r\n#[test]\r\nfn test_proof_vectors() {\r\n    let json_data = fs::read_to_string(\"tests/test_vectors/proof_test_vectors.json\").expect(\"read proof vectors\");\r\n    let suite: GenericVectors\u003cProofVectorJson\u003e = serde_json::from_str(\u0026json_data).expect(\"parse proof vectors\");\r\n    for vector in \u0026suite.vectors {\r\n        if vector.name.contains(\"Discrete-Log\") {\r\n            let generator = vec![2u8; 32];\r\n            let secret = vec![42u8; 32];\r\n            use num_bigint::BigUint; let modulus_bytes = vec![0xFF; 32];\r\n            let gen_big = BigUint::from_bytes_be(\u0026generator); let secret_big = BigUint::from_bytes_be(\u0026secret); let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n            let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n            let statement = StatementBuilder::new().discrete_log(generator, public_value).build().expect(\"statement\");\r\n            let witness = Witness::discrete_log(secret);\r\n            let proof = prove(\u0026statement, \u0026witness).expect(\"prove\");\r\n            verify(\u0026statement, \u0026proof).expect(\"verify\");\r\n        } else if vector.name.contains(\"Preimage\") {\r\n            let preimage = b\"test_message\".to_vec(); let mut hasher = Sha3_256::new(); hasher.update(\u0026preimage); let hash = hasher.finalize().to_vec();\r\n            let statement = StatementBuilder::new().preimage(HashFunction::SHA3_256, hash).build().expect(\"preimage statement\");\r\n            let witness = Witness::preimage(preimage);\r\n            let proof = prove(\u0026statement, \u0026witness).expect(\"prove preimage\");\r\n            verify(\u0026statement, \u0026proof).expect(\"verify preimage\");\r\n        } else if vector.name.contains(\"Serialization\") {\r\n            let preimage = b\"serialization\".to_vec(); let mut hasher = Sha3_256::new(); hasher.update(\u0026preimage); let hash = hasher.finalize().to_vec();\r\n            let statement = StatementBuilder::new().preimage(HashFunction::SHA3_256, hash).build().expect(\"ser statement\");\r\n            let witness = Witness::preimage(preimage);\r\n            let proof = prove(\u0026statement, \u0026witness).expect(\"prove ser\");\r\n            let bytes = proof.to_bytes().expect(\"serialize\");\r\n            let restored = Proof::from_bytes(\u0026bytes).expect(\"deserialize\");\r\n            verify(\u0026statement, \u0026restored).expect(\"verify restored\");\r\n        }\r\n    }\r\n    println!(\"✓ Proof vectors OK\");\r\n}\r\n\r\n#[test]\r\nfn test_polynomial_operations_from_vectors() {\r\n    let json_data = fs::read_to_string(\"tests/test_vectors/ring_lwe_test_vectors.json\").expect(\"read Ring-LWE vectors\");\r\n    let suite: GenericVectors\u003cRingLWEVectorJson\u003e = serde_json::from_str(\u0026json_data).expect(\"parse Ring-LWE vectors\");\r\n    for vector in \u0026suite.vectors { let p=\u0026vector.parameters; if p.degree.is_power_of_two() { if let Some(root)=find_primitive_root(p.degree,p.modulus){ let poly=Polynomial{coeffs:vec![1i64;8],modulus:p.modulus,degree:8}; let t=ntt(\u0026poly,p.modulus,root); assert_eq!(t.len(),poly.coeffs.len()); } } }\r\n    println!(\"✓ Polynomial ops OK\");\r\n}\r\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","benches","comprehensive_benchmarks.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};\r\nuse nexuszero_crypto::lattice::lwe::*;\r\nuse nexuszero_crypto::lattice::ring_lwe::*;\r\nuse nexuszero_crypto::params::security::SecurityLevel;\r\nuse nexuszero_crypto::proof::statement::*;\r\nuse nexuszero_crypto::proof::witness::*;\r\nuse nexuszero_crypto::proof::proof::*;\r\nuse num_bigint::BigUint;\r\nuse rand::thread_rng;\r\n\r\n// ============================================================================\r\n// LWE Benchmarks\r\n// ============================================================================\r\n\r\nfn benchmark_lwe_operations(c: \u0026mut Criterion) {\r\n    let mut group = c.benchmark_group(\"LWE Operations\");\r\n    \r\n    for (name, n, m, q, sigma) in \u0026[\r\n        (\"128-bit\", 256, 512, 12289, 3.2),\r\n        (\"192-bit\", 384, 768, 12289, 3.2),\r\n        (\"256-bit\", 512, 1024, 12289, 3.2),\r\n    ] {\r\n        let params = LWEParameters::new(*n, *m, *q, *sigma);\r\n        let mut rng = thread_rng();\r\n        \r\n        // KeyGen\r\n        group.bench_function(\r\n            BenchmarkId::new(\"KeyGen\", name),\r\n            |b| b.iter(|| {\r\n                let mut rng = thread_rng();\r\n                keygen(black_box(\u0026params), \u0026mut rng)\r\n            })\r\n        );\r\n        \r\n        // Encrypt\r\n        let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n        group.bench_function(\r\n            BenchmarkId::new(\"Encrypt\", name),\r\n            |b| b.iter(|| {\r\n                let mut rng = thread_rng();\r\n                encrypt(black_box(\u0026pk), black_box(true), black_box(\u0026params), \u0026mut rng)\r\n            })\r\n        );\r\n        \r\n        // Decrypt\r\n        let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n        let ct = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n        group.bench_function(\r\n            BenchmarkId::new(\"Decrypt\", name),\r\n            |b| b.iter(|| decrypt(black_box(\u0026sk), black_box(\u0026ct), black_box(\u0026params)))\r\n        );\r\n    }\r\n    \r\n    group.finish();\r\n}\r\n\r\n// ============================================================================\r\n// Ring-LWE Benchmarks\r\n// ============================================================================\r\n\r\nfn benchmark_ring_lwe_operations(c: \u0026mut Criterion) {\r\n    let mut group = c.benchmark_group(\"Ring-LWE Operations\");\r\n    \r\n    for (name, params) in \u0026[\r\n        (\"128-bit\", RingLWEParameters::new_128bit_security()),\r\n        (\"192-bit\", RingLWEParameters::new_192bit_security()),\r\n        (\"256-bit\", RingLWEParameters::new_256bit_security()),\r\n    ] {\r\n        // KeyGen\r\n        group.bench_function(\r\n            BenchmarkId::new(\"KeyGen\", name),\r\n            |b| b.iter(|| ring_keygen(black_box(params)))\r\n        );\r\n        \r\n        // Encrypt\r\n        let (sk, pk) = ring_keygen(params).unwrap();\r\n        let message = vec![true, false, true, false, true];  // 5 bits\r\n        group.bench_function(\r\n            BenchmarkId::new(\"Encrypt\", name),\r\n            |b| b.iter(|| ring_encrypt(black_box(\u0026pk), black_box(\u0026message), black_box(params)))\r\n        );\r\n        \r\n        // Decrypt\r\n        let (sk, pk) = ring_keygen(params).unwrap();\r\n        let message = vec![true, false, true, false, true];\r\n        let ct = ring_encrypt(\u0026pk, \u0026message, params).unwrap();\r\n        group.bench_function(\r\n            BenchmarkId::new(\"Decrypt\", name),\r\n            |b| b.iter(|| ring_decrypt(black_box(\u0026sk), black_box(\u0026ct), black_box(params)))\r\n        );\r\n    }\r\n    \r\n    group.finish();\r\n}\r\n\r\n// ============================================================================\r\n// Polynomial Operations Benchmarks\r\n// ============================================================================\r\n\r\nfn benchmark_polynomial_operations(c: \u0026mut Criterion) {\r\n    let mut group = c.benchmark_group(\"Polynomial Operations\");\r\n    \r\n    let q = 12289u64;\r\n    for degree in \u0026[128, 256, 512, 1024] {\r\n        let poly_a = Polynomial {\r\n            coeffs: vec![1i64; *degree],\r\n            modulus: q,\r\n            degree: *degree,\r\n        };\r\n        let poly_b = Polynomial {\r\n            coeffs: vec![2i64; *degree],\r\n            modulus: q,\r\n            degree: *degree,\r\n        };\r\n        \r\n        // Addition\r\n        group.bench_function(\r\n            BenchmarkId::new(\"Addition\", degree),\r\n            |b| b.iter(|| poly_add(black_box(\u0026poly_a), black_box(\u0026poly_b), q))\r\n        );\r\n        \r\n        // Subtraction\r\n        group.bench_function(\r\n            BenchmarkId::new(\"Subtraction\", degree),\r\n            |b| b.iter(|| poly_sub(black_box(\u0026poly_a), black_box(\u0026poly_b), q))\r\n        );\r\n        \r\n        // Schoolbook Multiplication\r\n        group.bench_function(\r\n            BenchmarkId::new(\"Mult-Schoolbook\", degree),\r\n            |b| b.iter(|| poly_mult_schoolbook(black_box(\u0026poly_a), black_box(\u0026poly_b), q))\r\n        );\r\n        \r\n        // NTT Transform\r\n        let primitive_root = find_primitive_root(*degree, q).unwrap();\r\n        group.bench_function(\r\n            BenchmarkId::new(\"NTT-Forward\", degree),\r\n            |b| b.iter(|| ntt(black_box(\u0026poly_a), q, primitive_root))\r\n        );\r\n    }\r\n    \r\n    group.finish();\r\n}\r\n\r\n// ============================================================================\r\n// Proof System Benchmarks\r\n// ============================================================================\r\n\r\nfn benchmark_proof_operations(c: \u0026mut Criterion) {\r\n    let mut group = c.benchmark_group(\"Proof Operations\");\r\n    \r\n    // Discrete Log Proof Generation\r\n    let generator = vec![2u8; 32];\r\n    let secret = vec![42u8; 32];\r\n    let modulus_bytes = vec![0xFF; 32];\r\n    let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n    let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n    let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n    let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n    \r\n    let statement = StatementBuilder::new()\r\n        .discrete_log(generator, public_value)\r\n        .build()\r\n        .unwrap();\r\n    let witness = Witness::discrete_log(secret);\r\n    \r\n    group.bench_function(\"Discrete-Log-Prove\", |b| {\r\n        b.iter(|| prove(black_box(\u0026statement), black_box(\u0026witness)))\r\n    });\r\n    \r\n    // Discrete Log Proof Verification\r\n    let proof = prove(\u0026statement, \u0026witness).unwrap();\r\n    group.bench_function(\"Discrete-Log-Verify\", |b| {\r\n        b.iter(|| verify(black_box(\u0026statement), black_box(\u0026proof)))\r\n    });\r\n    \r\n    // Preimage Proof\r\n    use sha3::{Digest, Sha3_256};\r\n    let preimage = b\"benchmark_message\".to_vec();\r\n    let mut hasher = Sha3_256::new();\r\n    hasher.update(\u0026preimage);\r\n    let hash = hasher.finalize().to_vec();\r\n    \r\n    let preimage_statement = StatementBuilder::new()\r\n        .preimage(HashFunction::SHA3_256, hash)\r\n        .build()\r\n        .unwrap();\r\n    let preimage_witness = Witness::preimage(preimage);\r\n    \r\n    group.bench_function(\"Preimage-Prove\", |b| {\r\n        b.iter(|| prove(black_box(\u0026preimage_statement), black_box(\u0026preimage_witness)))\r\n    });\r\n    \r\n    let preimage_proof = prove(\u0026preimage_statement, \u0026preimage_witness).unwrap();\r\n    group.bench_function(\"Preimage-Verify\", |b| {\r\n        b.iter(|| verify(black_box(\u0026preimage_statement), black_box(\u0026preimage_proof)))\r\n    });\r\n    \r\n    // Proof Serialization\r\n    group.bench_function(\"Proof-Serialize\", |b| {\r\n        b.iter(|| proof.to_bytes())\r\n    });\r\n    \r\n    // Proof Deserialization\r\n    let serialized = proof.to_bytes().unwrap();\r\n    group.bench_function(\"Proof-Deserialize\", |b| {\r\n        b.iter(|| Proof::from_bytes(black_box(\u0026serialized)))\r\n    });\r\n    \r\n    group.finish();\r\n}\r\n\r\n// ============================================================================\r\n// End-to-End Workflow Benchmarks\r\n// ============================================================================\r\n\r\nfn benchmark_e2e_workflows(c: \u0026mut Criterion) {\r\n    let mut group = c.benchmark_group(\"End-to-End Workflows\");\r\n    \r\n    // Complete LWE encryption workflow\r\n    group.bench_function(\"LWE-Full-Workflow\", |b| {\r\n        b.iter(|| {\r\n            let params = LWEParameters::new(256, 512, 12289, 3.2);\r\n            let mut rng = thread_rng();\r\n            let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n            let ct = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n            let _pt = decrypt(\u0026sk, \u0026ct, \u0026params);\r\n        })\r\n    });\r\n    \r\n    // Complete Ring-LWE encryption workflow\r\n    group.bench_function(\"Ring-LWE-Full-Workflow\", |b| {\r\n        b.iter(|| {\r\n            let params = RingLWEParameters::new_128bit_security();\r\n            let (sk, pk) = ring_keygen(\u0026params).unwrap();\r\n            let message = vec![true, false, true, false, true];\r\n            let ct = ring_encrypt(\u0026pk, \u0026message, \u0026params).unwrap();\r\n            let _dec = ring_decrypt(\u0026sk, \u0026ct, \u0026params);\r\n        })\r\n    });\r\n    \r\n    // Complete proof generation and verification workflow\r\n    group.bench_function(\"Proof-Full-Workflow\", |b| {\r\n        b.iter(|| {\r\n            let generator = vec![2u8; 32];\r\n            let secret = vec![42u8; 32];\r\n            let modulus_bytes = vec![0xFF; 32];\r\n            let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n            let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n            let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n            let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n            \r\n            let statement = StatementBuilder::new()\r\n                .discrete_log(generator, public_value)\r\n                .build()\r\n                .unwrap();\r\n            let witness = Witness::discrete_log(secret);\r\n            let proof = prove(\u0026statement, \u0026witness).unwrap();\r\n            let _result = verify(\u0026statement, \u0026proof);\r\n        })\r\n    });\r\n    \r\n    group.finish();\r\n}\r\n\r\ncriterion_group!(\r\n    benches,\r\n    benchmark_lwe_operations,\r\n    benchmark_ring_lwe_operations,\r\n    benchmark_polynomial_operations,\r\n    benchmark_proof_operations,\r\n    benchmark_e2e_workflows\r\n);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","benches","crypto_benchmarks.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion};\r\nuse nexuszero_crypto::lattice::{LWEParameters, keygen, encrypt, decrypt};\r\n\r\nfn bench_lwe_encryption(c: \u0026mut Criterion) {\r\n    let params = LWEParameters::new(256, 512, 12289, 3.2);\r\n    let mut rng = rand::thread_rng();\r\n    let (_, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n\r\n    c.bench_function(\"lwe_encrypt_128bit\", |b| {\r\n        b.iter(|| {\r\n            encrypt(black_box(\u0026pk), black_box(true), black_box(\u0026params), black_box(\u0026mut rng))\r\n        });\r\n    });\r\n}\r\n\r\nfn bench_lwe_decryption(c: \u0026mut Criterion) {\r\n    let params = LWEParameters::new(256, 512, 12289, 3.2);\r\n    let mut rng = rand::thread_rng();\r\n    let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n    let ct = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n\r\n    c.bench_function(\"lwe_decrypt_128bit\", |b| {\r\n        b.iter(|| {\r\n            decrypt(black_box(\u0026sk), black_box(\u0026ct), black_box(\u0026params))\r\n        });\r\n    });\r\n}\r\n\r\ncriterion_group!(benches, bench_lwe_encryption, bench_lwe_decryption);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","examples","parameter_selection.rs"],"content":"/// Example: Advanced Parameter Selection\r\n/// \r\n/// Demonstrates the ParameterSelector with various configurations:\r\n/// - Basic parameter generation for different security levels\r\n/// - Custom constraints (dimension, modulus ranges)\r\n/// - Prime modulus selection using Miller-Rabin\r\n/// - Security level estimation\r\n\r\nuse nexuszero_crypto::{\r\n    params::{ParameterSelector, SecurityLevel, is_prime_miller_rabin, generate_prime},\r\n    CryptoResult,\r\n};\r\n\r\nfn main() -\u003e CryptoResult\u003c()\u003e {\r\n    println!(\"=== NexusZero Parameter Selection Examples ===\\n\");\r\n\r\n    // Example 1: Basic LWE parameter selection\r\n    basic_lwe_selection()?;\r\n\r\n    // Example 2: Basic Ring-LWE parameter selection\r\n    basic_ring_lwe_selection()?;\r\n\r\n    // Example 3: Custom constraints\r\n    custom_constraints()?;\r\n\r\n    // Example 4: Prime modulus selection\r\n    prime_modulus_selection()?;\r\n\r\n    // Example 5: Security estimation\r\n    security_estimation();\r\n\r\n    // Example 6: Primality testing\r\n    primality_testing();\r\n\r\n    // Example 7: Prime generation\r\n    prime_generation()?;\r\n\r\n    Ok(())\r\n}\r\n\r\nfn basic_lwe_selection() -\u003e CryptoResult\u003c()\u003e {\r\n    println!(\"=== Example 1: Basic LWE Parameter Selection ===\");\r\n    \r\n    for \u0026security_level in \u0026[SecurityLevel::Bit128, SecurityLevel::Bit192, SecurityLevel::Bit256] {\r\n        let selector = ParameterSelector::new()\r\n            .target_security(security_level);\r\n        \r\n        let params = selector.build_lwe()?;\r\n        \r\n        println!(\"Security Level: {:?}\", security_level);\r\n        println!(\"  n (dimension): {}\", params.n);\r\n        println!(\"  m (samples):   {}\", params.m);\r\n        println!(\"  q (modulus):   {}\", params.q);\r\n        println!(\"  σ (sigma):     {:.2}\", params.sigma);\r\n        \r\n        // Estimate actual security\r\n        let estimated_security = ParameterSelector::estimate_security(\r\n            params.n, \r\n            params.q, \r\n            params.sigma\r\n        );\r\n        println!(\"  Estimated security: {} bits\\n\", estimated_security);\r\n    }\r\n    \r\n    Ok(())\r\n}\r\n\r\nfn basic_ring_lwe_selection() -\u003e CryptoResult\u003c()\u003e {\r\n    println!(\"=== Example 2: Basic Ring-LWE Parameter Selection ===\");\r\n    \r\n    for \u0026security_level in \u0026[SecurityLevel::Bit128, SecurityLevel::Bit192, SecurityLevel::Bit256] {\r\n        let selector = ParameterSelector::new()\r\n            .target_security(security_level);\r\n        \r\n        let params = selector.build_ring_lwe()?;\r\n        \r\n        println!(\"Security Level: {:?}\", security_level);\r\n        println!(\"  n (degree):    {}\", params.n);\r\n        println!(\"  q (modulus):   {}\", params.q);\r\n        println!(\"  σ (sigma):     {:.2}\", params.sigma);\r\n        println!(\"  Power of 2:    {}\", params.n.is_power_of_two());\r\n        \r\n        let estimated_security = ParameterSelector::estimate_security(\r\n            params.n, \r\n            params.q, \r\n            params.sigma\r\n        );\r\n        println!(\"  Estimated security: {} bits\\n\", estimated_security);\r\n    }\r\n    \r\n    Ok(())\r\n}\r\n\r\nfn custom_constraints() -\u003e CryptoResult\u003c()\u003e {\r\n    println!(\"=== Example 3: Custom Constraints ===\");\r\n    \r\n    // Scenario: Need at least 512-bit dimension but no more than 1024\r\n    let selector = ParameterSelector::new()\r\n        .target_security(SecurityLevel::Bit128)\r\n        .min_dimension(512)\r\n        .max_dimension(1024);\r\n    \r\n    let params = selector.build_lwe()?;\r\n    \r\n    println!(\"Constrained LWE Parameters:\");\r\n    println!(\"  n (dimension): {} (within [512, 1024])\", params.n);\r\n    println!(\"  m (samples):   {}\", params.m);\r\n    println!(\"  q (modulus):   {}\", params.q);\r\n    println!(\"  σ (sigma):     {:.2}\\n\", params.sigma);\r\n    \r\n    // Scenario: Custom m/n ratio\r\n    let selector = ParameterSelector::new()\r\n        .target_security(SecurityLevel::Bit128)\r\n        .custom_ratio(3.0); // More samples for extra security\r\n    \r\n    let params = selector.build_lwe()?;\r\n    \r\n    println!(\"Custom Ratio (m/n = 3.0):\");\r\n    println!(\"  n: {}\", params.n);\r\n    println!(\"  m: {} (3× dimension)\", params.m);\r\n    println!(\"  Ratio: {:.2}\\n\", params.m as f64 / params.n as f64);\r\n    \r\n    Ok(())\r\n}\r\n\r\nfn prime_modulus_selection() -\u003e CryptoResult\u003c()\u003e {\r\n    println!(\"=== Example 4: Prime Modulus Selection ===\");\r\n    \r\n    // Without prime preference\r\n    let selector = ParameterSelector::new()\r\n        .target_security(SecurityLevel::Bit128);\r\n    \r\n    let params = selector.build_lwe()?;\r\n    \r\n    println!(\"Standard modulus:\");\r\n    println!(\"  q: {}\", params.q);\r\n    println!(\"  Is prime: {}\\n\", is_prime_miller_rabin(params.q, 20));\r\n    \r\n    // With prime preference\r\n    let selector = ParameterSelector::new()\r\n        .target_security(SecurityLevel::Bit128)\r\n        .prefer_prime_modulus(true);\r\n    \r\n    let params = selector.build_lwe()?;\r\n    \r\n    println!(\"Prime modulus:\");\r\n    println!(\"  q: {}\", params.q);\r\n    println!(\"  Is prime: {} (verified with Miller-Rabin)\\n\", \r\n        is_prime_miller_rabin(params.q, 20));\r\n    \r\n    Ok(())\r\n}\r\n\r\nfn security_estimation() {\r\n    println!(\"=== Example 5: Security Estimation ===\");\r\n    \r\n    // Compare different parameter sets\r\n    let test_cases = vec![\r\n        (256, 12289, 3.2, \"Small (128-bit target)\"),\r\n        (384, 16411, 3.8, \"Medium (192-bit target)\"),\r\n        (512, 20483, 4.0, \"Large (256-bit target)\"),\r\n        (1024, 40961, 4.5, \"Extra Large\"),\r\n    ];\r\n    \r\n    for (n, q, sigma, description) in test_cases {\r\n        let security = ParameterSelector::estimate_security(n, q, sigma);\r\n        println!(\"{}\", description);\r\n        println!(\"  Parameters: n={}, q={}, σ={:.1}\", n, q, sigma);\r\n        println!(\"  Estimated security: {} bits\\n\", security);\r\n    }\r\n}\r\n\r\nfn primality_testing() {\r\n    println!(\"=== Example 6: Primality Testing (Miller-Rabin) ===\");\r\n    \r\n    let test_numbers = vec![\r\n        (2, \"Small prime\"),\r\n        (97, \"Two-digit prime\"),\r\n        (541, \"Three-digit prime\"),\r\n        (7919, \"Four-digit prime\"),\r\n        (12289, \"Common in lattice crypto\"),\r\n        (100, \"Composite\"),\r\n        (1001, \"Composite (7 × 11 × 13)\"),\r\n    ];\r\n    \r\n    for (n, description) in test_numbers {\r\n        let is_prime = is_prime_miller_rabin(n, 20);\r\n        let result = if is_prime { \"PRIME\" } else { \"COMPOSITE\" };\r\n        println!(\"{:5} - {} [{}]\", n, description, result);\r\n    }\r\n    println!();\r\n}\r\n\r\nfn prime_generation() -\u003e CryptoResult\u003c()\u003e {\r\n    println!(\"=== Example 7: Prime Generation ===\");\r\n    \r\n    for bit_length in \u0026[10, 12, 14, 16] {\r\n        let prime = generate_prime(*bit_length)?;\r\n        let min = 1u64 \u003c\u003c (bit_length - 1);\r\n        let max = (1u64 \u003c\u003c bit_length) - 1;\r\n        \r\n        println!(\"{}-bit prime: {}\", bit_length, prime);\r\n        println!(\"  Range: [{}, {}]\", min, max);\r\n        println!(\"  Verified: {}\\n\", is_prime_miller_rabin(prime, 20));\r\n    }\r\n    \r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","lattice","lwe.rs"],"content":"//! Learning With Errors (LWE) primitives\r\n//!\r\n//! This module implements the LWE cryptographic scheme, which forms\r\n//! the security foundation for quantum-resistant cryptography.\r\n\r\nuse crate::{CryptoError, CryptoResult, LatticeParameters};\r\nuse ndarray::{Array1, Array2};\r\nuse rand::{CryptoRng, Rng};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// LWE parameters defining security and operational characteristics\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct LWEParameters {\r\n    /// Dimension (security parameter)\r\n    pub n: usize,\r\n    /// Number of samples\r\n    pub m: usize,\r\n    /// Modulus\r\n    pub q: u64,\r\n    /// Error distribution standard deviation\r\n    pub sigma: f64,\r\n}\r\n\r\nimpl LWEParameters {\r\n    /// Create new LWE parameters\r\n    pub fn new(n: usize, m: usize, q: u64, sigma: f64) -\u003e Self {\r\n        Self { n, m, q, sigma }\r\n    }\r\n}\r\n\r\nimpl LatticeParameters for LWEParameters {\r\n    fn dimension(\u0026self) -\u003e usize {\r\n        self.n\r\n    }\r\n\r\n    fn modulus(\u0026self) -\u003e u64 {\r\n        self.q\r\n    }\r\n\r\n    fn sigma(\u0026self) -\u003e f64 {\r\n        self.sigma\r\n    }\r\n\r\n    fn validate(\u0026self) -\u003e CryptoResult\u003c()\u003e {\r\n        if self.n == 0 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Dimension must be positive\".to_string(),\r\n            ));\r\n        }\r\n        if self.m == 0 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Number of samples must be positive\".to_string(),\r\n            ));\r\n        }\r\n        if self.q \u003c 2 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Modulus must be at least 2\".to_string(),\r\n            ));\r\n        }\r\n        if self.sigma \u003c= 0.0 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Sigma must be positive\".to_string(),\r\n            ));\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n/// LWE public key\r\n#[derive(Clone, Debug)]\r\npub struct LWEPublicKey {\r\n    /// Random matrix A (m × n)\r\n    pub a: Array2\u003ci64\u003e,\r\n    /// Vector b = As + e (m-dimensional)\r\n    pub b: Array1\u003ci64\u003e,\r\n}\r\n\r\n/// LWE secret key\r\n#[derive(Clone, Debug)]\r\npub struct LWESecretKey {\r\n    /// Secret vector s (n-dimensional)\r\n    pub s: Array1\u003ci64\u003e,\r\n}\r\n\r\n/// LWE ciphertext\r\n#[derive(Clone, Debug)]\r\npub struct LWECiphertext {\r\n    /// Ciphertext component u\r\n    pub u: Array1\u003ci64\u003e,\r\n    /// Ciphertext component v\r\n    pub v: i64,\r\n}\r\n\r\n/// Generate LWE key pair\r\npub fn keygen\u003cR: Rng + CryptoRng\u003e(\r\n    params: \u0026LWEParameters,\r\n    rng: \u0026mut R,\r\n) -\u003e CryptoResult\u003c(LWESecretKey, LWEPublicKey)\u003e {\r\n    params.validate()?;\r\n\r\n    // Generate secret key s\r\n    let s = sample_secret(params.n, params.q, rng);\r\n\r\n    // Generate random matrix A\r\n    let a = sample_matrix(params.m, params.n, params.q, rng);\r\n\r\n    // Generate error vector e\r\n    let e = crate::lattice::sampling::sample_error(params.sigma, params.m);\r\n\r\n    // Compute b = As + e (mod q)\r\n    let as_product = a.dot(\u0026s);\r\n    let b = as_product\r\n        .iter()\r\n        .zip(e.iter())\r\n        .map(|(as_i, e_i)| (as_i + e_i).rem_euclid(params.q as i64))\r\n        .collect::\u003cArray1\u003ci64\u003e\u003e();\r\n\r\n    let sk = LWESecretKey { s };\r\n    let pk = LWEPublicKey { a, b };\r\n\r\n    Ok((sk, pk))\r\n}\r\n\r\n/// Encrypt a message bit\r\npub fn encrypt\u003cR: Rng + CryptoRng\u003e(\r\n    pk: \u0026LWEPublicKey,\r\n    message: bool,\r\n    params: \u0026LWEParameters,\r\n    rng: \u0026mut R,\r\n) -\u003e CryptoResult\u003cLWECiphertext\u003e {\r\n    // Sample random vector r\r\n    let r = sample_binary_vector(params.m, rng);\r\n\r\n    // Compute u = A^T r (mod q)\r\n    let u = pk\r\n        .a\r\n        .t()\r\n        .dot(\u0026r)\r\n        .mapv(|x| x.rem_euclid(params.q as i64));\r\n\r\n    // Encode message (0 -\u003e 0, 1 -\u003e q/2)\r\n    let encoded_msg = if message { (params.q / 2) as i64 } else { 0 };\r\n\r\n    // Compute v = b^T r + encoded_msg (mod q)\r\n    let v = (pk.b.dot(\u0026r) + encoded_msg).rem_euclid(params.q as i64);\r\n\r\n    Ok(LWECiphertext { u, v })\r\n}\r\n\r\n/// Decrypt a ciphertext\r\npub fn decrypt(\r\n    sk: \u0026LWESecretKey,\r\n    ct: \u0026LWECiphertext,\r\n    params: \u0026LWEParameters,\r\n) -\u003e CryptoResult\u003cbool\u003e {\r\n    // Compute m' = v - s^T u (mod q)\r\n    let m_prime = (ct.v - sk.s.dot(\u0026ct.u)).rem_euclid(params.q as i64);\r\n\r\n    // Decode: if m' is closer to q/2 than to 0, message is 1\r\n    let _threshold = (params.q / 4) as i64;\r\n    let distance_to_zero = m_prime.min(params.q as i64 - m_prime);\r\n    let distance_to_half = (m_prime - (params.q / 2) as i64)\r\n        .abs()\r\n        .min((params.q / 2) as i64);\r\n\r\n    Ok(distance_to_half \u003c distance_to_zero)\r\n}\r\n\r\n// Helper functions\r\n\r\nfn sample_secret\u003cR: Rng + CryptoRng\u003e(n: usize, q: u64, rng: \u0026mut R) -\u003e Array1\u003ci64\u003e {\r\n    Array1::from_shape_fn(n, |_| rng.gen_range(0..q) as i64)\r\n}\r\n\r\nfn sample_matrix\u003cR: Rng + CryptoRng\u003e(\r\n    m: usize,\r\n    n: usize,\r\n    q: u64,\r\n    rng: \u0026mut R,\r\n) -\u003e Array2\u003ci64\u003e {\r\n    Array2::from_shape_fn((m, n), |_| rng.gen_range(0..q) as i64)\r\n}\r\n\r\nfn sample_binary_vector\u003cR: Rng + CryptoRng\u003e(m: usize, rng: \u0026mut R) -\u003e Array1\u003ci64\u003e {\r\n    Array1::from_shape_fn(m, |_| if rng.gen_bool(0.5) { 1 } else { 0 })\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_lwe_parameters_validation() {\r\n        let params = LWEParameters::new(256, 512, 12289, 3.2);\r\n        assert!(params.validate().is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn test_lwe_encrypt_decrypt() {\r\n        let params = LWEParameters::new(32, 64, 97, 2.0);\r\n        let mut rng = rand::thread_rng();\r\n\r\n        let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n\r\n        // Test encrypting false\r\n        let ct_false = encrypt(\u0026pk, false, \u0026params, \u0026mut rng).unwrap();\r\n        let decrypted_false = decrypt(\u0026sk, \u0026ct_false, \u0026params).unwrap();\r\n        assert_eq!(decrypted_false, false);\r\n\r\n        // Test encrypting true\r\n        let ct_true = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n        let decrypted_true = decrypt(\u0026sk, \u0026ct_true, \u0026params).unwrap();\r\n        assert_eq!(decrypted_true, true);\r\n    }\r\n    \r\n    #[test]\r\n    fn test_keygen_with_various_parameters() {\r\n        let mut rng = rand::thread_rng();\r\n        \r\n        // Test with minimal parameters\r\n        let params = LWEParameters::new(8, 16, 11, 1.0);\r\n        let result = keygen(\u0026params, \u0026mut rng);\r\n        assert!(result.is_ok());\r\n        \r\n        // Test with large parameters\r\n        let params = LWEParameters::new(512, 1024, 40961, 5.0);\r\n        let result = keygen(\u0026params, \u0026mut rng);\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn test_decrypt_edge_values() {\r\n        // Test decryption with reliable parameters\r\n        let params = LWEParameters::new(64, 128, 257, 2.0);\r\n        let mut rng = rand::thread_rng();\r\n        let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n        \r\n        // Test multiple encryptions and decryptions\r\n        for _ in 0..10 {\r\n            let ct_false = encrypt(\u0026pk, false, \u0026params, \u0026mut rng).unwrap();\r\n            let ct_true = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n            \r\n            assert_eq!(decrypt(\u0026sk, \u0026ct_false, \u0026params).unwrap(), false);\r\n            assert_eq!(decrypt(\u0026sk, \u0026ct_true, \u0026params).unwrap(), true);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_lwe_with_small_modulus() {\r\n        // Test with small but secure modulus\r\n        let params = LWEParameters::new(32, 64, 127, 1.5);\r\n        let mut rng = rand::thread_rng();\r\n        \r\n        let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n        let ct = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n        let decrypted = decrypt(\u0026sk, \u0026ct, \u0026params).unwrap();\r\n        assert_eq!(decrypted, true);\r\n        \r\n        // Test false as well\r\n        let ct_false = encrypt(\u0026pk, false, \u0026params, \u0026mut rng).unwrap();\r\n        let decrypted_false = decrypt(\u0026sk, \u0026ct_false, \u0026params).unwrap();\r\n        assert_eq!(decrypted_false, false);\r\n    }\r\n\r\n    #[test]\r\n    fn test_error_distribution_statistical_properties() {\r\n        use crate::lattice::sampling::sample_error;\r\n        let sigma = 3.2;\r\n        let n = 1000;\r\n        \r\n        // Sample error vector\r\n        let samples = sample_error(sigma, n);\r\n        \r\n        // Check mean is close to 0\r\n        let mean: f64 = samples.iter().map(|\u0026x| x as f64).sum::\u003cf64\u003e() / n as f64;\r\n        assert!(mean.abs() \u003c 1.0, \"Mean should be close to 0: {}\", mean);\r\n        \r\n        // Check standard deviation is close to sigma\r\n        let variance: f64 = samples.iter().map(|\u0026x| {\r\n            let x_f = x as f64;\r\n            (x_f - mean).powi(2)\r\n        }).sum::\u003cf64\u003e() / n as f64;\r\n        let std_dev = variance.sqrt();\r\n        assert!((std_dev - sigma).abs() \u003c 1.0, \"Std dev should be close to {}: {}\", sigma, std_dev);\r\n        \r\n        // Check distribution is roughly bell-shaped (most values within 3 sigma)\r\n        let within_3sigma = samples.iter().filter(|\u0026\u0026x| (x as f64).abs() \u003c= 3.0 * sigma).count();\r\n        let ratio = within_3sigma as f64 / n as f64;\r\n        assert!(ratio \u003e 0.95, \"At least 95% of samples should be within 3 sigma: {}\", ratio);\r\n    }\r\n\r\n    #[test]\r\n    fn test_error_magnitude_bounds() {\r\n        use crate::lattice::sampling::sample_error;\r\n        let sigma = 2.0;\r\n        \r\n        // Sample error vector and check all values are bounded\r\n        for _ in 0..10 {\r\n            let errors = sample_error(sigma, 100);\r\n            for \u0026error in errors.iter() {\r\n                // In practice, errors beyond 6*sigma are extremely rare\r\n                let error_f = (error as f64).abs();\r\n                assert!(error_f \u003c 6.0 * sigma, \"Error magnitude too large: {}\", error_f);\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_lwe_invalid_parameters() {\r\n        // Zero dimension\r\n        let params = LWEParameters::new(0, 64, 97, 2.0);\r\n        assert!(params.validate().is_err());\r\n        \r\n        // Zero samples\r\n        let params = LWEParameters::new(32, 0, 97, 2.0);\r\n        assert!(params.validate().is_err());\r\n        \r\n        // Invalid modulus\r\n        let params = LWEParameters::new(32, 64, 1, 2.0);\r\n        assert!(params.validate().is_err());\r\n        \r\n        // Negative/zero sigma\r\n        let params = LWEParameters::new(32, 64, 97, 0.0);\r\n        assert!(params.validate().is_err());\r\n        \r\n        let params = LWEParameters::new(32, 64, 97, -1.0);\r\n        assert!(params.validate().is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_encryption_produces_different_ciphertexts() {\r\n        let params = LWEParameters::new(32, 64, 97, 2.0);\r\n        let mut rng = rand::thread_rng();\r\n        let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n        \r\n        // Encrypt same message multiple times\r\n        let ct1 = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n        let ct2 = encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n        \r\n        // Ciphertexts should be different (probabilistic encryption)\r\n        let same_u = ct1.u.iter().zip(ct2.u.iter()).all(|(a, b)| a == b);\r\n        let same_v = ct1.v == ct2.v;\r\n        assert!(!(same_u \u0026\u0026 same_v), \"Ciphertexts should differ due to randomness\");\r\n        \r\n        // But both decrypt to the same plaintext\r\n        assert_eq!(decrypt(\u0026sk, \u0026ct1, \u0026params).unwrap(), true);\r\n        assert_eq!(decrypt(\u0026sk, \u0026ct2, \u0026params).unwrap(), true);\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":45,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":47,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":50,"address":[],"length":0,"stats":{"Line":2305843009213693951}},{"line":51,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":52,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":55,"address":[],"length":0,"stats":{"Line":2233785415175766015}},{"line":56,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":57,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":60,"address":[],"length":0,"stats":{"Line":2161727821137838079}},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":62,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":65,"address":[],"length":0,"stats":{"Line":2017612633061982207}},{"line":95,"address":[],"length":0,"stats":{"Line":1152921504606846977}},{"line":99,"address":[],"length":0,"stats":{"Line":2305843009213693955}},{"line":102,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":105,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":108,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":111,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":112,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":114,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":115,"address":[],"length":0,"stats":{"Line":5764607523034235810}},{"line":118,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":119,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":121,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":125,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":132,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":135,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":136,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":138,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":139,"address":[],"length":0,"stats":{"Line":17870283321406129850}},{"line":142,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":145,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":147,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":151,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":157,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":160,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":161,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":162,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":164,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":166,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":171,"address":[],"length":0,"stats":{"Line":1152921504606846977}},{"line":172,"address":[],"length":0,"stats":{"Line":4611686018427970074}},{"line":175,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":181,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":184,"address":[],"length":0,"stats":{"Line":1729382256910270481}},{"line":185,"address":[],"length":0,"stats":{"Line":3458764513820542110}}],"covered":51,"coverable":55},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","lattice","mod.rs"],"content":"//! Lattice-based cryptographic primitives\r\n//!\r\n//! This module provides implementations of:\r\n//! - Learning With Errors (LWE)\r\n//! - Ring Learning With Errors (Ring-LWE)\r\n//! - Error sampling from discrete Gaussian distributions\r\n\r\npub mod lwe;\r\npub mod ring_lwe;\r\npub mod sampling;\r\n\r\n// Re-export main types\r\npub use lwe::{LWECiphertext, LWEParameters, LWEPublicKey, LWESecretKey};\r\npub use ring_lwe::{\r\n    Polynomial, RingLWECiphertext, RingLWEParameters, RingLWEPublicKey, RingLWESecretKey,\r\n};\r\npub use sampling::{sample_error, sample_uniform};\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","lattice","ring_lwe.rs"],"content":"//! Ring Learning With Errors (Ring-LWE) primitives\r\n//!\r\n//! This module implements Ring-LWE, a more efficient variant of LWE\r\n//! that operates in polynomial rings.\r\n\r\nuse crate::{CryptoError, CryptoResult, LatticeParameters};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// Polynomial in the ring Z_q[X]/(X^n + 1)\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct Polynomial {\r\n    /// Coefficients [a_0, a_1, ..., a_{n-1}]\r\n    pub coeffs: Vec\u003ci64\u003e,\r\n    /// Degree (must be power of 2)\r\n    pub degree: usize,\r\n    /// Coefficient modulus\r\n    pub modulus: u64,\r\n}\r\n\r\nimpl Polynomial {\r\n    /// Create a polynomial from coefficients\r\n    pub fn from_coeffs(coeffs: Vec\u003ci64\u003e, modulus: u64) -\u003e Self {\r\n        let degree = coeffs.len();\r\n        Self {\r\n            coeffs,\r\n            degree,\r\n            modulus,\r\n        }\r\n    }\r\n\r\n    /// Create a zero polynomial\r\n    pub fn zero(degree: usize, modulus: u64) -\u003e Self {\r\n        Self {\r\n            coeffs: vec![0; degree],\r\n            degree,\r\n            modulus,\r\n        }\r\n    }\r\n}\r\n\r\n/// Ring-LWE parameters\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct RingLWEParameters {\r\n    /// Polynomial degree (must be power of 2)\r\n    pub n: usize,\r\n    /// Coefficient modulus\r\n    pub q: u64,\r\n    /// Error distribution standard deviation\r\n    pub sigma: f64,\r\n}\r\n\r\nimpl RingLWEParameters {\r\n    /// Create new Ring-LWE parameters\r\n    pub fn new(n: usize, q: u64, sigma: f64) -\u003e Self {\r\n        Self { n, q, sigma }\r\n    }\r\n\r\n    /// Standard 128-bit security parameters\r\n    pub fn new_128bit_security() -\u003e Self {\r\n        Self {\r\n            n: 512,\r\n            q: 12289,\r\n            sigma: 3.2,\r\n        }\r\n    }\r\n\r\n    /// Standard 192-bit security parameters\r\n    pub fn new_192bit_security() -\u003e Self {\r\n        Self {\r\n            n: 1024,\r\n            q: 40961,\r\n            sigma: 3.2,\r\n        }\r\n    }\r\n\r\n    /// Standard 256-bit security parameters\r\n    pub fn new_256bit_security() -\u003e Self {\r\n        Self {\r\n            n: 2048,\r\n            q: 65537,\r\n            sigma: 3.2,\r\n        }\r\n    }\r\n}\r\n\r\nimpl LatticeParameters for RingLWEParameters {\r\n    fn dimension(\u0026self) -\u003e usize {\r\n        self.n\r\n    }\r\n\r\n    fn modulus(\u0026self) -\u003e u64 {\r\n        self.q\r\n    }\r\n\r\n    fn sigma(\u0026self) -\u003e f64 {\r\n        self.sigma\r\n    }\r\n\r\n    fn validate(\u0026self) -\u003e CryptoResult\u003c()\u003e {\r\n        if !self.n.is_power_of_two() {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Dimension must be power of 2\".to_string(),\r\n            ));\r\n        }\r\n        if self.q \u003c 2 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Modulus must be at least 2\".to_string(),\r\n            ));\r\n        }\r\n        if self.sigma \u003c= 0.0 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Sigma must be positive\".to_string(),\r\n            ));\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n/// Ring-LWE public key\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct RingLWEPublicKey {\r\n    /// Random polynomial a\r\n    pub a: Polynomial,\r\n    /// Polynomial b = a*s + e\r\n    pub b: Polynomial,\r\n}\r\n\r\n/// Ring-LWE secret key\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct RingLWESecretKey {\r\n    /// Secret polynomial s\r\n    pub s: Polynomial,\r\n}\r\n\r\n/// Ring-LWE ciphertext\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct RingLWECiphertext {\r\n    /// Ciphertext component u = a*r + e1\r\n    pub u: Polynomial,\r\n    /// Ciphertext component v = b*r + e2 + encode(m)\r\n    pub v: Polynomial,\r\n}\r\n\r\n// ============================================================================\r\n// Polynomial Arithmetic Operations\r\n// ============================================================================\r\n\r\nuse rand::Rng;\r\nuse super::sampling::sample_error;\r\n\r\n/// Polynomial addition in R_q\r\npub fn poly_add(a: \u0026Polynomial, b: \u0026Polynomial, q: u64) -\u003e Polynomial {\r\n    assert_eq!(a.degree, b.degree, \"Polynomials must have same degree\");\r\n    \r\n    let coeffs: Vec\u003ci64\u003e = a.coeffs\r\n        .iter()\r\n        .zip(b.coeffs.iter())\r\n        .map(|(\u0026ai, \u0026bi)| (ai + bi).rem_euclid(q as i64))\r\n        .collect();\r\n    \r\n    Polynomial::from_coeffs(coeffs, q)\r\n}\r\n\r\n/// Polynomial subtraction in R_q\r\npub fn poly_sub(a: \u0026Polynomial, b: \u0026Polynomial, q: u64) -\u003e Polynomial {\r\n    assert_eq!(a.degree, b.degree, \"Polynomials must have same degree\");\r\n    \r\n    let coeffs: Vec\u003ci64\u003e = a.coeffs\r\n        .iter()\r\n        .zip(b.coeffs.iter())\r\n        .map(|(\u0026ai, \u0026bi)| (ai - bi).rem_euclid(q as i64))\r\n        .collect();\r\n    \r\n    Polynomial::from_coeffs(coeffs, q)\r\n}\r\n\r\n/// Scalar multiplication\r\npub fn poly_scalar_mult(poly: \u0026Polynomial, scalar: i64, q: u64) -\u003e Polynomial {\r\n    let coeffs: Vec\u003ci64\u003e = poly.coeffs\r\n        .iter()\r\n        .map(|\u0026c| ((c as i128 * scalar as i128) % q as i128) as i64)\r\n        .collect();\r\n    \r\n    Polynomial::from_coeffs(coeffs, q)\r\n}\r\n\r\n/// Sample polynomial with coefficients from error distribution\r\npub fn sample_poly_error(n: usize, sigma: f64, q: u64) -\u003e Polynomial {\r\n    let errors = sample_error(sigma, n);\r\n    let coeffs: Vec\u003ci64\u003e = errors\r\n        .iter()\r\n        .map(|\u0026e| e.rem_euclid(q as i64))\r\n        .collect();\r\n    \r\n    Polynomial::from_coeffs(coeffs, q)\r\n}\r\n\r\n/// Sample uniform random polynomial in R_q\r\npub fn sample_poly_uniform(n: usize, q: u64) -\u003e Polynomial {\r\n    let mut rng = rand::thread_rng();\r\n    let coeffs: Vec\u003ci64\u003e = (0..n)\r\n        .map(|_| rng.gen_range(0..q as i64))\r\n        .collect();\r\n    \r\n    Polynomial::from_coeffs(coeffs, q)\r\n}\r\n\r\n// ============================================================================\r\n// Number Theoretic Transform (NTT) Implementation\r\n// ============================================================================\r\n\r\n/// Find primitive nth root of unity mod q\r\n/// For NTT, we need q ≡ 1 (mod 2n) and ω^n ≡ -1 (mod q)\r\npub fn find_primitive_root(n: usize, q: u64) -\u003e Option\u003cu64\u003e {\r\n    // Known roots for common parameter sets\r\n    if q == 12289 {\r\n        if n == 512 { return Some(49); }\r\n        else if n == 256 { return Some(2401); }\r\n    } else if q == 40961 \u0026\u0026 n == 1024 {\r\n        return Some(3);\r\n    } else if q == 65537 \u0026\u0026 n == 2048 {\r\n        return Some(3);\r\n    }\r\n    \r\n    // General case: search for primitive root\r\n    for candidate in 2..std::cmp::min(1000, q) {\r\n        if is_primitive_root(candidate, n, q) {\r\n            return Some(candidate);\r\n        }\r\n    }\r\n    \r\n    None\r\n}\r\n\r\n/// Check if omega is a primitive 2n-th root of unity mod q\r\nfn is_primitive_root(omega: u64, n: usize, q: u64) -\u003e bool {\r\n    // ω^n ≡ -1 (mod q)\r\n    let half_order = mod_exp(omega, n as u64, q);\r\n    if half_order != q - 1 {\r\n        return false;\r\n    }\r\n    \r\n    // ω^(2n) ≡ 1 (mod q)\r\n    let full_order = mod_exp(omega, (2 * n) as u64, q);\r\n    full_order == 1\r\n}\r\n\r\n/// Modular exponentiation: base^exp mod modulus\r\nfn mod_exp(mut base: u64, mut exp: u64, modulus: u64) -\u003e u64 {\r\n    let mut result = 1u64;\r\n    base %= modulus;\r\n    \r\n    while exp \u003e 0 {\r\n        if exp % 2 == 1 {\r\n            result = ((result as u128 * base as u128) % modulus as u128) as u64;\r\n        }\r\n        exp \u003e\u003e= 1;\r\n        base = ((base as u128 * base as u128) % modulus as u128) as u64;\r\n    }\r\n    \r\n    result\r\n}\r\n\r\n/// Number Theoretic Transform (NTT) - Forward transform\r\n/// Implements Cooley-Tukey FFT-style algorithm for NTT\r\npub fn ntt(poly: \u0026Polynomial, q: u64, primitive_root: u64) -\u003e Vec\u003ci64\u003e {\r\n    let n = poly.degree;\r\n    assert!(n.is_power_of_two(), \"Degree must be power of 2 for NTT\");\r\n    \r\n    let mut result = poly.coeffs.clone();\r\n    let mut len = 1;\r\n    \r\n    while len \u003c n {\r\n        let step = n / (len * 2);\r\n        let mut k = 0;\r\n        \r\n        while k \u003c n {\r\n            let omega = mod_exp(primitive_root, step as u64, q);\r\n            let mut omega_pow = 1u64;\r\n            \r\n            for j in 0..len {\r\n                let u = result[k + j];\r\n                let v = ((result[k + j + len] as i128 * omega_pow as i128) \r\n                        % q as i128) as i64;\r\n                \r\n                result[k + j] = (u + v).rem_euclid(q as i64);\r\n                result[k + j + len] = (u - v).rem_euclid(q as i64);\r\n                \r\n                omega_pow = ((omega_pow as u128 * omega as u128) % q as u128) as u64;\r\n            }\r\n            \r\n            k += len * 2;\r\n        }\r\n        \r\n        len *= 2;\r\n    }\r\n    \r\n    result\r\n}\r\n\r\n/// Inverse Number Theoretic Transform (INTT)\r\npub fn intt(transformed: \u0026[i64], n: usize, q: u64, primitive_root: u64) -\u003e Polynomial {\r\n    assert!(n.is_power_of_two(), \"Size must be power of 2 for INTT\");\r\n    \r\n    // Find inverse of primitive root\r\n    let omega_inv = mod_inverse(primitive_root as i64, q as i64) as u64;\r\n    \r\n    // Apply NTT with inverse root\r\n    let mut result = transformed.to_vec();\r\n    let mut len = n / 2;\r\n    \r\n    while len \u003e 0 {\r\n        let step = n / (len * 2);\r\n        let mut k = 0;\r\n        \r\n        while k \u003c n {\r\n            let omega = mod_exp(omega_inv, step as u64, q);\r\n            let mut omega_pow = 1u64;\r\n            \r\n            for j in 0..len {\r\n                let u = result[k + j];\r\n                let v = result[k + j + len];\r\n                \r\n                result[k + j] = (u + v).rem_euclid(q as i64);\r\n                \r\n                let diff = (u - v).rem_euclid(q as i64);\r\n                result[k + j + len] = ((diff as i128 * omega_pow as i128) \r\n                                       % q as i128) as i64;\r\n                \r\n                omega_pow = ((omega_pow as u128 * omega as u128) % q as u128) as u64;\r\n            }\r\n            \r\n            k += len * 2;\r\n        }\r\n        \r\n        len /= 2;\r\n    }\r\n    \r\n    // Divide by n\r\n    let n_inv = mod_inverse(n as i64, q as i64);\r\n    for coeff in result.iter_mut() {\r\n        *coeff = ((*coeff as i128 * n_inv as i128) % q as i128) as i64;\r\n    }\r\n    \r\n    Polynomial::from_coeffs(result, q)\r\n}\r\n\r\n/// Modular multiplicative inverse using extended Euclidean algorithm\r\nfn mod_inverse(a: i64, m: i64) -\u003e i64 {\r\n    let (gcd, x, _) = extended_gcd(a, m);\r\n    assert_eq!(gcd, 1, \"Modular inverse does not exist\");\r\n    (x % m + m) % m\r\n}\r\n\r\n/// Extended Euclidean algorithm\r\nfn extended_gcd(a: i64, b: i64) -\u003e (i64, i64, i64) {\r\n    if a == 0 {\r\n        return (b, 0, 1);\r\n    }\r\n    let (gcd, x1, y1) = extended_gcd(b % a, a);\r\n    let x = y1 - (b / a) * x1;\r\n    let y = x1;\r\n    (gcd, x, y)\r\n}\r\n\r\n/// Polynomial multiplication in R_q = Z_q[X]/(X^n + 1) using schoolbook method\r\n/// This is a simple O(n^2) implementation. NTT can be added later for O(n log n)\r\npub fn poly_mult_schoolbook(a: \u0026Polynomial, b: \u0026Polynomial, q: u64) -\u003e Polynomial {\r\n    assert_eq!(a.degree, b.degree, \"Polynomials must have same degree\");\r\n    let n = a.degree;\r\n    \r\n    // Result has degree 2n-2 before reduction\r\n    let mut result = vec![0i128; 2 * n - 1];\r\n    \r\n    // Multiply coefficients\r\n    for i in 0..n {\r\n        for j in 0..n {\r\n            result[i + j] += a.coeffs[i] as i128 * b.coeffs[j] as i128;\r\n        }\r\n    }\r\n    \r\n    // Reduce by X^n + 1: X^(n+k) = -X^k\r\n    let mut reduced = vec![0i64; n];\r\n    for i in 0..n {\r\n        reduced[i] = (result[i] % q as i128) as i64;\r\n    }\r\n    for i in n..(2*n-1) {\r\n        let k = i - n;\r\n        reduced[k] = ((reduced[k] as i128 - result[i]) % q as i128) as i64;\r\n    }\r\n    \r\n    // Normalize to [0, q)\r\n    for i in 0..n {\r\n        reduced[i] = ((reduced[i] % q as i64) + q as i64) % q as i64;\r\n    }\r\n    \r\n    Polynomial::from_coeffs(reduced, q)\r\n}\r\n\r\n/// Fast polynomial multiplication using NTT\r\n/// Complexity: O(n log n) vs O(n²) for naive multiplication\r\n/// Note: NTT implementation needs debugging, using schoolbook for now\r\npub fn poly_mult_ntt(a: \u0026Polynomial, b: \u0026Polynomial, q: u64) -\u003e Polynomial {\r\n    // TODO: Fix NTT implementation\r\n    // For now, use schoolbook multiplication\r\n    poly_mult_schoolbook(a, b, q)\r\n}\r\n\r\n// ============================================================================\r\n// Message Encoding/Decoding\r\n// ============================================================================\r\n\r\n/// Encode message bits into polynomial coefficients\r\n/// Each bit is scaled to q/2 for robust decryption\r\npub fn encode_message(message: \u0026[bool], n: usize, q: u64) -\u003e Polynomial {\r\n    let scale = q / 2;\r\n    let mut coeffs = vec![0i64; n];\r\n    \r\n    for (i, \u0026bit) in message.iter().enumerate().take(n) {\r\n        coeffs[i] = if bit { scale as i64 } else { 0 };\r\n    }\r\n    \r\n    Polynomial::from_coeffs(coeffs, q)\r\n}\r\n\r\n/// Decode polynomial coefficients back to message bits\r\n/// Decoding uses rounding: if coefficient is closer to q/2 than to 0, it's a 1\r\npub fn decode_message(poly: \u0026Polynomial) -\u003e Vec\u003cbool\u003e {\r\n    let q = poly.modulus;\r\n    let quarter = q / 4;\r\n    \r\n    poly.coeffs\r\n        .iter()\r\n        .map(|\u0026c| {\r\n            // Normalize to [0, q)\r\n            let val = ((c % (q as i64)) + (q as i64)) as u64 % q;\r\n            // Check if closer to q/2 than to 0 or q\r\n            val \u003e= quarter \u0026\u0026 val \u003c (3 * quarter)\r\n        })\r\n        .collect()\r\n}\r\n\r\n// ============================================================================\r\n// Ring-LWE Cryptographic Operations\r\n// ============================================================================\r\n\r\n/// Generate Ring-LWE key pair\r\npub fn ring_keygen(params: \u0026RingLWEParameters) -\u003e CryptoResult\u003c(RingLWESecretKey, RingLWEPublicKey)\u003e {\r\n    params.validate()?;\r\n    \r\n    // Sample secret polynomial s with small coefficients\r\n    let s = sample_poly_error(params.n, params.sigma, params.q);\r\n    \r\n    // Sample random polynomial a\r\n    let a = sample_poly_uniform(params.n, params.q);\r\n    \r\n    // Sample error e\r\n    let e = sample_poly_error(params.n, params.sigma, params.q);\r\n    \r\n    // Compute b = a*s + e (mod q, mod X^n+1)\r\n    let as_prod = poly_mult_ntt(\u0026a, \u0026s, params.q);\r\n    let b = poly_add(\u0026as_prod, \u0026e, params.q);\r\n    \r\n    let sk = RingLWESecretKey { s };\r\n    let pk = RingLWEPublicKey { a, b };\r\n    \r\n    Ok((sk, pk))\r\n}\r\n\r\n/// Encrypt message bits using Ring-LWE\r\npub fn ring_encrypt(\r\n    pk: \u0026RingLWEPublicKey,\r\n    message: \u0026[bool],\r\n    params: \u0026RingLWEParameters,\r\n) -\u003e CryptoResult\u003cRingLWECiphertext\u003e {\r\n    params.validate()?;\r\n    \r\n    if message.len() \u003e params.n {\r\n        return Err(CryptoError::InvalidParameter(\r\n            format!(\"Message too long: {} bits, max {}\", message.len(), params.n),\r\n        ));\r\n    }\r\n    \r\n    // Sample ephemeral random polynomial r\r\n    let r = sample_poly_error(params.n, params.sigma, params.q);\r\n    \r\n    // Sample error polynomials e1, e2\r\n    let e1 = sample_poly_error(params.n, params.sigma, params.q);\r\n    let e2 = sample_poly_error(params.n, params.sigma, params.q);\r\n    \r\n    // Encode message\r\n    let m_poly = encode_message(message, params.n, params.q);\r\n    \r\n    // Compute u = a*r + e1\r\n    let ar_prod = poly_mult_ntt(\u0026pk.a, \u0026r, params.q);\r\n    let u = poly_add(\u0026ar_prod, \u0026e1, params.q);\r\n    \r\n    // Compute v = b*r + e2 + m\r\n    let br_prod = poly_mult_ntt(\u0026pk.b, \u0026r, params.q);\r\n    let br_e2 = poly_add(\u0026br_prod, \u0026e2, params.q);\r\n    let v = poly_add(\u0026br_e2, \u0026m_poly, params.q);\r\n    \r\n    Ok(RingLWECiphertext { u, v })\r\n}\r\n\r\n/// Decrypt Ring-LWE ciphertext\r\npub fn ring_decrypt(\r\n    sk: \u0026RingLWESecretKey,\r\n    ct: \u0026RingLWECiphertext,\r\n    params: \u0026RingLWEParameters,\r\n) -\u003e CryptoResult\u003cVec\u003cbool\u003e\u003e {\r\n    params.validate()?;\r\n    \r\n    // Compute m' = v - u*s\r\n    let us_prod = poly_mult_ntt(\u0026ct.u, \u0026sk.s, params.q);\r\n    let m_noisy = poly_sub(\u0026ct.v, \u0026us_prod, params.q);\r\n    \r\n    // Decode message bits\r\n    let message = decode_message(\u0026m_noisy);\r\n    \r\n    Ok(message)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_ring_lwe_parameters() {\r\n        let params = RingLWEParameters::new_128bit_security();\r\n        assert!(params.validate().is_ok());\r\n        assert_eq!(params.n, 512);\r\n    }\r\n\r\n    #[test]\r\n    fn test_polynomial_creation() {\r\n        let poly = Polynomial::zero(512, 12289);\r\n        assert_eq!(poly.degree, 512);\r\n        assert_eq!(poly.coeffs.len(), 512);\r\n    }\r\n\r\n    #[test]\r\n    fn test_polynomial_arithmetic() {\r\n        let q = 12289;\r\n        let a = Polynomial::from_coeffs(vec![1, 2, 3, 4], q);\r\n        let b = Polynomial::from_coeffs(vec![5, 6, 7, 8], q);\r\n        \r\n        // Test addition\r\n        let c = poly_add(\u0026a, \u0026b, q);\r\n        assert_eq!(c.coeffs, vec![6, 8, 10, 12]);\r\n        \r\n        // Test subtraction\r\n        let d = poly_sub(\u0026b, \u0026a, q);\r\n        assert_eq!(d.coeffs, vec![4, 4, 4, 4]);\r\n        \r\n        // Test scalar multiplication\r\n        let e = poly_scalar_mult(\u0026a, 3, q);\r\n        assert_eq!(e.coeffs, vec![3, 6, 9, 12]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_ntt_primitive_root() {\r\n        // Test known primitive roots\r\n        let root_512 = find_primitive_root(512, 12289);\r\n        assert!(root_512.is_some());\r\n        \r\n        let omega = root_512.unwrap();\r\n        // Verify ω^512 ≡ -1 (mod 12289)\r\n        let half_order = mod_exp(omega, 512, 12289);\r\n        assert_eq!(half_order, 12288); // q - 1 = -1 mod q\r\n        \r\n        // Verify ω^1024 ≡ 1 (mod 12289)\r\n        let full_order = mod_exp(omega, 1024, 12289);\r\n        assert_eq!(full_order, 1);\r\n    }\r\n\r\n    #[test]\r\n    fn test_ntt_intt_correctness() {\r\n        let q = 12289;\r\n        let n = 512;\r\n        \r\n        // Create test polynomial\r\n        let coeffs: Vec\u003ci64\u003e = (0..n).map(|i| (i % 100) as i64).collect();\r\n        let poly = Polynomial::from_coeffs(coeffs.clone(), q);\r\n        \r\n        // Find primitive root\r\n        let root = find_primitive_root(n, q).unwrap();\r\n        \r\n        // Transform and inverse transform\r\n        let transformed = ntt(\u0026poly, q, root);\r\n        let recovered = intt(\u0026transformed, n, q, root);\r\n        \r\n        // Verify we get back original coefficients\r\n        for (i, (\u0026orig, \u0026rec)) in coeffs.iter().zip(recovered.coeffs.iter()).enumerate() {\r\n            assert_eq!(\r\n                orig, rec,\r\n                \"Coefficient {} mismatch: original {} != recovered {}\",\r\n                i, orig, rec\r\n            );\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_ntt_multiplication() {\r\n        let q = 12289;\r\n        let n = 512; // Use standard parameter size\r\n        \r\n        // Create two simple polynomials\r\n        let mut a_coeffs = vec![0i64; n];\r\n        let mut b_coeffs = vec![0i64; n];\r\n        a_coeffs[0] = 1;\r\n        a_coeffs[1] = 2;\r\n        b_coeffs[0] = 3;\r\n        b_coeffs[1] = 4;\r\n        \r\n        let a = Polynomial::from_coeffs(a_coeffs, q);\r\n        let b = Polynomial::from_coeffs(b_coeffs, q);\r\n        \r\n        // Multiply using NTT\r\n        let c = poly_mult_ntt(\u0026a, \u0026b, q);\r\n        \r\n        // (1 + 2x) * (3 + 4x) = 3 + 10x + 8x^2 in normal multiplication\r\n        // In ring R_q, this should match\r\n        assert_eq!(c.coeffs[0], 3);  // Constant term\r\n        assert_eq!(c.coeffs[1], 10); // x term\r\n        assert_eq!(c.coeffs[2], 8);  // x^2 term\r\n    }\r\n\r\n    #[test]\r\n    fn test_message_encoding_decoding() {\r\n        let q = 12289;\r\n        let n = 512;\r\n        \r\n        // Test message\r\n        let message = vec![true, false, true, true, false];\r\n        \r\n        // Encode and decode\r\n        let poly = encode_message(\u0026message, n, q);\r\n        let decoded = decode_message(\u0026poly);\r\n        \r\n        // Verify first 5 bits match\r\n        assert_eq!(\u0026decoded[0..5], \u0026message[..]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_keygen() {\r\n        let params = RingLWEParameters::new_128bit_security();\r\n        let result = ring_keygen(\u0026params);\r\n        \r\n        assert!(result.is_ok());\r\n        let (sk, pk) = result.unwrap();\r\n        \r\n        // Verify key dimensions\r\n        assert_eq!(sk.s.degree, params.n);\r\n        assert_eq!(pk.a.degree, params.n);\r\n        assert_eq!(pk.b.degree, params.n);\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_encrypt_decrypt() {\r\n        let params = RingLWEParameters::new_128bit_security();\r\n        let (sk, pk) = ring_keygen(\u0026params).unwrap();\r\n        \r\n        // Test message\r\n        let message = vec![true, false, true, true, false, true, false, false];\r\n        \r\n        // Encrypt\r\n        let ct = ring_encrypt(\u0026pk, \u0026message, \u0026params).unwrap();\r\n        \r\n        // Decrypt\r\n        let decrypted = ring_decrypt(\u0026sk, \u0026ct, \u0026params).unwrap();\r\n        \r\n        // Verify decryption correctness (first message.len() bits)\r\n        assert_eq!(\u0026decrypted[0..message.len()], \u0026message[..]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_multiple_messages() {\r\n        let params = RingLWEParameters::new_128bit_security();\r\n        let (sk, pk) = ring_keygen(\u0026params).unwrap();\r\n        \r\n        // Test multiple different messages\r\n        let messages = vec![\r\n            vec![true; 10],\r\n            vec![false; 10],\r\n            vec![true, false, true, false, true, false],\r\n        ];\r\n        \r\n        for message in messages {\r\n            let ct = ring_encrypt(\u0026pk, \u0026message, \u0026params).unwrap();\r\n            let decrypted = ring_decrypt(\u0026sk, \u0026ct, \u0026params).unwrap();\r\n            \r\n            assert_eq!(\u0026decrypted[0..message.len()], \u0026message[..]);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_error_handling() {\r\n        let params = RingLWEParameters::new_128bit_security();\r\n        let (_, pk) = ring_keygen(\u0026params).unwrap();\r\n        \r\n        // Message too long\r\n        let long_message = vec![true; params.n + 1];\r\n        let result = ring_encrypt(\u0026pk, \u0026long_message, \u0026params);\r\n        \r\n        assert!(result.is_err());\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":1152921504606848712}},{"line":23,"address":[],"length":0,"stats":{"Line":3458764513820546136}},{"line":32,"address":[],"length":0,"stats":{"Line":216172782113783835}},{"line":34,"address":[],"length":0,"stats":{"Line":648518346341351505}},{"line":54,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":59,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":68,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":77,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":100,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":101,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":102,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":105,"address":[],"length":0,"stats":{"Line":3386706919782612995}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":110,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":152,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":153,"address":[],"length":0,"stats":{"Line":5476377146882523126}},{"line":155,"address":[],"length":0,"stats":{"Line":16429131440647569438}},{"line":157,"address":[],"length":0,"stats":{"Line":10952754293765046292}},{"line":158,"address":[],"length":0,"stats":{"Line":6269010681299730451}},{"line":161,"address":[],"length":0,"stats":{"Line":16429131440647569438}},{"line":165,"address":[],"length":0,"stats":{"Line":1152921504606846986}},{"line":166,"address":[],"length":0,"stats":{"Line":1152921504606846995}},{"line":168,"address":[],"length":0,"stats":{"Line":3458764513820540931}},{"line":170,"address":[],"length":0,"stats":{"Line":2305843009213693954}},{"line":171,"address":[],"length":0,"stats":{"Line":2882303761517124137}},{"line":174,"address":[],"length":0,"stats":{"Line":3458764513820540931}},{"line":178,"address":[],"length":0,"stats":{"Line":144115188075855873}},{"line":179,"address":[],"length":0,"stats":{"Line":432345564227567619}},{"line":181,"address":[],"length":0,"stats":{"Line":720575940379279916}},{"line":184,"address":[],"length":0,"stats":{"Line":432345564227567619}},{"line":188,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":189,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":190,"address":[],"length":0,"stats":{"Line":14267403619509731328}},{"line":192,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":195,"address":[],"length":0,"stats":{"Line":14267403619509731328}},{"line":199,"address":[],"length":0,"stats":{"Line":864691128455135237}},{"line":200,"address":[],"length":0,"stats":{"Line":1729382256910270474}},{"line":201,"address":[],"length":0,"stats":{"Line":2594073385365405711}},{"line":202,"address":[],"length":0,"stats":{"Line":864691128455143490}},{"line":205,"address":[],"length":0,"stats":{"Line":2594073385365405711}},{"line":214,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":216,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":217,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":4539628424389459970}},{"line":227,"address":[],"length":0,"stats":{"Line":17582052945254416384}},{"line":228,"address":[],"length":0,"stats":{"Line":72057594037927937}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":238,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":239,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":240,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":244,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":245,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":249,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":250,"address":[],"length":0,"stats":{"Line":10088063165309911040}},{"line":251,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":253,"address":[],"length":0,"stats":{"Line":12970366926827028495}},{"line":254,"address":[],"length":0,"stats":{"Line":16357073846609641633}},{"line":255,"address":[],"length":0,"stats":{"Line":5044031582654955666}},{"line":257,"address":[],"length":0,"stats":{"Line":11313042263954685967}},{"line":258,"address":[],"length":0,"stats":{"Line":11313042263954685967}},{"line":261,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":266,"address":[],"length":0,"stats":{"Line":432345564227567631}},{"line":267,"address":[],"length":0,"stats":{"Line":864691128455135262}},{"line":268,"address":[],"length":0,"stats":{"Line":1297036692682702908}},{"line":270,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":271,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":273,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":274,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":275,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":277,"address":[],"length":0,"stats":{"Line":3746994889972252672}},{"line":278,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":279,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":281,"address":[],"length":0,"stats":{"Line":4179340454199820304}},{"line":282,"address":[],"length":0,"stats":{"Line":6917529027641081888}},{"line":283,"address":[],"length":0,"stats":{"Line":6917529027641081888}},{"line":284,"address":[],"length":0,"stats":{"Line":3458764513820540944}},{"line":286,"address":[],"length":0,"stats":{"Line":8646911284551352360}},{"line":287,"address":[],"length":0,"stats":{"Line":8646911284551352360}},{"line":289,"address":[],"length":0,"stats":{"Line":1729382256910270472}},{"line":292,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":295,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":298,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":302,"address":[],"length":0,"stats":{"Line":288230376151711786}},{"line":303,"address":[],"length":0,"stats":{"Line":864691128455135400}},{"line":306,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":309,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":310,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":312,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":313,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":314,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":316,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":317,"address":[],"length":0,"stats":{"Line":17005592192950992896}},{"line":318,"address":[],"length":0,"stats":{"Line":17870283321406128128}},{"line":320,"address":[],"length":0,"stats":{"Line":18158513697557839888}},{"line":321,"address":[],"length":0,"stats":{"Line":32}},{"line":322,"address":[],"length":0,"stats":{"Line":32}},{"line":324,"address":[],"length":0,"stats":{"Line":40}},{"line":326,"address":[],"length":0,"stats":{"Line":40}},{"line":327,"address":[],"length":0,"stats":{"Line":32}},{"line":328,"address":[],"length":0,"stats":{"Line":16}},{"line":330,"address":[],"length":0,"stats":{"Line":8}},{"line":333,"address":[],"length":0,"stats":{"Line":18158513697557839872}},{"line":336,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":340,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":341,"address":[],"length":0,"stats":{"Line":576460752303423572}},{"line":342,"address":[],"length":0,"stats":{"Line":42}},{"line":345,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":349,"address":[],"length":0,"stats":{"Line":576460752303423496}},{"line":350,"address":[],"length":0,"stats":{"Line":2305843009213693984}},{"line":351,"address":[],"length":0,"stats":{"Line":576460752303423504}},{"line":352,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":356,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":357,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":358,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":360,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":361,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":362,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":363,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":368,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":369,"address":[],"length":0,"stats":{"Line":3963167672086036476}},{"line":370,"address":[],"length":0,"stats":{"Line":7926335344172072968}},{"line":373,"address":[],"length":0,"stats":{"Line":11889503016258109452}},{"line":376,"address":[],"length":0,"stats":{"Line":3963167672086036484}},{"line":377,"address":[],"length":0,"stats":{"Line":4428}},{"line":378,"address":[],"length":0,"stats":{"Line":8856}},{"line":383,"address":[],"length":0,"stats":{"Line":11889503016258109452}},{"line":384,"address":[],"length":0,"stats":{"Line":3963167672088502592}},{"line":385,"address":[],"length":0,"stats":{"Line":2466108}},{"line":387,"address":[],"length":0,"stats":{"Line":4428}},{"line":388,"address":[],"length":0,"stats":{"Line":6557241057451448806}},{"line":389,"address":[],"length":0,"stats":{"Line":6557241057451448806}},{"line":393,"address":[],"length":0,"stats":{"Line":3963167672086040896}},{"line":394,"address":[],"length":0,"stats":{"Line":4412}},{"line":397,"address":[],"length":0,"stats":{"Line":11889503016258109452}},{"line":403,"address":[],"length":0,"stats":{"Line":3963167672086038694}},{"line":406,"address":[],"length":0,"stats":{"Line":15852670688344154776}},{"line":415,"address":[],"length":0,"stats":{"Line":1080863910568919044}},{"line":416,"address":[],"length":0,"stats":{"Line":2161727821137838088}},{"line":417,"address":[],"length":0,"stats":{"Line":3242591731706757132}},{"line":419,"address":[],"length":0,"stats":{"Line":12898309332789100558}},{"line":420,"address":[],"length":0,"stats":{"Line":11673330234144325630}},{"line":423,"address":[],"length":0,"stats":{"Line":3242591731706757132}},{"line":428,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":429,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":430,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":432,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":434,"address":[],"length":0,"stats":{"Line":1080863910568919583}},{"line":436,"address":[],"length":0,"stats":{"Line":1086}},{"line":438,"address":[],"length":0,"stats":{"Line":504403158265496652}},{"line":448,"address":[],"length":0,"stats":{"Line":864691128455135233}},{"line":449,"address":[],"length":0,"stats":{"Line":1729382256910270467}},{"line":452,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":455,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":458,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":461,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":462,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":464,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":465,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":467,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":471,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":476,"address":[],"length":0,"stats":{"Line":2161727821137838081}},{"line":478,"address":[],"length":0,"stats":{"Line":2161727821137838078}},{"line":479,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":480,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":485,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":488,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":489,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":492,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":495,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":496,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":499,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":500,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":501,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":503,"address":[],"length":0,"stats":{"Line":1008806316530991103}},{"line":507,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":512,"address":[],"length":0,"stats":{"Line":2017612633061982209}},{"line":515,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":516,"address":[],"length":0,"stats":{"Line":5044031582654955515}},{"line":519,"address":[],"length":0,"stats":{"Line":3026418949592973309}},{"line":521,"address":[],"length":0,"stats":{"Line":1008806316530991103}}],"covered":185,"coverable":197},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","lattice","sampling.rs"],"content":"//! Error sampling from discrete Gaussian distributions\r\n//!\r\n//! This module implements sampling from discrete Gaussian distributions,\r\n//! which is crucial for LWE security.\r\n\r\nuse ndarray::Array1;\r\nuse rand::Rng;\r\n\r\n/// Sample error vector from discrete Gaussian distribution\r\n///\r\n/// Uses Box-Muller transform to generate continuous Gaussian,\r\n/// then rounds to nearest integer for discrete Gaussian.\r\npub fn sample_error(sigma: f64, dimension: usize) -\u003e Array1\u003ci64\u003e {\r\n    let mut rng = rand::thread_rng();\r\n    Array1::from_shape_fn(dimension, |_| sample_gaussian_int(sigma, \u0026mut rng))\r\n}\r\n\r\n/// Sample a single integer from discrete Gaussian\r\nfn sample_gaussian_int\u003cR: Rng\u003e(sigma: f64, rng: \u0026mut R) -\u003e i64 {\r\n    // Box-Muller transform for continuous Gaussian\r\n    let u1: f64 = rng.gen();\r\n    let u2: f64 = rng.gen();\r\n\r\n    let z = (-2.0 * u1.ln()).sqrt() * (2.0 * std::f64::consts::PI * u2).cos();\r\n    let scaled = z * sigma;\r\n\r\n    // Round to nearest integer\r\n    scaled.round() as i64\r\n}\r\n\r\n/// Sample uniform random values\r\npub fn sample_uniform(min: i64, max: i64, dimension: usize) -\u003e Array1\u003ci64\u003e {\r\n    let mut rng = rand::thread_rng();\r\n    Array1::from_shape_fn(dimension, |_| rng.gen_range(min..max))\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_error_sampling() {\r\n        let errors = sample_error(3.2, 1000);\r\n\r\n        // Check dimension\r\n        assert_eq!(errors.len(), 1000);\r\n\r\n        // Compute empirical mean (should be close to 0)\r\n        let mean: f64 = errors.iter().map(|\u0026x| x as f64).sum::\u003cf64\u003e() / 1000.0;\r\n        assert!(mean.abs() \u003c 1.0, \"Mean {} too far from 0\", mean);\r\n\r\n        // Compute empirical standard deviation (should be close to sigma)\r\n        let variance: f64 = errors\r\n            .iter()\r\n            .map(|\u0026x| {\r\n                let diff = x as f64 - mean;\r\n                diff * diff\r\n            })\r\n            .sum::\u003cf64\u003e()\r\n            / 1000.0;\r\n        let std_dev = variance.sqrt();\r\n        assert!(\r\n            (std_dev - 3.2).abs() \u003c 0.5,\r\n            \"Std dev {} too far from 3.2\",\r\n            std_dev\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_uniform_sampling() {\r\n        let values = sample_uniform(0, 100, 1000);\r\n        assert_eq!(values.len(), 1000);\r\n\r\n        // All values should be in range [0, 100)\r\n        for \u0026val in values.iter() {\r\n            assert!(val \u003e= 0 \u0026\u0026 val \u003c 100);\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":6773413839565225984}},{"line":14,"address":[],"length":0,"stats":{"Line":13546827679130451968}},{"line":15,"address":[],"length":0,"stats":{"Line":2594073385365405702}},{"line":19,"address":[],"length":0,"stats":{"Line":8646911284551355657}},{"line":21,"address":[],"length":0,"stats":{"Line":16140901064495871012}},{"line":22,"address":[],"length":0,"stats":{"Line":16140901064495871012}},{"line":24,"address":[],"length":0,"stats":{"Line":16140901064495871012}},{"line":25,"address":[],"length":0,"stats":{"Line":17293822569102711314}},{"line":28,"address":[],"length":0,"stats":{"Line":8646911284551355657}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927942}},{"line":33,"address":[],"length":0,"stats":{"Line":144115188075855884}},{"line":34,"address":[],"length":0,"stats":{"Line":13402712491054606119}}],"covered":12,"coverable":12},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","lib.rs"],"content":"//! Nexuszero Crypto - Quantum-Resistant Zero-Knowledge Proof System\n//!\n//! This library provides lattice-based cryptographic primitives for building\n//! zero-knowledge proof systems that are resistant to quantum attacks.\n//!\n//! # Features\n//!\n//! - **LWE Encryption**: Learning With Errors based encryption\n//! - **Ring-LWE**: Efficient ring-based variant with NTT optimization\n//! - **Zero-Knowledge Proofs**: Statement/Witness/Proof system\n//! - **Parameter Selection**: Automatic security parameter optimization\n//!\n//! # Example\n//!\n//! ```rust,no_run\n//! use nexuszero_crypto::{SecurityLevel, CryptoParameters};\n//!\n//! // Select security parameters\n//! let params = CryptoParameters::from_security_level(SecurityLevel::Bit128);\n//!\n//! // Create statement and witness (examples to be implemented)\n//! // let statement = ...;\n//! // let witness = ...;\n//! // let proof = prove(\u0026statement, \u0026witness, \u0026params)?;\n//! // verify(\u0026statement, \u0026proof, \u0026params)?;\n//! ```\n\n#![warn(missing_docs)]\n#![warn(clippy::all)]\n\npub mod lattice;\npub mod params;\npub mod proof;\npub mod utils;\n\n// Re-export commonly used types\npub use params::{CryptoParameters, SecurityLevel};\n\n/// Custom error type for cryptographic operations\n#[derive(Debug, thiserror::Error)]\npub enum CryptoError {\n    /// Invalid security parameter\n    #[error(\"Invalid security parameter: {0}\")]\n    InvalidParameter(String),\n\n    /// Encryption/Decryption error\n    #[error(\"Encryption error: {0}\")]\n    EncryptionError(String),\n\n    /// Proof generation error\n    #[error(\"Proof generation failed: {0}\")]\n    ProofError(String),\n\n    /// Verification error\n    #[error(\"Verification failed: {0}\")]\n    VerificationError(String),\n\n    /// Serialization error\n    #[error(\"Serialization error: {0}\")]\n    SerializationError(String),\n\n    /// Mathematical operation error\n    #[error(\"Math error: {0}\")]\n    MathError(String),\n}\n\n/// Result type for cryptographic operations\npub type CryptoResult\u003cT\u003e = Result\u003cT, CryptoError\u003e;\n\n/// Trait for lattice-based cryptographic parameters\npub trait LatticeParameters {\n    /// Get the dimension parameter\n    fn dimension(\u0026self) -\u003e usize;\n\n    /// Get the modulus\n    fn modulus(\u0026self) -\u003e u64;\n\n    /// Get the error distribution parameter\n    fn sigma(\u0026self) -\u003e f64;\n\n    /// Validate parameters\n    fn validate(\u0026self) -\u003e CryptoResult\u003c()\u003e;\n}\n\n/// Trait for proof systems\npub trait ProofSystem {\n    /// Statement type\n    type Statement;\n\n    /// Witness type\n    type Witness;\n\n    /// Proof type\n    type Proof;\n\n    /// Generate a proof\n    fn prove(\n        statement: \u0026Self::Statement,\n        witness: \u0026Self::Witness,\n    ) -\u003e CryptoResult\u003cSelf::Proof\u003e;\n\n    /// Verify a proof\n    fn verify(statement: \u0026Self::Statement, proof: \u0026Self::Proof) -\u003e CryptoResult\u003c()\u003e;\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_library_initialization() {\n        // Basic smoke test\n        assert!(true);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","params","mod.rs"],"content":"//! Security parameter selection and management\r\n//!\r\n//! This module provides parameter sets for different security levels\r\n//! and algorithms for selecting optimal parameters.\r\n\r\npub mod security;\r\n\r\n/// Parameter selection with Miller-Rabin primality testing and security estimation\r\npub mod selector;\r\n\r\n// Re-export main types\r\npub use security::{CryptoParameters, ParameterSet, SecurityLevel};\r\npub use selector::{ParameterSelector, is_prime_miller_rabin, generate_prime};\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","params","security.rs"],"content":"//! Security parameter definitions and selection\r\n//!\r\n//! This module provides standard security levels and parameter sets.\r\n\r\nuse crate::lattice::RingLWEParameters;\r\nuse crate::{CryptoError, CryptoResult};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// Standard security levels (NIST post-quantum standards)\r\n#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq)]\r\npub enum SecurityLevel {\r\n    /// 128-bit security (NIST Level 1) - Comparable to AES-128\r\n    Bit128,\r\n    /// 192-bit security (NIST Level 3) - Comparable to AES-192\r\n    Bit192,\r\n    /// 256-bit security (NIST Level 5) - Comparable to AES-256\r\n    Bit256,\r\n}\r\n\r\n/// Complete parameter set for a security level\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct ParameterSet {\r\n    /// Security level\r\n    pub security_level: SecurityLevel,\r\n    /// Ring dimension (power of 2)\r\n    pub n: usize,\r\n    /// Coefficient modulus (prime)\r\n    pub q: u64,\r\n    /// Error distribution standard deviation\r\n    pub sigma: f64,\r\n    /// Estimated proof size (bytes)\r\n    pub proof_size: usize,\r\n    /// Estimated prove time (milliseconds)\r\n    pub prove_time_ms: u64,\r\n    /// Estimated verify time (milliseconds)\r\n    pub verify_time_ms: u64,\r\n}\r\n\r\nimpl ParameterSet {\r\n    /// Get standard parameter set for security level\r\n    pub fn from_security_level(level: SecurityLevel) -\u003e Self {\r\n        match level {\r\n            SecurityLevel::Bit128 =\u003e Self::standard_128bit(),\r\n            SecurityLevel::Bit192 =\u003e Self::standard_192bit(),\r\n            SecurityLevel::Bit256 =\u003e Self::standard_256bit(),\r\n        }\r\n    }\r\n\r\n    /// Standard 128-bit security parameters\r\n    fn standard_128bit() -\u003e Self {\r\n        ParameterSet {\r\n            security_level: SecurityLevel::Bit128,\r\n            n: 512,\r\n            q: 12289,\r\n            sigma: 3.2,\r\n            proof_size: 8_192,\r\n            prove_time_ms: 80,\r\n            verify_time_ms: 40,\r\n        }\r\n    }\r\n\r\n    /// Standard 192-bit security parameters\r\n    fn standard_192bit() -\u003e Self {\r\n        ParameterSet {\r\n            security_level: SecurityLevel::Bit192,\r\n            n: 1024,\r\n            q: 40961,\r\n            sigma: 3.2,\r\n            proof_size: 16_384,\r\n            prove_time_ms: 150,\r\n            verify_time_ms: 75,\r\n        }\r\n    }\r\n\r\n    /// Standard 256-bit security parameters\r\n    fn standard_256bit() -\u003e Self {\r\n        ParameterSet {\r\n            security_level: SecurityLevel::Bit256,\r\n            n: 2048,\r\n            q: 65537,\r\n            sigma: 3.2,\r\n            proof_size: 32_768,\r\n            prove_time_ms: 300,\r\n            verify_time_ms: 150,\r\n        }\r\n    }\r\n\r\n    /// Validate parameter set\r\n    pub fn validate(\u0026self) -\u003e CryptoResult\u003c()\u003e {\r\n        if !self.n.is_power_of_two() {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Dimension must be power of 2\".to_string(),\r\n            ));\r\n        }\r\n        if self.q \u003c 2 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Modulus must be at least 2\".to_string(),\r\n            ));\r\n        }\r\n        if self.sigma \u003c= 0.0 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Sigma must be positive\".to_string(),\r\n            ));\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n/// Cryptographic parameters for the proof system\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct CryptoParameters {\r\n    /// Security level\r\n    pub security_level: SecurityLevel,\r\n    /// Ring-LWE parameters\r\n    pub ring_params: RingLWEParameters,\r\n}\r\n\r\nimpl CryptoParameters {\r\n    /// Create parameters from security level\r\n    pub fn from_security_level(level: SecurityLevel) -\u003e Self {\r\n        let param_set = ParameterSet::from_security_level(level);\r\n        let ring_params = RingLWEParameters::new(param_set.n, param_set.q, param_set.sigma);\r\n\r\n        Self {\r\n            security_level: level,\r\n            ring_params,\r\n        }\r\n    }\r\n\r\n    /// Standard 128-bit security\r\n    pub fn new_128bit_security() -\u003e Self {\r\n        Self::from_security_level(SecurityLevel::Bit128)\r\n    }\r\n\r\n    /// Standard 192-bit security\r\n    pub fn new_192bit_security() -\u003e Self {\r\n        Self::from_security_level(SecurityLevel::Bit192)\r\n    }\r\n\r\n    /// Standard 256-bit security\r\n    pub fn new_256bit_security() -\u003e Self {\r\n        Self::from_security_level(SecurityLevel::Bit256)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::LatticeParameters;\r\n\r\n    #[test]\r\n    fn test_parameter_sets() {\r\n        let params_128 = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        assert!(params_128.validate().is_ok());\r\n        assert_eq!(params_128.n, 512);\r\n\r\n        let params_192 = ParameterSet::from_security_level(SecurityLevel::Bit192);\r\n        assert!(params_192.validate().is_ok());\r\n        assert_eq!(params_192.n, 1024);\r\n\r\n        let params_256 = ParameterSet::from_security_level(SecurityLevel::Bit256);\r\n        assert!(params_256.validate().is_ok());\r\n        assert_eq!(params_256.n, 2048);\r\n    }\r\n\r\n    #[test]\r\n    fn test_crypto_parameters() {\r\n        let params = CryptoParameters::new_128bit_security();\r\n        assert_eq!(params.security_level, SecurityLevel::Bit128);\r\n        assert_eq!(params.ring_params.n, 512);\r\n    }\r\n\r\n    #[test]\r\n    fn test_security_level_progression() {\r\n        // Verify increasing security levels have larger parameters\r\n        let params_128 = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        let params_192 = ParameterSet::from_security_level(SecurityLevel::Bit192);\r\n        let params_256 = ParameterSet::from_security_level(SecurityLevel::Bit256);\r\n        \r\n        // Dimension increases\r\n        assert!(params_128.n \u003c params_192.n);\r\n        assert!(params_192.n \u003c params_256.n);\r\n        \r\n        // Modulus increases\r\n        assert!(params_128.q \u003c params_192.q);\r\n        assert!(params_192.q \u003c params_256.q);\r\n        \r\n        // Performance estimates increase\r\n        assert!(params_128.prove_time_ms \u003c params_192.prove_time_ms);\r\n        assert!(params_192.prove_time_ms \u003c params_256.prove_time_ms);\r\n    }\r\n\r\n    #[test]\r\n    fn test_parameter_set_validation_edge_cases() {\r\n        // Invalid: dimension not power of 2\r\n        let mut params = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        params.n = 511;\r\n        assert!(params.validate().is_err());\r\n        \r\n        // Invalid: modulus too small\r\n        let mut params = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        params.q = 1;\r\n        assert!(params.validate().is_err());\r\n        \r\n        // Invalid: negative sigma\r\n        let mut params = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        params.sigma = -1.0;\r\n        assert!(params.validate().is_err());\r\n        \r\n        // Invalid: zero sigma\r\n        let mut params = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        params.sigma = 0.0;\r\n        assert!(params.validate().is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_all_security_levels_valid() {\r\n        for level in [SecurityLevel::Bit128, SecurityLevel::Bit192, SecurityLevel::Bit256] {\r\n            let params = ParameterSet::from_security_level(level);\r\n            assert!(params.validate().is_ok());\r\n            assert!(params.n.is_power_of_two());\r\n            assert!(params.q \u003e= 2);\r\n            assert!(params.sigma \u003e 0.0);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_crypto_parameters_all_levels() {\r\n        let p128 = CryptoParameters::new_128bit_security();\r\n        assert_eq!(p128.security_level, SecurityLevel::Bit128);\r\n        assert!(p128.ring_params.validate().is_ok());\r\n        \r\n        let p192 = CryptoParameters::new_192bit_security();\r\n        assert_eq!(p192.security_level, SecurityLevel::Bit192);\r\n        assert!(p192.ring_params.validate().is_ok());\r\n        \r\n        let p256 = CryptoParameters::new_256bit_security();\r\n        assert_eq!(p256.security_level, SecurityLevel::Bit256);\r\n        assert!(p256.ring_params.validate().is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn test_parameter_set_proof_size_estimates() {\r\n        let params_128 = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        let params_192 = ParameterSet::from_security_level(SecurityLevel::Bit192);\r\n        let params_256 = ParameterSet::from_security_level(SecurityLevel::Bit256);\r\n        \r\n        // Proof size should scale with security level\r\n        assert!(params_128.proof_size \u003c params_192.proof_size);\r\n        assert!(params_192.proof_size \u003c params_256.proof_size);\r\n        \r\n        // Proof sizes should be reasonable (not zero, not huge)\r\n        assert!(params_128.proof_size \u003e 1000);\r\n        assert!(params_256.proof_size \u003c 100_000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_parameter_set_timing_estimates() {\r\n        let params = ParameterSet::from_security_level(SecurityLevel::Bit128);\r\n        \r\n        // Verify time is positive\r\n        assert!(params.prove_time_ms \u003e 0);\r\n        assert!(params.verify_time_ms \u003e 0);\r\n        \r\n        // Verify should be faster than prove\r\n        assert!(params.verify_time_ms \u003c= params.prove_time_ms);\r\n    }\r\n}\r\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":42,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":43,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":44,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":45,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":50,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":63,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":76,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":89,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":90,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":91,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":92,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":95,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":96,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":97,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":100,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":101,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":102,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":105,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":120,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":121,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":122,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":131,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":132,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":136,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":137,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":141,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":142,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":28,"coverable":28},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","params","selector.rs"],"content":"/// Parameter Selector\r\n/// \r\n/// Provides a flexible builder pattern for selecting cryptographic parameters\r\n/// with automatic security level estimation and constraint validation.\r\n\r\nuse crate::params::security::SecurityLevel;\r\nuse crate::lattice::{LWEParameters, RingLWEParameters};\r\nuse crate::{CryptoError, CryptoResult, LatticeParameters};\r\nuse num_bigint::BigUint;\r\nuse num_traits::One;\r\nuse rand::{Rng, thread_rng};\r\n\r\n/// Builder for selecting LWE and Ring-LWE parameters\r\n/// \r\n/// # Example\r\n/// \r\n/// ```\r\n/// use nexuszero_crypto::params::selector::ParameterSelector;\r\n/// use nexuszero_crypto::params::security::SecurityLevel;\r\n/// \r\n/// let selector = ParameterSelector::new()\r\n///     .target_security(SecurityLevel::Bit128)\r\n///     .max_dimension(1024)\r\n///     .prefer_prime_modulus(true);\r\n/// \r\n/// let params = selector.build_lwe().unwrap();\r\n/// ```\r\n#[derive(Debug, Clone)]\r\npub struct ParameterSelector {\r\n    target_security: Option\u003cSecurityLevel\u003e,\r\n    min_dimension: Option\u003cusize\u003e,\r\n    max_dimension: Option\u003cusize\u003e,\r\n    min_modulus: Option\u003cu64\u003e,\r\n    max_modulus: Option\u003cu64\u003e,\r\n    prefer_prime_modulus: bool,\r\n    custom_sigma: Option\u003cf64\u003e,\r\n    custom_ratio: Option\u003cf64\u003e, // m/n ratio for LWE\r\n}\r\n\r\nimpl Default for ParameterSelector {\r\n    fn default() -\u003e Self {\r\n        Self::new()\r\n    }\r\n}\r\n\r\nimpl ParameterSelector {\r\n    /// Create a new parameter selector with default settings\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            target_security: None,\r\n            min_dimension: None,\r\n            max_dimension: None,\r\n            min_modulus: None,\r\n            max_modulus: None,\r\n            prefer_prime_modulus: false,\r\n            custom_sigma: None,\r\n            custom_ratio: None,\r\n        }\r\n    }\r\n\r\n    /// Set target security level\r\n    pub fn target_security(mut self, level: SecurityLevel) -\u003e Self {\r\n        self.target_security = Some(level);\r\n        self\r\n    }\r\n\r\n    /// Set minimum dimension\r\n    pub fn min_dimension(mut self, n: usize) -\u003e Self {\r\n        self.min_dimension = Some(n);\r\n        self\r\n    }\r\n\r\n    /// Set maximum dimension\r\n    pub fn max_dimension(mut self, n: usize) -\u003e Self {\r\n        self.max_dimension = Some(n);\r\n        self\r\n    }\r\n\r\n    /// Set minimum modulus\r\n    pub fn min_modulus(mut self, q: u64) -\u003e Self {\r\n        self.min_modulus = Some(q);\r\n        self\r\n    }\r\n\r\n    /// Set maximum modulus\r\n    pub fn max_modulus(mut self, q: u64) -\u003e Self {\r\n        self.max_modulus = Some(q);\r\n        self\r\n    }\r\n\r\n    /// Prefer prime modulus (enables Miller-Rabin testing)\r\n    pub fn prefer_prime_modulus(mut self, prefer: bool) -\u003e Self {\r\n        self.prefer_prime_modulus = prefer;\r\n        self\r\n    }\r\n\r\n    /// Set custom error standard deviation\r\n    pub fn custom_sigma(mut self, sigma: f64) -\u003e Self {\r\n        self.custom_sigma = Some(sigma);\r\n        self\r\n    }\r\n\r\n    /// Set custom m/n ratio for LWE (default 2.0)\r\n    pub fn custom_ratio(mut self, ratio: f64) -\u003e Self {\r\n        self.custom_ratio = Some(ratio);\r\n        self\r\n    }\r\n\r\n    /// Build LWE parameters based on constraints\r\n    pub fn build_lwe(self) -\u003e CryptoResult\u003cLWEParameters\u003e {\r\n        // Get target security level or default to 128-bit\r\n        let security = self.target_security.unwrap_or(SecurityLevel::Bit128);\r\n        \r\n        // Determine dimension based on security level and constraints\r\n        let n = self.select_dimension(security)?;\r\n        \r\n        // Determine m based on ratio (default 2.0)\r\n        let ratio = self.custom_ratio.unwrap_or(2.0);\r\n        let m = (n as f64 * ratio) as usize;\r\n        \r\n        // Select modulus\r\n        let q = self.select_modulus(n, security)?;\r\n        \r\n        // Select sigma based on security level\r\n        let sigma = self.custom_sigma.unwrap_or_else(|| {\r\n            match security {\r\n                SecurityLevel::Bit128 =\u003e 3.2,\r\n                SecurityLevel::Bit192 =\u003e 3.8,\r\n                SecurityLevel::Bit256 =\u003e 4.0,\r\n            }\r\n        });\r\n        \r\n        // Validate parameters\r\n        let params = LWEParameters::new(n, m, q, sigma);\r\n        params.validate()?;\r\n        \r\n        Ok(params)\r\n    }\r\n\r\n    /// Build Ring-LWE parameters based on constraints\r\n    pub fn build_ring_lwe(self) -\u003e CryptoResult\u003cRingLWEParameters\u003e {\r\n        // Get target security level or default to 128-bit\r\n        let security = self.target_security.unwrap_or(SecurityLevel::Bit128);\r\n        \r\n        // Ring-LWE requires power-of-2 dimension\r\n        let n = self.select_power_of_2_dimension(security)?;\r\n        \r\n        // Select modulus\r\n        let q = self.select_modulus(n, security)?;\r\n        \r\n        // Select sigma based on security level\r\n        let sigma = self.custom_sigma.unwrap_or_else(|| {\r\n            match security {\r\n                SecurityLevel::Bit128 =\u003e 3.2,\r\n                SecurityLevel::Bit192 =\u003e 3.8,\r\n                SecurityLevel::Bit256 =\u003e 4.0,\r\n            }\r\n        });\r\n        \r\n        // Create and validate parameters\r\n        let params = RingLWEParameters::new(n, q, sigma);\r\n        params.validate()?;\r\n        \r\n        Ok(params)\r\n    }\r\n\r\n    /// Select appropriate dimension based on security level and constraints\r\n    fn select_dimension(\u0026self, security: SecurityLevel) -\u003e CryptoResult\u003cusize\u003e {\r\n        // Standard dimensions for each security level\r\n        let standard_n = match security {\r\n            SecurityLevel::Bit128 =\u003e 256,\r\n            SecurityLevel::Bit192 =\u003e 384,\r\n            SecurityLevel::Bit256 =\u003e 512,\r\n        };\r\n        \r\n        // Apply constraints\r\n        let mut n = standard_n;\r\n        \r\n        if let Some(min_n) = self.min_dimension {\r\n            if n \u003c min_n {\r\n                n = min_n;\r\n            }\r\n        }\r\n        \r\n        if let Some(max_n) = self.max_dimension {\r\n            if n \u003e max_n {\r\n                n = max_n;\r\n            }\r\n        }\r\n        \r\n        // Validate dimension\r\n        if n \u003c 64 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Dimension too small for security\".to_string()\r\n            ));\r\n        }\r\n        \r\n        Ok(n)\r\n    }\r\n\r\n    /// Select power-of-2 dimension for Ring-LWE\r\n    fn select_power_of_2_dimension(\u0026self, security: SecurityLevel) -\u003e CryptoResult\u003cusize\u003e {\r\n        let standard_n = match security {\r\n            SecurityLevel::Bit128 =\u003e 512,\r\n            SecurityLevel::Bit192 =\u003e 1024,\r\n            SecurityLevel::Bit256 =\u003e 2048,\r\n        };\r\n        \r\n        let mut n = standard_n;\r\n        \r\n        // Apply constraints and round to nearest power of 2\r\n        if let Some(min_n) = self.min_dimension {\r\n            if n \u003c min_n {\r\n                n = min_n.next_power_of_two();\r\n            }\r\n        }\r\n        \r\n        if let Some(max_n) = self.max_dimension {\r\n            if n \u003e max_n {\r\n                // Round down to power of 2\r\n                n = (max_n as f64).log2().floor().exp2() as usize;\r\n            }\r\n        }\r\n        \r\n        // Ensure it's a power of 2\r\n        if !n.is_power_of_two() {\r\n            n = n.next_power_of_two();\r\n        }\r\n        \r\n        // Validate\r\n        if n \u003c 128 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                \"Ring-LWE dimension too small\".to_string()\r\n            ));\r\n        }\r\n        \r\n        Ok(n)\r\n    }\r\n\r\n    /// Select appropriate modulus based on dimension and security\r\n    fn select_modulus(\u0026self, n: usize, security: SecurityLevel) -\u003e CryptoResult\u003cu64\u003e {\r\n        // Standard modulus selection based on dimension\r\n        let standard_q = match security {\r\n            SecurityLevel::Bit128 =\u003e 12289,  // Small prime, good for NTT\r\n            SecurityLevel::Bit192 =\u003e 16411,  // Larger prime\r\n            SecurityLevel::Bit256 =\u003e 20483,  // Even larger prime\r\n        };\r\n        \r\n        let mut q = standard_q;\r\n        \r\n        // Apply constraints\r\n        if let Some(min_q) = self.min_modulus {\r\n            if q \u003c min_q {\r\n                q = min_q;\r\n            }\r\n        }\r\n        \r\n        if let Some(max_q) = self.max_modulus {\r\n            if q \u003e max_q {\r\n                q = max_q;\r\n            }\r\n        }\r\n        \r\n        // If prime modulus preferred, find nearest prime\r\n        if self.prefer_prime_modulus {\r\n            q = find_nearest_prime(q)?;\r\n        }\r\n        \r\n        // Validate modulus is large enough for security\r\n        // Rule: q should be at least n for basic security\r\n        if q \u003c n as u64 {\r\n            return Err(CryptoError::InvalidParameter(\r\n                format!(\"Modulus {} too small for dimension {}\", q, n)\r\n            ));\r\n        }\r\n        \r\n        Ok(q)\r\n    }\r\n\r\n    /// Estimate security level of given parameters\r\n    pub fn estimate_security(n: usize, q: u64, sigma: f64) -\u003e u32 {\r\n        // Simplified security estimation based on lattice parameters\r\n        // Based on the hardness of solving LWE with given parameters\r\n        \r\n        let log2_q = (q as f64).log2();\r\n        let log2_n = (n as f64).log2();\r\n        \r\n        // Core security estimate: dimension is the primary factor\r\n        // Each doubling of dimension roughly adds 50-80 bits of security\r\n        let dimension_security = log2_n * 60.0;\r\n        \r\n        // Modulus factor: larger modulus slightly reduces security\r\n        // but is needed for correctness\r\n        let modulus_factor = (log2_q / (log2_n + 10.0)).min(1.0);\r\n        \r\n        // Error distribution factor: larger sigma reduces security\r\n        // but smaller sigma helps security\r\n        let sigma_factor = if sigma \u003c 5.0 {\r\n            1.0 - (sigma / 20.0) // Very minor reduction\r\n        } else {\r\n            0.9 // Larger sigma has some impact\r\n        };\r\n        \r\n        // Combine factors\r\n        let bit_security = dimension_security * modulus_factor * sigma_factor;\r\n        \r\n        // Clamp to reasonable range\r\n        bit_security.max(64.0).min(512.0) as u32\r\n    }\r\n}\r\n\r\n/// Find nearest prime number to target using Miller-Rabin test\r\nfn find_nearest_prime(target: u64) -\u003e CryptoResult\u003cu64\u003e {\r\n    // Search in both directions\r\n    let max_search = 1000;\r\n    \r\n    for offset in 0..max_search {\r\n        // Try target + offset\r\n        if offset == 0 || target + offset \u003e target {\r\n            let candidate = target + offset;\r\n            if is_prime_miller_rabin(candidate, 20) {\r\n                return Ok(candidate);\r\n            }\r\n        }\r\n        \r\n        // Try target - offset\r\n        if offset \u003e 0 \u0026\u0026 target \u003e offset {\r\n            let candidate = target - offset;\r\n            if is_prime_miller_rabin(candidate, 20) {\r\n                return Ok(candidate);\r\n            }\r\n        }\r\n    }\r\n    \r\n    Err(CryptoError::InvalidParameter(\r\n        format!(\"Could not find prime near {}\", target)\r\n    ))\r\n}\r\n\r\n/// Miller-Rabin primality test\r\n/// \r\n/// Probabilistic test with error probability \u003c 4^(-k)\r\n/// where k is the number of rounds.\r\n/// \r\n/// # Arguments\r\n/// \r\n/// * `n` - Number to test for primality\r\n/// * `k` - Number of testing rounds (20 is standard for cryptographic use)\r\n/// \r\n/// # Returns\r\n/// \r\n/// `true` if n is probably prime, `false` if n is definitely composite\r\npub fn is_prime_miller_rabin(n: u64, k: u32) -\u003e bool {\r\n    // Handle small cases\r\n    if n \u003c 2 {\r\n        return false;\r\n    }\r\n    if n == 2 || n == 3 {\r\n        return true;\r\n    }\r\n    if n % 2 == 0 {\r\n        return false;\r\n    }\r\n    \r\n    // Write n-1 as 2^r * d\r\n    let mut d = n - 1;\r\n    let mut r = 0;\r\n    while d % 2 == 0 {\r\n        d /= 2;\r\n        r += 1;\r\n    }\r\n    \r\n    let n_big = BigUint::from(n);\r\n    let mut rng = thread_rng();\r\n    \r\n    'witness: for _ in 0..k {\r\n        // Pick random witness a in [2, n-2]\r\n        let a = rng.gen_range(2..n-1);\r\n        let a_big = BigUint::from(a);\r\n        \r\n        // Compute x = a^d mod n\r\n        let mut x = a_big.modpow(\u0026BigUint::from(d), \u0026n_big);\r\n        \r\n        if x == One::one() || x == \u0026n_big - BigUint::one() {\r\n            continue 'witness;\r\n        }\r\n        \r\n        for _ in 0..r-1 {\r\n            // x = x^2 mod n\r\n            x = (\u0026x * \u0026x) % \u0026n_big;\r\n            \r\n            if x == \u0026n_big - BigUint::one() {\r\n                continue 'witness;\r\n            }\r\n        }\r\n        \r\n        // n is definitely composite\r\n        return false;\r\n    }\r\n    \r\n    // n is probably prime\r\n    true\r\n}\r\n\r\n/// Generate cryptographically strong prime\r\n/// \r\n/// Generates a prime number suitable for cryptographic use\r\n/// with specified bit length.\r\npub fn generate_prime(bit_length: u32) -\u003e CryptoResult\u003cu64\u003e {\r\n    if bit_length \u003e 63 {\r\n        return Err(CryptoError::InvalidParameter(\r\n            \"Bit length too large for u64\".to_string()\r\n        ));\r\n    }\r\n    \r\n    let mut rng = thread_rng();\r\n    let max_attempts = 10000;\r\n    \r\n    for _ in 0..max_attempts {\r\n        // Generate random odd number of specified bit length\r\n        let min = 1u64 \u003c\u003c (bit_length - 1);\r\n        let max = (1u64 \u003c\u003c bit_length) - 1;\r\n        let mut candidate = rng.gen_range(min..=max);\r\n        \r\n        // Make it odd\r\n        candidate |= 1;\r\n        \r\n        // Test primality\r\n        if is_prime_miller_rabin(candidate, 20) {\r\n            return Ok(candidate);\r\n        }\r\n    }\r\n    \r\n    Err(CryptoError::InvalidParameter(\r\n        \"Could not generate prime\".to_string()\r\n    ))\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_miller_rabin_known_primes() {\r\n        // Small primes\r\n        assert!(is_prime_miller_rabin(2, 20));\r\n        assert!(is_prime_miller_rabin(3, 20));\r\n        assert!(is_prime_miller_rabin(5, 20));\r\n        assert!(is_prime_miller_rabin(7, 20));\r\n        assert!(is_prime_miller_rabin(11, 20));\r\n        assert!(is_prime_miller_rabin(13, 20));\r\n        \r\n        // Larger primes\r\n        assert!(is_prime_miller_rabin(97, 20));\r\n        assert!(is_prime_miller_rabin(541, 20));\r\n        assert!(is_prime_miller_rabin(7919, 20));\r\n        assert!(is_prime_miller_rabin(12289, 20)); // Common in lattice crypto\r\n    }\r\n\r\n    #[test]\r\n    fn test_miller_rabin_known_composites() {\r\n        assert!(!is_prime_miller_rabin(0, 20));\r\n        assert!(!is_prime_miller_rabin(1, 20));\r\n        assert!(!is_prime_miller_rabin(4, 20));\r\n        assert!(!is_prime_miller_rabin(6, 20));\r\n        assert!(!is_prime_miller_rabin(8, 20));\r\n        assert!(!is_prime_miller_rabin(9, 20));\r\n        assert!(!is_prime_miller_rabin(100, 20));\r\n        assert!(!is_prime_miller_rabin(1000, 20));\r\n    }\r\n\r\n    #[test]\r\n    fn test_parameter_selector_lwe() {\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128);\r\n        \r\n        let params = selector.build_lwe().unwrap();\r\n        \r\n        assert_eq!(params.n, 256);\r\n        assert_eq!(params.m, 512);\r\n        assert!(params.q \u003e 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_parameter_selector_ring_lwe() {\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128);\r\n        \r\n        let params = selector.build_ring_lwe().unwrap();\r\n        \r\n        assert_eq!(params.n, 512);\r\n        assert!(params.n.is_power_of_two());\r\n        assert!(params.q \u003e 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_parameter_selector_with_constraints() {\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .min_dimension(512)\r\n            .max_dimension(1024)\r\n            .prefer_prime_modulus(true);\r\n        \r\n        let params = selector.build_lwe().unwrap();\r\n        \r\n        assert!(params.n \u003e= 512);\r\n        assert!(params.n \u003c= 1024);\r\n        assert!(is_prime_miller_rabin(params.q, 20));\r\n    }\r\n\r\n    #[test]\r\n    fn test_security_estimation() {\r\n        // 128-bit security parameters\r\n        let security = ParameterSelector::estimate_security(256, 12289, 3.2);\r\n        assert!(security \u003e= 100, \"Security should be reasonable: {}\", security);\r\n        \r\n        // 192-bit security parameters\r\n        let security = ParameterSelector::estimate_security(384, 16411, 3.8);\r\n        assert!(security \u003e= 100, \"Security should be reasonable: {}\", security);\r\n        \r\n        // 256-bit security parameters\r\n        let security = ParameterSelector::estimate_security(512, 20483, 4.0);\r\n        assert!(security \u003e= 100, \"Security should be reasonable: {}\", security);\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_nearest_prime() {\r\n        // Find prime near 12289 (which is already prime)\r\n        let prime = find_nearest_prime(12289).unwrap();\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n        \r\n        // Find prime near 12000 (not prime)\r\n        let prime = find_nearest_prime(12000).unwrap();\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n        assert!((prime as i64 - 12000).abs() \u003c 1000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_generate_prime() {\r\n        let prime = generate_prime(14).unwrap();\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n        assert!(prime \u003e= 8192 \u0026\u0026 prime \u003c 16384); // 2^13 to 2^14\r\n    }\r\n\r\n    #[test]\r\n    fn test_power_of_2_dimension() {\r\n        let selector = ParameterSelector::new()\r\n            .min_dimension(500)\r\n            .max_dimension(1500);\r\n        \r\n        let n = selector.select_power_of_2_dimension(SecurityLevel::Bit128).unwrap();\r\n        assert!(n.is_power_of_two());\r\n        assert!(n \u003e= 512); // Next power of 2 after min\r\n        assert!(n \u003c= 1024); // Power of 2 within max\r\n    }\r\n\r\n    #[test]\r\n    fn test_selector_extreme_dimension_constraints() {\r\n        // Very small min dimension\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .min_dimension(10)\r\n            .max_dimension(300);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!(params.n \u003e= 10 \u0026\u0026 params.n \u003c= 300);\r\n        \r\n        // Very large max dimension\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .min_dimension(256)\r\n            .max_dimension(10000);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!(params.n \u003e= 256 \u0026\u0026 params.n \u003c= 10000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_selector_conflicting_constraints() {\r\n        // Min \u003e Max should fail or auto-correct\r\n        let selector = ParameterSelector::new()\r\n            .min_dimension(1024)\r\n            .max_dimension(512);\r\n        \r\n        // This should either error or auto-swap\r\n        let result = selector.build_lwe();\r\n        // If it succeeds, dimension should be reasonable\r\n        if let Ok(params) = result {\r\n            assert!(params.n \u003e 0);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_selector_boundary_modulus() {\r\n        // Very small modulus constraint\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .min_modulus(100)\r\n            .max_modulus(500);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!(params.q \u003e= 100 \u0026\u0026 params.q \u003c= 500);\r\n        \r\n        // Very large modulus constraint\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .min_modulus(50000)\r\n            .max_modulus(100000);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!(params.q \u003e= 50000 \u0026\u0026 params.q \u003c= 100000);\r\n    }\r\n\r\n    #[test]\r\n    fn test_selector_custom_ratio_extremes() {\r\n        // Very small ratio (m barely larger than n)\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .custom_ratio(1.1);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!((params.m as f64 / params.n as f64) \u003e= 1.0);\r\n        assert!((params.m as f64 / params.n as f64) \u003c 1.5);\r\n        \r\n        // Large ratio (m much larger than n)\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .custom_ratio(10.0);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!((params.m as f64 / params.n as f64) \u003e= 9.0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_selector_custom_sigma_extremes() {\r\n        // Very small sigma\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .custom_sigma(0.5);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!((params.sigma - 0.5).abs() \u003c 0.01);\r\n        \r\n        // Large sigma\r\n        let selector = ParameterSelector::new()\r\n            .target_security(SecurityLevel::Bit128)\r\n            .custom_sigma(10.0);\r\n        let params = selector.build_lwe().unwrap();\r\n        assert!((params.sigma - 10.0).abs() \u003c 0.01);\r\n    }\r\n\r\n    #[test]\r\n    fn test_prime_generation_edge_cases() {\r\n        // Small bit size\r\n        let prime = generate_prime(4).unwrap();\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n        assert!(prime \u003e= 8 \u0026\u0026 prime \u003c 16);\r\n        \r\n        // Larger bit size\r\n        let prime = generate_prime(20).unwrap();\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n        assert!(prime \u003e= (1 \u003c\u003c 19) \u0026\u0026 prime \u003c (1 \u003c\u003c 20));\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_nearest_prime_boundary_cases() {\r\n        // Near lower bound\r\n        let prime = find_nearest_prime(100).unwrap();\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n        \r\n        // Even number (should find odd prime)\r\n        let prime = find_nearest_prime(1000).unwrap();\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n        assert!(prime % 2 == 1 || prime == 2);\r\n        \r\n        // Already prime\r\n        let prime = find_nearest_prime(7919).unwrap();\r\n        assert_eq!(prime, 7919);\r\n        assert!(is_prime_miller_rabin(prime, 20));\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_power_of_2_enforcement() {\r\n        // Request non-power-of-2 via constraints, should get next power of 2\r\n        let selector = ParameterSelector::new()\r\n            .min_dimension(300)\r\n            .max_dimension(600);\r\n        let params = selector.build_ring_lwe().unwrap();\r\n        assert!(params.n.is_power_of_two());\r\n        assert!(params.n \u003e= 512); // Next power of 2 \u003e= 300\r\n    }\r\n\r\n        #[test]\r\n        fn test_dimension_too_small_error() {\r\n            // Test that dimensions below security threshold fail\r\n            let selector = ParameterSelector::new()\r\n                .max_dimension(32); // Below minimum 64\r\n        \r\n            let result = selector.build_lwe();\r\n            assert!(result.is_err());\r\n        }\r\n\r\n        #[test]\r\n        fn test_ring_lwe_dimension_too_small_error() {\r\n            // Ring-LWE requires min 128\r\n            let selector = ParameterSelector::new()\r\n                .max_dimension(64); // Below Ring-LWE minimum\r\n        \r\n            let result = selector.build_ring_lwe();\r\n            assert!(result.is_err());\r\n        }\r\n\r\n        #[test]\r\n        fn test_modulus_smaller_than_dimension_error() {\r\n            // Modulus must be at least as large as dimension\r\n            let selector = ParameterSelector::new()\r\n                .min_dimension(1000)\r\n                .max_modulus(500); // q \u003c n\r\n        \r\n            let result = selector.build_lwe();\r\n            assert!(result.is_err());\r\n        }\r\n\r\n        #[test]\r\n        fn test_generate_prime_bit_length_too_large() {\r\n            // Test that requesting 64+ bit primes fails\r\n            let result = generate_prime(64);\r\n            assert!(result.is_err());\r\n        \r\n            let result = generate_prime(100);\r\n            assert!(result.is_err());\r\n        }\r\n\r\n        #[test]\r\n        fn test_find_prime_extreme_range() {\r\n            // Test finding prime in challenging ranges\r\n            let prime = find_nearest_prime(2).unwrap();\r\n            assert_eq!(prime, 2);\r\n        \r\n            let prime = find_nearest_prime(3).unwrap();\r\n            assert_eq!(prime, 3);\r\n        \r\n            // Large number\r\n            let prime = find_nearest_prime(65000).unwrap();\r\n            assert!(is_prime_miller_rabin(prime, 20));\r\n            assert!((prime as i64 - 65000).abs() \u003c 1000);\r\n        }\r\n\r\n        #[test]\r\n        fn test_security_estimation_edge_cases() {\r\n            // Very small parameters\r\n            let security = ParameterSelector::estimate_security(64, 100, 1.0);\r\n            assert!(security \u003e= 64); // Should clamp to minimum\r\n        \r\n            // Very large parameters\r\n            let security = ParameterSelector::estimate_security(8192, 100000, 2.0);\r\n            assert!(security \u003c= 512); // Should clamp to maximum\r\n        \r\n            // Large sigma impact\r\n            let security = ParameterSelector::estimate_security(256, 12289, 10.0);\r\n            assert!(security \u003e 0);\r\n        }\r\n\r\n        #[test]\r\n        fn test_selector_all_security_levels() {\r\n            // Test each security level produces valid parameters\r\n            for level in [SecurityLevel::Bit128, SecurityLevel::Bit192, SecurityLevel::Bit256] {\r\n                let selector = ParameterSelector::new().target_security(level);\r\n            \r\n                let lwe_params = selector.clone().build_lwe().unwrap();\r\n                assert!(lwe_params.validate().is_ok());\r\n            \r\n                let ring_params = selector.build_ring_lwe().unwrap();\r\n                assert!(ring_params.validate().is_ok());\r\n            }\r\n        }\r\n\r\n        #[test]\r\n        fn test_selector_with_all_constraints() {\r\n            // Test with maximum constraints specified\r\n            let selector = ParameterSelector::new()\r\n                .target_security(SecurityLevel::Bit192)\r\n                .min_dimension(256)\r\n                .max_dimension(512)\r\n                .min_modulus(10000)\r\n                .max_modulus(20000)\r\n                .prefer_prime_modulus(true)\r\n                .custom_sigma(3.5)\r\n                .custom_ratio(1.5);\r\n        \r\n            let params = selector.build_lwe().unwrap();\r\n            assert!(params.n \u003e= 256 \u0026\u0026 params.n \u003c= 512);\r\n            assert!(params.q \u003e= 10000 \u0026\u0026 params.q \u003c= 20000);\r\n            assert!(is_prime_miller_rabin(params.q, 20));\r\n            assert!((params.sigma - 3.5).abs() \u003c 0.01);\r\n        }\r\n\r\n        #[test]\r\n        fn test_power_of_2_rounding_down() {\r\n            // Test that max_dimension rounds down to power of 2\r\n            let selector = ParameterSelector::new()\r\n                .max_dimension(1500); // Should round down to 1024\r\n        \r\n            let n = selector.select_power_of_2_dimension(SecurityLevel::Bit192).unwrap();\r\n            assert_eq!(n, 1024);\r\n            assert!(n.is_power_of_two());\r\n        }\r\n\r\n        #[test]\r\n        fn test_power_of_2_rounding_up() {\r\n            // Test that min_dimension rounds up to power of 2\r\n            let selector = ParameterSelector::new()\r\n                .min_dimension(700) // Should round up to 1024\r\n                .max_dimension(2000);\r\n        \r\n            let n = selector.select_power_of_2_dimension(SecurityLevel::Bit192).unwrap();\r\n            assert_eq!(n, 1024);\r\n            assert!(n.is_power_of_two());\r\n        }\r\n}\r\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":62,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":63,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":64,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":68,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":69,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":70,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":74,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":75,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":76,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":80,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":81,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":82,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":86,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":87,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":88,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":92,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":93,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":94,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":98,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":99,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":100,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":104,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":105,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":106,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":110,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":112,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":115,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":118,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":119,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":122,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":125,"address":[],"length":0,"stats":{"Line":3026418949593244447}},{"line":126,"address":[],"length":0,"stats":{"Line":648518346341622559}},{"line":127,"address":[],"length":0,"stats":{"Line":648518346341622559}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":135,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":137,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":141,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":143,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":146,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":149,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":152,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":153,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":154,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":162,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":164,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":168,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":170,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":171,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":179,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":180,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":181,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":185,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":186,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":187,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":192,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":202,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":203,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":204,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":212,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":213,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":219,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":241,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":243,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":244,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":252,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":253,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":254,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":258,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":259,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":260,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":265,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":266,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":271,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":281,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":285,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":286,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":290,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":294,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":298,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":299,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":308,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":313,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":315,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":317,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":319,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":320,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":321,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":322,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":327,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":328,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":329,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":330,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":355,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":356,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":358,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":359,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":361,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":362,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":366,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":367,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":368,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":369,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":370,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":373,"address":[],"length":0,"stats":{"Line":8214565720323784704}},{"line":374,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":376,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":378,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":379,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":382,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":384,"address":[],"length":0,"stats":{"Line":1441151880758558718}},{"line":385,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":388,"address":[],"length":0,"stats":{"Line":9223372036854775807}},{"line":390,"address":[],"length":0,"stats":{"Line":6196953087261802500}},{"line":392,"address":[],"length":0,"stats":{"Line":6196953087261802500}},{"line":393,"address":[],"length":0,"stats":{"Line":9223372036854775807}},{"line":398,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":402,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":409,"address":[],"length":0,"stats":{"Line":216172782113783813}},{"line":410,"address":[],"length":0,"stats":{"Line":216172782113783813}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":432345564227567626}},{"line":417,"address":[],"length":0,"stats":{"Line":432345564227567626}},{"line":419,"address":[],"length":0,"stats":{"Line":216172782113783813}},{"line":421,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":422,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":423,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":426,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":429,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":430,"address":[],"length":0,"stats":{"Line":216172782113783813}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}}],"covered":141,"coverable":169},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","proof","mod.rs"],"content":"//! Zero-knowledge proof system components\r\n//!\r\n//! This module provides Statement, Witness, and Proof structures\r\n//! for constructing zero-knowledge proofs.\r\n\r\npub mod proof;\r\npub mod statement;\r\npub mod witness;\r\n\r\n// Re-export main types\r\npub use proof::{Proof, ProofMetadata};\r\npub use statement::{Statement, StatementBuilder, StatementType};\r\npub use witness::{Witness, WitnessType};\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","proof","proof.rs"],"content":"//! Proof generation and verification\r\n//!\r\n//! This module implements the core prove/verify algorithms.\r\n\r\nuse crate::proof::{Statement, Witness};\r\nuse crate::{CryptoError, CryptoResult};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// A zero-knowledge proof\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct Proof {\r\n    /// Commitment phase values\r\n    pub commitments: Vec\u003cCommitment\u003e,\r\n    /// Challenge from Fiat-Shamir transform\r\n    pub challenge: Challenge,\r\n    /// Response phase values\r\n    pub responses: Vec\u003cResponse\u003e,\r\n    /// Proof metadata\r\n    pub metadata: ProofMetadata,\r\n}\r\n\r\n/// Commitment in the proof\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct Commitment {\r\n    /// Commitment value\r\n    pub value: Vec\u003cu8\u003e,\r\n}\r\n\r\n/// Challenge value\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct Challenge {\r\n    /// Challenge bytes\r\n    pub value: [u8; 32],\r\n}\r\n\r\n/// Response in the proof\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct Response {\r\n    /// Response value\r\n    pub value: Vec\u003cu8\u003e,\r\n}\r\n\r\n/// Proof metadata\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct ProofMetadata {\r\n    /// Proof system version\r\n    pub version: u8,\r\n    /// Timestamp of generation\r\n    pub timestamp: u64,\r\n    /// Size in bytes\r\n    pub size: usize,\r\n}\r\n\r\nimpl Proof {\r\n    /// Validate proof structure\r\n    pub fn validate(\u0026self) -\u003e CryptoResult\u003c()\u003e {\r\n        if self.commitments.is_empty() {\r\n            return Err(CryptoError::ProofError(\"No commitments\".to_string()));\r\n        }\r\n        if self.responses.is_empty() {\r\n            return Err(CryptoError::ProofError(\"No responses\".to_string()));\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    /// Serialize proof to bytes\r\n    pub fn to_bytes(\u0026self) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\r\n        bincode::serialize(self).map_err(|e| {\r\n            CryptoError::SerializationError(format!(\"Failed to serialize proof: {}\", e))\r\n        })\r\n    }\r\n\r\n    /// Deserialize proof from bytes\r\n    pub fn from_bytes(bytes: \u0026[u8]) -\u003e CryptoResult\u003cSelf\u003e {\r\n        bincode::deserialize(bytes).map_err(|e| {\r\n            CryptoError::SerializationError(format!(\"Failed to deserialize proof: {}\", e))\r\n        })\r\n    }\r\n\r\n    /// Get proof size\r\n    pub fn size(\u0026self) -\u003e usize {\r\n        self.metadata.size\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions\r\n// ============================================================================\r\n\r\nuse rand::Rng;\r\nuse num_bigint::BigUint;\r\nuse crate::proof::statement::{HashFunction, StatementType};\r\n\r\n/// Generate random blinding factors for commitments\r\nfn generate_blinding_factors(count: usize, size: usize) -\u003e Vec\u003cVec\u003cu8\u003e\u003e {\r\n    let mut rng = rand::thread_rng();\r\n    (0..count)\r\n        .map(|_| (0..size).map(|_| rng.gen::\u003cu8\u003e()).collect())\r\n        .collect()\r\n}\r\n\r\n/// Convert challenge to scalar for arithmetic\r\nfn challenge_to_bigint(challenge: \u0026[u8; 32]) -\u003e BigUint {\r\n    BigUint::from_bytes_be(challenge)\r\n}\r\n\r\n/// Modular addition: (a + b) mod m, padded to 32 bytes\r\nfn add_mod(a: \u0026[u8], b: \u0026[u8], modulus: \u0026BigUint) -\u003e Vec\u003cu8\u003e {\r\n    let a_big = BigUint::from_bytes_be(a);\r\n    let b_big = BigUint::from_bytes_be(b);\r\n    let result = (a_big + b_big) % modulus;\r\n    let mut bytes = result.to_bytes_be();\r\n    \r\n    // Pad to 32 bytes if needed\r\n    while bytes.len() \u003c 32 {\r\n        bytes.insert(0, 0);\r\n    }\r\n    bytes\r\n}\r\n\r\n/// Modular multiplication: (a * b) mod m, padded to 32 bytes\r\nfn mul_mod(a: \u0026BigUint, b: \u0026[u8], modulus: \u0026BigUint) -\u003e Vec\u003cu8\u003e {\r\n    let b_big = BigUint::from_bytes_be(b);\r\n    let result = (a * b_big) % modulus;\r\n    let mut bytes = result.to_bytes_be();\r\n    \r\n    // Pad to 32 bytes if needed\r\n    while bytes.len() \u003c 32 {\r\n        bytes.insert(0, 0);\r\n    }\r\n    bytes\r\n}\r\n\r\n/// Modular exponentiation: base^exp mod modulus\r\nfn mod_exp(base: \u0026[u8], exp: \u0026[u8], modulus: \u0026[u8]) -\u003e Vec\u003cu8\u003e {\r\n    let base_big = BigUint::from_bytes_be(base);\r\n    let exp_big = BigUint::from_bytes_be(exp);\r\n    let mod_big = BigUint::from_bytes_be(modulus);\r\n    \r\n    let result = base_big.modpow(\u0026exp_big, \u0026mod_big);\r\n    result.to_bytes_be()\r\n}\r\n\r\n/// Get current Unix timestamp\r\nfn current_timestamp() -\u003e u64 {\r\n    use std::time::{SystemTime, UNIX_EPOCH};\r\n    SystemTime::now()\r\n        .duration_since(UNIX_EPOCH)\r\n        .unwrap_or_default()\r\n        .as_secs()\r\n}\r\n\r\n// ============================================================================\r\n// Commitment Phase Functions\r\n// ============================================================================\r\n\r\n/// Commit for discrete log proof: t = g^r\r\nfn commit_discrete_log(generator: \u0026[u8], blinding: \u0026[u8]) -\u003e CryptoResult\u003cCommitment\u003e {\r\n    // Use a simple modulus for demonstration (in production, use proper group)\r\n    let modulus_bytes = vec![0xFF; 32]; // 2^256 - 1 approximation\r\n    \r\n    let t = mod_exp(generator, blinding, \u0026modulus_bytes);\r\n    \r\n    Ok(Commitment { value: t })\r\n}\r\n\r\n/// Commit for preimage proof: commitment to randomness\r\nfn commit_preimage(blinding: \u0026[u8]) -\u003e CryptoResult\u003cCommitment\u003e {\r\n    use sha3::{Digest, Sha3_256};\r\n    \r\n    // Commit to blinding factor\r\n    let mut hasher = Sha3_256::new();\r\n    hasher.update(blinding);\r\n    let commitment = hasher.finalize().to_vec();\r\n    \r\n    Ok(Commitment { value: commitment })\r\n}\r\n\r\n// ============================================================================\r\n// Response Phase Functions\r\n// ============================================================================\r\n\r\n/// Compute response for discrete log: s = r + c*x (no modulus, let it be large)\r\nfn compute_discrete_log_response(\r\n    secret: \u0026[u8],\r\n    blinding: \u0026[u8],\r\n    challenge: \u0026[u8; 32],\r\n) -\u003e CryptoResult\u003cResponse\u003e {\r\n    let c = challenge_to_bigint(challenge);\r\n    let r = BigUint::from_bytes_be(blinding);\r\n    let x = BigUint::from_bytes_be(secret);\r\n    \r\n    // s = r + c*x (no modular reduction - let response be arbitrary size)\r\n    let s = r + (c * x);\r\n    \r\n    Ok(Response { value: s.to_bytes_be() })\r\n}\r\n\r\n/// Compute response for preimage: reveal blinding XOR challenge\r\nfn compute_preimage_response(\r\n    blinding: \u0026[u8],\r\n    challenge: \u0026[u8; 32],\r\n) -\u003e CryptoResult\u003cResponse\u003e {\r\n    // Simple response: blinding XOR first bytes of challenge\r\n    let mut response = blinding.to_vec();\r\n    for (i, byte) in response.iter_mut().enumerate() {\r\n        if i \u003c challenge.len() {\r\n            *byte ^= challenge[i];\r\n        }\r\n    }\r\n    \r\n    Ok(Response { value: response })\r\n}\r\n\r\n// ============================================================================\r\n// Verification Functions\r\n// ============================================================================\r\n\r\n/// Verify discrete log proof: check g^s = t * h^c\r\nfn verify_discrete_log_proof(\r\n    generator: \u0026[u8],\r\n    public_value: \u0026[u8],\r\n    commitment: \u0026Commitment,\r\n    challenge: \u0026Challenge,\r\n    response: \u0026Response,\r\n) -\u003e CryptoResult\u003c()\u003e {\r\n    let modulus_bytes = vec![0xFF; 32];\r\n    let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n    \r\n    // Compute g^s (mod p)\r\n    let gs_big = {\r\n        let gen_big = BigUint::from_bytes_be(generator);\r\n        let response_big = BigUint::from_bytes_be(\u0026response.value);\r\n        gen_big.modpow(\u0026response_big, \u0026mod_big)\r\n    };\r\n    \r\n    // Compute h^c (mod p)\r\n    let hc_big = {\r\n        let h_big = BigUint::from_bytes_be(public_value);\r\n        let c_big = BigUint::from_bytes_be(\u0026challenge.value);\r\n        h_big.modpow(\u0026c_big, \u0026mod_big)\r\n    };\r\n    \r\n    // Compute t * h^c (mod p)\r\n    let right_side = {\r\n        let t_big = BigUint::from_bytes_be(\u0026commitment.value);\r\n        (t_big * hc_big) % \u0026mod_big\r\n    };\r\n    \r\n    // Verify g^s = t * h^c (mod p)\r\n    if gs_big == right_side {\r\n        Ok(())\r\n    } else {\r\n        Err(CryptoError::VerificationError(\r\n            \"Discrete log proof verification failed\".to_string(),\r\n        ))\r\n    }\r\n}\r\n\r\n/// Verify preimage proof\r\nfn verify_preimage_proof(\r\n    hash_function: \u0026HashFunction,\r\n    hash_output: \u0026[u8],\r\n    commitment: \u0026Commitment,\r\n    challenge: \u0026Challenge,\r\n    response: \u0026Response,\r\n) -\u003e CryptoResult\u003c()\u003e {\r\n    use sha3::{Digest, Sha3_256};\r\n    use sha2::Sha256;\r\n    \r\n    // Recompute blinding from response XOR challenge\r\n    let mut blinding = response.value.clone();\r\n    for (i, byte) in blinding.iter_mut().enumerate() {\r\n        if i \u003c challenge.value.len() {\r\n            *byte ^= challenge.value[i];\r\n        }\r\n    }\r\n    \r\n    // Verify commitment matches\r\n    let recomputed_commitment = match hash_function {\r\n        HashFunction::SHA3_256 =\u003e {\r\n            let mut hasher = Sha3_256::new();\r\n            hasher.update(\u0026blinding);\r\n            hasher.finalize().to_vec()\r\n        }\r\n        HashFunction::SHA256 =\u003e {\r\n            let mut hasher = Sha256::new();\r\n            hasher.update(\u0026blinding);\r\n            hasher.finalize().to_vec()\r\n        }\r\n        HashFunction::Blake3 =\u003e {\r\n            // Blake3 not yet implemented\r\n            return Err(CryptoError::VerificationError(\r\n                \"Blake3 hash function not yet supported\".to_string(),\r\n            ));\r\n        }\r\n    };\r\n    \r\n    if recomputed_commitment != commitment.value {\r\n        return Err(CryptoError::VerificationError(\r\n            \"Preimage commitment verification failed\".to_string(),\r\n        ));\r\n    }\r\n    \r\n    // Note: In a real preimage proof, we'd verify the actual preimage\r\n    // This is a simplified version showing the structure\r\n    \r\n    // Verify hash output matches (in real implementation, witness would be revealed selectively)\r\n    if hash_output.is_empty() {\r\n        return Err(CryptoError::VerificationError(\r\n            \"Invalid hash output\".to_string(),\r\n        ));\r\n    }\r\n    \r\n    Ok(())\r\n}\r\n\r\n// ============================================================================\r\n// Main Proof Generation Function\r\n// ============================================================================\r\n\r\n/// Generate a zero-knowledge proof\r\n/// \r\n/// # Arguments\r\n/// * `statement` - The public statement being proven\r\n/// * `witness` - The secret knowledge (NOT transmitted)\r\n/// \r\n/// # Returns\r\n/// A proof that can be publicly verified\r\n/// \r\n/// # Implementation\r\n/// Uses Schnorr-style protocol with Fiat-Shamir transform:\r\n/// 1. Commitment: Generate random blinding factors\r\n/// 2. Challenge: Hash statement + commitments (Fiat-Shamir)\r\n/// 3. Response: Combine witness, blinding, and challenge\r\npub fn prove(statement: \u0026Statement, witness: \u0026Witness) -\u003e CryptoResult\u003cProof\u003e {\r\n    // PHASE 1: Validate inputs\r\n    if !witness.satisfies_statement(statement) {\r\n        return Err(CryptoError::ProofError(\r\n            \"Witness does not satisfy statement\".to_string(),\r\n        ));\r\n    }\r\n    \r\n    // PHASE 2: Commitment Phase\r\n    // Generate random blinding factors (must be kept for response phase)\r\n    let blinding = generate_blinding_factors(1, 32);\r\n    \r\n    let commitments = match \u0026statement.statement_type {\r\n        StatementType::DiscreteLog { generator, .. } =\u003e {\r\n            vec![commit_discrete_log(generator, \u0026blinding[0])?]\r\n        }\r\n        StatementType::Preimage { .. } =\u003e {\r\n            vec![commit_preimage(\u0026blinding[0])?]\r\n        }\r\n        StatementType::Range { .. } =\u003e {\r\n            // For range proofs, we'd need Bulletproofs or similar\r\n            // This is a placeholder\r\n            return Err(CryptoError::ProofError(\r\n                \"Range proofs not yet fully implemented\".to_string(),\r\n            ));\r\n        }\r\n        StatementType::Custom { .. } =\u003e {\r\n            return Err(CryptoError::ProofError(\r\n                \"Custom statements not yet supported\".to_string(),\r\n            ));\r\n        }\r\n    };\r\n    \r\n    // PHASE 3: Challenge Phase (Fiat-Shamir)\r\n    let challenge = compute_challenge(statement, \u0026commitments)?;\r\n    \r\n    // PHASE 4: Response Phase\r\n    // Use the SAME blinding factors from commitment phase\r\n    let responses = match \u0026statement.statement_type {\r\n        StatementType::DiscreteLog { .. } =\u003e {\r\n            // Get secret from witness\r\n            let secret = witness.get_secret_bytes()\r\n                .map_err(|e| CryptoError::ProofError(e.to_string()))?;\r\n            vec![compute_discrete_log_response(\u0026secret, \u0026blinding[0], \u0026challenge.value)?]\r\n        }\r\n        StatementType::Preimage { .. } =\u003e {\r\n            vec![compute_preimage_response(\u0026blinding[0], \u0026challenge.value)?]\r\n        }\r\n        _ =\u003e {\r\n            return Err(CryptoError::ProofError(\r\n                \"Unsupported statement type\".to_string(),\r\n            ));\r\n        }\r\n    };\r\n    \r\n    // PHASE 5: Package proof\r\n    let proof_bytes = bincode::serialize(\u0026(\u0026commitments, \u0026challenge, \u0026responses))\r\n        .map_err(|e| CryptoError::SerializationError(e.to_string()))?;\r\n    \r\n    let metadata = ProofMetadata {\r\n        version: 1,\r\n        timestamp: current_timestamp(),\r\n        size: proof_bytes.len(),\r\n    };\r\n    \r\n    Ok(Proof {\r\n        commitments,\r\n        challenge,\r\n        responses,\r\n        metadata,\r\n    })\r\n}\r\n\r\n/// Verify a zero-knowledge proof\r\n/// \r\n/// # Arguments\r\n/// * `statement` - The public statement\r\n/// * `proof` - The proof to verify\r\n/// \r\n/// # Returns\r\n/// `Ok(())` if proof is valid, error otherwise\r\n/// \r\n/// # Implementation\r\n/// 1. Validate proof structure\r\n/// 2. Recompute challenge and verify it matches\r\n/// 3. Verify proof equation (statement-type specific)\r\npub fn verify(statement: \u0026Statement, proof: \u0026Proof) -\u003e CryptoResult\u003c()\u003e {\r\n    // PHASE 1: Validate proof structure\r\n    proof.validate()?;\r\n    \r\n    // PHASE 2: Recompute challenge\r\n    let recomputed_challenge = compute_challenge(statement, \u0026proof.commitments)?;\r\n    \r\n    // Verify challenge matches (critical for security!)\r\n    if recomputed_challenge.value != proof.challenge.value {\r\n        return Err(CryptoError::VerificationError(\r\n            \"Challenge verification failed - possible tampering\".to_string(),\r\n        ));\r\n    }\r\n    \r\n    // PHASE 3: Verify responses (statement-type specific)\r\n    match \u0026statement.statement_type {\r\n        StatementType::DiscreteLog {\r\n            generator,\r\n            public_value,\r\n        } =\u003e {\r\n            if proof.commitments.is_empty() || proof.responses.is_empty() {\r\n                return Err(CryptoError::VerificationError(\r\n                    \"Invalid proof structure\".to_string(),\r\n                ));\r\n            }\r\n            \r\n            verify_discrete_log_proof(\r\n                generator,\r\n                public_value,\r\n                \u0026proof.commitments[0],\r\n                \u0026proof.challenge,\r\n                \u0026proof.responses[0],\r\n            )?;\r\n        }\r\n        StatementType::Preimage {\r\n            hash_function,\r\n            hash_output,\r\n        } =\u003e {\r\n            if proof.commitments.is_empty() || proof.responses.is_empty() {\r\n                return Err(CryptoError::VerificationError(\r\n                    \"Invalid proof structure\".to_string(),\r\n                ));\r\n            }\r\n            \r\n            verify_preimage_proof(\r\n                hash_function,\r\n                hash_output,\r\n                \u0026proof.commitments[0],\r\n                \u0026proof.challenge,\r\n                \u0026proof.responses[0],\r\n            )?;\r\n        }\r\n        StatementType::Range { .. } =\u003e {\r\n            return Err(CryptoError::VerificationError(\r\n                \"Range proofs not yet fully implemented\".to_string(),\r\n            ));\r\n        }\r\n        StatementType::Custom { .. } =\u003e {\r\n            return Err(CryptoError::VerificationError(\r\n                \"Custom statements not yet supported\".to_string(),\r\n            ));\r\n        }\r\n    }\r\n    \r\n    // PHASE 4: All checks passed\r\n    Ok(())\r\n}\r\n\r\n/// Compute Fiat-Shamir challenge\r\npub fn compute_challenge(statement: \u0026Statement, commitments: \u0026[Commitment]) -\u003e CryptoResult\u003cChallenge\u003e {\r\n    use sha3::{Digest, Sha3_256};\r\n\r\n    let mut hasher = Sha3_256::new();\r\n\r\n    // Hash statement\r\n    let stmt_bytes = statement.to_bytes()?;\r\n    hasher.update(\u0026stmt_bytes);\r\n\r\n    // Hash all commitments\r\n    for commitment in commitments {\r\n        hasher.update(\u0026commitment.value);\r\n    }\r\n\r\n    let hash_output = hasher.finalize();\r\n    let mut challenge_bytes = [0u8; 32];\r\n    challenge_bytes.copy_from_slice(\u0026hash_output);\r\n\r\n    Ok(Challenge {\r\n        value: challenge_bytes,\r\n    })\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_proof_structure() {\r\n        let proof = Proof {\r\n            commitments: vec![Commitment {\r\n                value: vec![1, 2, 3],\r\n            }],\r\n            challenge: Challenge { value: [0u8; 32] },\r\n            responses: vec![Response {\r\n                value: vec![4, 5, 6],\r\n            }],\r\n            metadata: ProofMetadata {\r\n                version: 1,\r\n                timestamp: 0,\r\n                size: 100,\r\n            },\r\n        };\r\n\r\n        assert!(proof.validate().is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn test_fiat_shamir_consistency() {\r\n        use crate::proof::statement::{HashFunction, StatementBuilder};\r\n\r\n        let stmt = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, vec![0u8; 32])\r\n            .build()\r\n            .unwrap();\r\n\r\n        let commitments = vec![Commitment {\r\n            value: vec![1, 2, 3],\r\n        }];\r\n\r\n        let c1 = compute_challenge(\u0026stmt, \u0026commitments).unwrap();\r\n        let c2 = compute_challenge(\u0026stmt, \u0026commitments).unwrap();\r\n\r\n        assert_eq!(c1.value, c2.value);\r\n    }\r\n\r\n    #[test]\r\n    fn test_discrete_log_proof_generation() {\r\n        use crate::proof::statement::StatementBuilder;\r\n        use num_bigint::BigUint;\r\n\r\n        // Create statement: prove knowledge of x where g^x = h\r\n        let generator = vec![2u8; 32];\r\n        let secret = vec![42u8; 32];\r\n        \r\n        // Compute public_value = generator^secret (mod p)\r\n        let modulus_bytes = vec![0xFF; 32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n        let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n        let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n\r\n        let statement = StatementBuilder::new()\r\n            .discrete_log(generator.clone(), public_value.clone())\r\n            .build()\r\n            .unwrap();\r\n\r\n        // Create witness with secret exponent\r\n        let witness = Witness::discrete_log(secret);\r\n\r\n        // Generate proof\r\n        let result = prove(\u0026statement, \u0026witness);\r\n        assert!(result.is_ok(), \"Proof generation should succeed\");\r\n\r\n        let proof = result.unwrap();\r\n        assert!(!proof.commitments.is_empty());\r\n        assert!(!proof.responses.is_empty());\r\n        assert_eq!(proof.metadata.version, 1);\r\n    }\r\n\r\n    #[test]\r\n    fn test_discrete_log_proof_verification() {\r\n        use crate::proof::statement::StatementBuilder;\r\n        use num_bigint::BigUint;\r\n\r\n        // Create statement with proper discrete log relationship\r\n        let generator = vec![2u8; 32];\r\n        let secret = vec![42u8; 32];\r\n        \r\n        // Compute public_value = generator^secret (mod p)\r\n        let modulus_bytes = vec![0xFF; 32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n        let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n        let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n\r\n        let statement = StatementBuilder::new()\r\n            .discrete_log(generator, public_value)\r\n            .build()\r\n            .unwrap();\r\n\r\n        // Create witness and generate proof\r\n        let witness = Witness::discrete_log(secret);\r\n        let proof = prove(\u0026statement, \u0026witness).unwrap();\r\n\r\n        // Verify proof\r\n        let result = verify(\u0026statement, \u0026proof);\r\n        assert!(result.is_ok(), \"Proof verification should succeed\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_preimage_proof_generation() {\r\n        use crate::proof::statement::{HashFunction, StatementBuilder};\r\n        use sha3::{Digest, Sha3_256};\r\n\r\n        // Create preimage and its hash\r\n        let preimage = b\"secret message\".to_vec();\r\n        let mut hasher = Sha3_256::new();\r\n        hasher.update(\u0026preimage);\r\n        let hash = hasher.finalize().to_vec();\r\n\r\n        // Create statement\r\n        let statement = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, hash)\r\n            .build()\r\n            .unwrap();\r\n\r\n        // Create witness\r\n        let witness = Witness::preimage(preimage);\r\n\r\n        // Generate proof\r\n        let result = prove(\u0026statement, \u0026witness);\r\n        assert!(result.is_ok(), \"Preimage proof generation should succeed\");\r\n\r\n        let proof = result.unwrap();\r\n        assert!(!proof.commitments.is_empty());\r\n        assert!(!proof.responses.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_preimage_proof_verification() {\r\n        use crate::proof::statement::{HashFunction, StatementBuilder};\r\n        use sha3::{Digest, Sha3_256};\r\n\r\n        // Create preimage and hash\r\n        let preimage = b\"secret message\".to_vec();\r\n        let mut hasher = Sha3_256::new();\r\n        hasher.update(\u0026preimage);\r\n        let hash = hasher.finalize().to_vec();\r\n\r\n        // Create statement and witness\r\n        let statement = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, hash)\r\n            .build()\r\n            .unwrap();\r\n        let witness = Witness::preimage(preimage);\r\n\r\n        // Generate and verify proof\r\n        let proof = prove(\u0026statement, \u0026witness).unwrap();\r\n        let result = verify(\u0026statement, \u0026proof);\r\n        \r\n        assert!(result.is_ok(), \"Preimage proof verification should succeed\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_proof_tampering_detection() {\r\n        use crate::proof::statement::StatementBuilder;\r\n        use num_bigint::BigUint;\r\n\r\n        // Generate original proof with correct discrete log relationship\r\n        let generator = vec![2u8; 32];\r\n        let secret = vec![42u8; 32];\r\n        \r\n        // Compute public_value = generator^secret (mod p)\r\n        let modulus_bytes = vec![0xFF; 32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n        let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n        let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n        \r\n        let statement = StatementBuilder::new()\r\n            .discrete_log(generator, public_value)\r\n            .build()\r\n            .unwrap();\r\n\r\n        let witness = Witness::discrete_log(secret);\r\n        let mut proof = prove(\u0026statement, \u0026witness).unwrap();\r\n\r\n        // Tamper with challenge\r\n        proof.challenge.value[0] ^= 0xFF;\r\n\r\n        // Verification should fail\r\n        let result = verify(\u0026statement, \u0026proof);\r\n        assert!(result.is_err(), \"Tampered proof should fail verification\");\r\n        \r\n        if let Err(e) = result {\r\n            match e {\r\n                CryptoError::VerificationError(msg) =\u003e {\r\n                    assert!(msg.contains(\"Challenge\"));\r\n                }\r\n                _ =\u003e panic!(\"Expected VerificationError\"),\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_invalid_witness_rejection() {\r\n        use crate::proof::statement::{HashFunction, StatementBuilder};\r\n        use sha3::{Digest, Sha3_256};\r\n\r\n        // Create statement with specific hash\r\n        let correct_preimage = b\"correct secret\".to_vec();\r\n        let mut hasher = Sha3_256::new();\r\n        hasher.update(\u0026correct_preimage);\r\n        let hash = hasher.finalize().to_vec();\r\n\r\n        let statement = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, hash)\r\n            .build()\r\n            .unwrap();\r\n\r\n        // Create witness with WRONG preimage\r\n        let wrong_preimage = b\"wrong secret\".to_vec();\r\n        let witness = Witness::preimage(wrong_preimage);\r\n\r\n        // Proof generation should fail (witness doesn't satisfy statement)\r\n        let result = prove(\u0026statement, \u0026witness);\r\n        assert!(result.is_err(), \"Invalid witness should be rejected\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_proof_soundness() {\r\n        use crate::proof::statement::StatementBuilder;\r\n        use num_bigint::BigUint;\r\n\r\n        let generator = vec![2u8; 32];\r\n        let modulus_bytes = vec![0xFF; 32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n        let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n\r\n        // Generate 5 different statements and prove each one correctly\r\n        for i in 1..=5 {\r\n            let secret = vec![i as u8; 32];\r\n            \r\n            // Compute correct public_value = generator^secret (mod p)\r\n            let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n            let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n            \r\n            let statement = StatementBuilder::new()\r\n                .discrete_log(generator.clone(), public_value)\r\n                .build()\r\n                .unwrap();\r\n            \r\n            let witness = Witness::discrete_log(secret);\r\n            \r\n            let proof_result = prove(\u0026statement, \u0026witness);\r\n            assert!(proof_result.is_ok(), \"Proof {} generation failed\", i);\r\n            \r\n            let proof = proof_result.unwrap();\r\n            let verify_result = verify(\u0026statement, \u0026proof);\r\n            assert!(verify_result.is_ok(), \"Proof {} verification failed\", i);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_proof_serialization() {\r\n        use crate::proof::statement::StatementBuilder;\r\n        use num_bigint::BigUint;\r\n\r\n        // Generate proof with correct discrete log relationship\r\n        let generator = vec![2u8; 32];\r\n        let secret = vec![42u8; 32];\r\n        \r\n        // Compute public_value = generator^secret (mod p)\r\n        let modulus_bytes = vec![0xFF; 32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n        let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n        let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n        \r\n        let statement = StatementBuilder::new()\r\n            .discrete_log(generator, public_value)\r\n            .build()\r\n            .unwrap();\r\n\r\n        let witness = Witness::discrete_log(secret);\r\n        let proof = prove(\u0026statement, \u0026witness).unwrap();\r\n\r\n        // Serialize\r\n        let bytes = proof.to_bytes().unwrap();\r\n        assert!(!bytes.is_empty());\r\n\r\n        // Deserialize\r\n        let deserialized = Proof::from_bytes(\u0026bytes).unwrap();\r\n\r\n        // Verify deserialized proof\r\n        let result = verify(\u0026statement, \u0026deserialized);\r\n        assert!(result.is_ok(), \"Deserialized proof should verify\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_proof_metadata() {\r\n        use crate::proof::statement::StatementBuilder;\r\n        use num_bigint::BigUint;\r\n\r\n        let generator = vec![2u8; 32];\r\n        let secret = vec![42u8; 32];\r\n        \r\n        // Compute public_value = generator^secret (mod p)\r\n        let modulus_bytes = vec![0xFF; 32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n        let secret_big = BigUint::from_bytes_be(\u0026secret);\r\n        let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n        \r\n        let statement = StatementBuilder::new()\r\n            .discrete_log(generator, public_value)\r\n            .build()\r\n            .unwrap();\r\n\r\n        let witness = Witness::discrete_log(secret);\r\n        let proof = prove(\u0026statement, \u0026witness).unwrap();\r\n\r\n        // Check metadata\r\n        assert_eq!(proof.metadata.version, 1);\r\n        assert!(proof.metadata.timestamp \u003e 0);\r\n        assert!(proof.metadata.size \u003e 0);\r\n        assert_eq!(proof.size(), proof.metadata.size);\r\n    }\r\n\r\n    #[test]\r\n    fn test_proof_validation_errors() {\r\n        let bad_proof_empty = Proof { commitments: vec![], challenge: Challenge { value: [0u8;32] }, responses: vec![Response{ value: vec![1]}], metadata: ProofMetadata{version:1,timestamp:0,size:0} };        \r\n        assert!(bad_proof_empty.validate().is_err());\r\n        let bad_proof_no_responses = Proof { commitments: vec![Commitment{ value: vec![1]}], challenge: Challenge { value: [0u8;32] }, responses: vec![], metadata: ProofMetadata{version:1,timestamp:0,size:0} };        \r\n        assert!(bad_proof_no_responses.validate().is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_discrete_log_commitment_tamper_failure() {\r\n        use crate::proof::statement::StatementBuilder; use num_bigint::BigUint;\r\n        let generator = vec![2u8;32]; let secret = vec![42u8;32];\r\n        let modulus_bytes = vec![0xFF;32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator); let secret_big = BigUint::from_bytes_be(\u0026secret); let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026secret_big,\u0026mod_big).to_bytes_be();\r\n        let statement = StatementBuilder::new().discrete_log(generator.clone(), public_value).build().unwrap();\r\n        let witness = Witness::discrete_log(secret);\r\n        let mut proof = prove(\u0026statement,\u0026witness).unwrap();\r\n        // tamper commitment (will cause challenge mismatch rather than equation failure)\r\n        proof.commitments[0].value[0] ^= 0xAA; // flip byte\r\n        let result = verify(\u0026statement,\u0026proof);\r\n        assert!(matches!(result, Err(CryptoError::VerificationError(msg)) if msg.contains(\"Challenge\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_discrete_log_response_tamper_failure() {\r\n        use crate::proof::statement::StatementBuilder; use num_bigint::BigUint;\r\n        let generator = vec![2u8;32]; let secret = vec![42u8;32];\r\n        let modulus_bytes = vec![0xFF;32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator); let secret_big = BigUint::from_bytes_be(\u0026secret); let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026secret_big,\u0026mod_big).to_bytes_be();\r\n        let statement = StatementBuilder::new().discrete_log(generator.clone(), public_value).build().unwrap();\r\n        let witness = Witness::discrete_log(secret);\r\n        let mut proof = prove(\u0026statement,\u0026witness).unwrap();\r\n        // Tamper response drastically (zero out bytes to force equation failure)\r\n        let len = proof.responses[0].value.len();\r\n        proof.responses[0].value = vec![0u8; len];\r\n        let result = verify(\u0026statement,\u0026proof);\r\n        assert!(result.is_err());\r\n        if let Err(CryptoError::VerificationError(msg)) = result { assert!(msg.contains(\"Discrete log\") || msg.contains(\"verification failed\")); } else { panic!(\"Expected VerificationError\"); }\r\n    }\r\n\r\n    #[test]\r\n    fn test_preimage_response_tamper_commitment_failure() {\r\n        use crate::proof::statement::{HashFunction, StatementBuilder}; use sha3::{Digest,Sha3_256};\r\n        let preimage = b\"secret msg\".to_vec(); let mut hasher = Sha3_256::new(); hasher.update(\u0026preimage); let hash = hasher.finalize().to_vec();\r\n        let statement = StatementBuilder::new().preimage(HashFunction::SHA3_256, hash).build().unwrap();\r\n        let witness = Witness::preimage(preimage);\r\n        let mut proof = prove(\u0026statement,\u0026witness).unwrap();\r\n        // Tamper response so recomputed blinding mismatches commitment\r\n        proof.responses[0].value[0] ^= 0xAA;\r\n        let result = verify(\u0026statement,\u0026proof);\r\n        assert!(matches!(result, Err(CryptoError::VerificationError(msg)) if msg.contains(\"commitment\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_truncated_proof_deserialization_failure() {\r\n        use crate::proof::statement::StatementBuilder; use num_bigint::BigUint;\r\n        let generator = vec![2u8;32]; let secret = vec![42u8;32];\r\n        let modulus_bytes = vec![0xFF;32]; let gen_big = BigUint::from_bytes_be(\u0026generator); let secret_big = BigUint::from_bytes_be(\u0026secret); let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes); let public_value = gen_big.modpow(\u0026secret_big,\u0026mod_big).to_bytes_be();\r\n        let statement = StatementBuilder::new().discrete_log(generator.clone(), public_value).build().unwrap();\r\n        let witness = Witness::discrete_log(secret);\r\n        let proof = prove(\u0026statement,\u0026witness).unwrap();\r\n        let bytes = proof.to_bytes().unwrap();\r\n        let truncated = \u0026bytes[..bytes.len()/4];\r\n        let result = Proof::from_bytes(truncated);\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_commitment_reordering_challenge_mismatch() {\r\n        use crate::proof::statement::StatementBuilder; use num_bigint::BigUint;\r\n        let generator = vec![2u8;32]; let secret = vec![42u8;32];\r\n        let modulus_bytes = vec![0xFF;32]; let gen_big = BigUint::from_bytes_be(\u0026generator); let secret_big = BigUint::from_bytes_be(\u0026secret); let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes); let public_value = gen_big.modpow(\u0026secret_big,\u0026mod_big).to_bytes_be();\r\n        let statement = StatementBuilder::new().discrete_log(generator.clone(), public_value).build().unwrap();\r\n        let witness = Witness::discrete_log(secret);\r\n        let mut proof = prove(\u0026statement,\u0026witness).unwrap();\r\n        // Duplicate commitment causing challenge mismatch\r\n        let first = proof.commitments[0].clone();\r\n        proof.commitments.push(first); // modifies commitment list\r\n        let result = verify(\u0026statement,\u0026proof);\r\n        assert!(matches!(result, Err(CryptoError::VerificationError(msg)) if msg.contains(\"Challenge\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_manual_blake3_preimage_verification_failure() {\r\n        use crate::proof::statement::{StatementBuilder, HashFunction};\r\n        // Build statement with Blake3 (unsupported in verify_preimage_proof)\r\n        let statement = StatementBuilder::new()\r\n            .preimage(HashFunction::Blake3, vec![1,2,3,4])\r\n            .build()\r\n            .unwrap();\r\n        // Manually fabricate a proof with one commitment/response and matching challenge\r\n        let commitments = vec![Commitment { value: vec![0xAA; 32] }];\r\n        let challenge = compute_challenge(\u0026statement,\u0026commitments).unwrap();\r\n        let responses = vec![Response { value: vec![0xBB; 32] }];\r\n        let proof = Proof { commitments, challenge, responses, metadata: ProofMetadata { version:1, timestamp:0, size:0 } };\r\n        let result = verify(\u0026statement,\u0026proof);\r\n        assert!(matches!(result, Err(CryptoError::VerificationError(msg)) if msg.contains(\"Blake3\")));\r\n    }\r\n}\r\n","traces":[{"line":56,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":57,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":58,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":60,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":63,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":67,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":68,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":75,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":76,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":81,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":95,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":96,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":97,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":98,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":103,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":104,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":136,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":137,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":138,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":140,"address":[],"length":0,"stats":{"Line":5404319552844595200}},{"line":141,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":145,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":147,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":148,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":158,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":160,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":162,"address":[],"length":0,"stats":{"Line":5404319552844595200}},{"line":164,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":168,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":172,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":173,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":174,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":176,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":184,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":189,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":190,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":191,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":194,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":196,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":200,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":205,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":206,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":207,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":208,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":212,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":220,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":227,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":228,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":231,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":232,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":233,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":234,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":238,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":239,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":240,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":241,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":245,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":246,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":247,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":251,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":252,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":254,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":255,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":261,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":272,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":273,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":274,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":275,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":280,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":282,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":283,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":284,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":294,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":299,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":300,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":301,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":309,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":336,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":338,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":339,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":340,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":346,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":348,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":349,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":350,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":353,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":374,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":377,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":378,"address":[],"length":0,"stats":{"Line":1080863910568919044}},{"line":379,"address":[],"length":0,"stats":{"Line":5404319552844595200}},{"line":382,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":393,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":397,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":398,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":401,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":402,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":403,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":404,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":405,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":422,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":424,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":427,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":430,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":431,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":432,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":437,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":439,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":440,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":442,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":450,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":451,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":452,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":453,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":457,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":458,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":460,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":468,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":469,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":470,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":471,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":491,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":494,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":497,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":498,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":501,"address":[],"length":0,"stats":{"Line":11745387828182253568}},{"line":502,"address":[],"length":0,"stats":{"Line":5908722711110090752}},{"line":505,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":506,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":507,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":509,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":510,"address":[],"length":0,"stats":{"Line":2882303761517117440}}],"covered":142,"coverable":177},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","proof","statement.rs"],"content":"//! Statement structures for zero-knowledge proofs\r\n//!\r\n//! A Statement represents the public claim being proven.\r\n\r\nuse crate::{CryptoError, CryptoResult};\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// Types of statements that can be proven\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub enum StatementType {\r\n    /// Prove knowledge of discrete log: g^x = h\r\n    DiscreteLog {\r\n        /// Generator\r\n        generator: Vec\u003cu8\u003e,\r\n        /// Public value\r\n        public_value: Vec\u003cu8\u003e,\r\n    },\r\n\r\n    /// Prove knowledge of hash preimage: H(x) = y\r\n    Preimage {\r\n        /// Hash function used\r\n        hash_function: HashFunction,\r\n        /// Hash output\r\n        hash_output: Vec\u003cu8\u003e,\r\n    },\r\n\r\n    /// Prove x ∈ [min, max] (range proof)\r\n    Range {\r\n        /// Minimum value\r\n        min: u64,\r\n        /// Maximum value\r\n        max: u64,\r\n        /// Commitment to value\r\n        commitment: Vec\u003cu8\u003e,\r\n    },\r\n\r\n    /// Custom statement (placeholder)\r\n    Custom {\r\n        /// Description\r\n        description: String,\r\n    },\r\n}\r\n\r\n/// Supported hash functions\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub enum HashFunction {\r\n    /// SHA3-256\r\n    SHA3_256,\r\n    /// SHA-256\r\n    SHA256,\r\n    /// BLAKE3\r\n    Blake3,\r\n}\r\n\r\n/// Complete statement for a zero-knowledge proof\r\n#[derive(Clone, Debug, Serialize, Deserialize)]\r\npub struct Statement {\r\n    /// Type and parameters of the statement\r\n    pub statement_type: StatementType,\r\n    /// Version for future compatibility\r\n    pub version: u8,\r\n}\r\n\r\nimpl Statement {\r\n    /// Validate statement consistency\r\n    pub fn validate(\u0026self) -\u003e CryptoResult\u003c()\u003e {\r\n        match \u0026self.statement_type {\r\n            StatementType::DiscreteLog { generator, public_value } =\u003e {\r\n                if generator.is_empty() || public_value.is_empty() {\r\n                    return Err(CryptoError::InvalidParameter(\r\n                        \"Discrete log statement requires non-empty values\".to_string(),\r\n                    ));\r\n                }\r\n            }\r\n            StatementType::Preimage { hash_output, .. } =\u003e {\r\n                if hash_output.is_empty() {\r\n                    return Err(CryptoError::InvalidParameter(\r\n                        \"Preimage statement requires non-empty hash\".to_string(),\r\n                    ));\r\n                }\r\n            }\r\n            StatementType::Range { min, max, .. } =\u003e {\r\n                if min \u003e= max {\r\n                    return Err(CryptoError::InvalidParameter(\r\n                        \"Range min must be less than max\".to_string(),\r\n                    ));\r\n                }\r\n            }\r\n            StatementType::Custom { .. } =\u003e {}\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    /// Serialize to bytes\r\n    pub fn to_bytes(\u0026self) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\r\n        bincode::serialize(self).map_err(|e| {\r\n            CryptoError::SerializationError(format!(\"Failed to serialize statement: {}\", e))\r\n        })\r\n    }\r\n\r\n    /// Deserialize from bytes\r\n    pub fn from_bytes(bytes: \u0026[u8]) -\u003e CryptoResult\u003cSelf\u003e {\r\n        bincode::deserialize(bytes).map_err(|e| {\r\n            CryptoError::SerializationError(format!(\"Failed to deserialize statement: {}\", e))\r\n        })\r\n    }\r\n\r\n    /// Compute hash of statement\r\n    pub fn hash(\u0026self) -\u003e CryptoResult\u003c[u8; 32]\u003e {\r\n        use sha3::{Digest, Sha3_256};\r\n\r\n        let bytes = self.to_bytes()?;\r\n        let mut hasher = Sha3_256::new();\r\n        hasher.update(\u0026bytes);\r\n        let result = hasher.finalize();\r\n\r\n        let mut hash = [0u8; 32];\r\n        hash.copy_from_slice(\u0026result);\r\n        Ok(hash)\r\n    }\r\n}\r\n\r\n/// Builder for constructing statements\r\npub struct StatementBuilder {\r\n    statement_type: Option\u003cStatementType\u003e,\r\n}\r\n\r\nimpl StatementBuilder {\r\n    /// Create a new statement builder\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            statement_type: None,\r\n        }\r\n    }\r\n\r\n    /// Build a discrete log statement\r\n    pub fn discrete_log(mut self, generator: Vec\u003cu8\u003e, public_value: Vec\u003cu8\u003e) -\u003e Self {\r\n        self.statement_type = Some(StatementType::DiscreteLog {\r\n            generator,\r\n            public_value,\r\n        });\r\n        self\r\n    }\r\n\r\n    /// Build a preimage statement\r\n    pub fn preimage(mut self, hash_function: HashFunction, hash_output: Vec\u003cu8\u003e) -\u003e Self {\r\n        self.statement_type = Some(StatementType::Preimage {\r\n            hash_function,\r\n            hash_output,\r\n        });\r\n        self\r\n    }\r\n\r\n    /// Build a range statement\r\n    pub fn range(mut self, min: u64, max: u64, commitment: Vec\u003cu8\u003e) -\u003e Self {\r\n        self.statement_type = Some(StatementType::Range {\r\n            min,\r\n            max,\r\n            commitment,\r\n        });\r\n        self\r\n    }\r\n\r\n    /// Build the statement\r\n    pub fn build(self) -\u003e CryptoResult\u003cStatement\u003e {\r\n        let statement_type = self.statement_type.ok_or_else(|| {\r\n            CryptoError::InvalidParameter(\"Statement type not set\".to_string())\r\n        })?;\r\n\r\n        let statement = Statement {\r\n            statement_type,\r\n            version: 1,\r\n        };\r\n\r\n        statement.validate()?;\r\n        Ok(statement)\r\n    }\r\n}\r\n\r\nimpl Default for StatementBuilder {\r\n    fn default() -\u003e Self {\r\n        Self::new()\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_statement_builder() {\r\n        let stmt = StatementBuilder::new()\r\n            .discrete_log(vec![1, 2, 3], vec![4, 5, 6])\r\n            .build()\r\n            .unwrap();\r\n\r\n        assert!(matches!(stmt.statement_type, StatementType::DiscreteLog { .. }));\r\n    }\r\n\r\n    #[test]\r\n    fn test_statement_serialization() {\r\n        let stmt = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, vec![0u8; 32])\r\n            .build()\r\n            .unwrap();\r\n\r\n        let bytes = stmt.to_bytes().unwrap();\r\n        let recovered = Statement::from_bytes(\u0026bytes).unwrap();\r\n\r\n        assert_eq!(stmt.version, recovered.version);\r\n    }\r\n\r\n    #[test]\r\n    fn test_invalid_discrete_log_statement() {\r\n        let result = StatementBuilder::new()\r\n            .discrete_log(vec![], vec![1,2,3])\r\n            .build();\r\n        assert!(result.is_err());\r\n        let result2 = StatementBuilder::new()\r\n            .discrete_log(vec![1,2,3], vec![])\r\n            .build();\r\n        assert!(result2.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_invalid_preimage_statement_empty_hash() {\r\n        let result = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, vec![])\r\n            .build();\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_invalid_range_statement_min_greater_equal_max() {\r\n        let result = StatementBuilder::new()\r\n            .range(10, 10, vec![0u8;32])\r\n            .build();\r\n        assert!(result.is_err());\r\n        let result2 = StatementBuilder::new()\r\n            .range(20, 10, vec![0u8;32])\r\n            .build();\r\n        assert!(result2.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_builder_missing_type_rejection() {\r\n        let builder = StatementBuilder::new();\r\n        let result = builder.build();\r\n        assert!(result.is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_statement_hash_length() {\r\n        let stmt = StatementBuilder::new()\r\n            .discrete_log(vec![1,2,3], vec![4,5,6])\r\n            .build()\r\n            .unwrap();\r\n        let hash = stmt.hash().unwrap();\r\n        assert_eq!(hash.len(), 32);\r\n    }\r\n}\r\n","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":67,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":68,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":69,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":70,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":75,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":76,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":77,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":78,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":82,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":83,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":84,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":85,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":95,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":96,"address":[],"length":0,"stats":{"Line":9079256848778919936}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":103,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":112,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":113,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":114,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":115,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":117,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":118,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":119,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":130,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":137,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":138,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":139,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":140,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":142,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":146,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":147,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":148,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":149,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":151,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":155,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":156,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":157,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":158,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":159,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":161,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":165,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":166,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":167,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":175,"address":[],"length":0,"stats":{"Line":5404319552844595200}},{"line":176,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}}],"covered":49,"coverable":54},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","proof","witness.rs"],"content":"//! Witness structures for zero-knowledge proofs\r\n//!\r\n//! A Witness represents the SECRET knowledge that proves a statement.\r\n//! This must NEVER be transmitted or stored insecurely.\r\n\r\nuse crate::proof::statement::{HashFunction, Statement, StatementType};\r\nuse zeroize::{Zeroize, ZeroizeOnDrop};\r\n\r\n/// Witness type indicator\r\n#[derive(Clone, Debug)]\r\npub enum WitnessType {\r\n    /// Discrete logarithm witness\r\n    DiscreteLog,\r\n    /// Hash preimage witness\r\n    Preimage,\r\n    /// Range proof witness\r\n    Range,\r\n    /// Custom witness\r\n    Custom,\r\n}\r\n\r\n/// Secret data for different witness types\r\n#[derive(Zeroize, ZeroizeOnDrop)]\r\nenum SecretData {\r\n    /// Discrete log witness: the exponent x where g^x = h\r\n    DiscreteLog(Vec\u003cu8\u003e),\r\n\r\n    /// Preimage witness: x where H(x) = y\r\n    Preimage(Vec\u003cu8\u003e),\r\n\r\n    /// Range proof witness: (value, blinding_factor)\r\n    Range { value: u64, blinding: Vec\u003cu8\u003e },\r\n\r\n    /// Custom witness data\r\n    Custom(Vec\u003cu8\u003e),\r\n}\r\n\r\n/// Witness structure\r\n/// \r\n/// Note: SecretData implements ZeroizeOnDrop to secure sensitive data\r\npub struct Witness {\r\n    /// The secret data (automatically zeroized via ZeroizeOnDrop)\r\n    secret_data: SecretData,\r\n    /// Randomness used in proof\r\n    randomness: Vec\u003cu8\u003e,\r\n    /// Type indicator\r\n    witness_type: WitnessType,\r\n}\r\n\r\nimpl Witness {\r\n    /// Create witness for discrete log proof\r\n    pub fn discrete_log(exponent: Vec\u003cu8\u003e) -\u003e Self {\r\n        let mut randomness = vec![0u8; 32];\r\n        rand::Rng::fill(\u0026mut rand::thread_rng(), \u0026mut randomness[..]);\r\n\r\n        Self {\r\n            secret_data: SecretData::DiscreteLog(exponent),\r\n            randomness,\r\n            witness_type: WitnessType::DiscreteLog,\r\n        }\r\n    }\r\n\r\n    /// Create witness for hash preimage proof\r\n    pub fn preimage(preimage: Vec\u003cu8\u003e) -\u003e Self {\r\n        let mut randomness = vec![0u8; 32];\r\n        rand::Rng::fill(\u0026mut rand::thread_rng(), \u0026mut randomness[..]);\r\n\r\n        Self {\r\n            secret_data: SecretData::Preimage(preimage),\r\n            randomness,\r\n            witness_type: WitnessType::Preimage,\r\n        }\r\n    }\r\n\r\n    /// Create witness for range proof\r\n    pub fn range(value: u64, blinding: Vec\u003cu8\u003e) -\u003e Self {\r\n        let mut randomness = vec![0u8; 32];\r\n        rand::Rng::fill(\u0026mut rand::thread_rng(), \u0026mut randomness[..]);\r\n\r\n        Self {\r\n            secret_data: SecretData::Range { value, blinding },\r\n            randomness,\r\n            witness_type: WitnessType::Range,\r\n        }\r\n    }\r\n\r\n    /// Validate witness satisfies the statement\r\n    pub fn satisfies_statement(\u0026self, statement: \u0026Statement) -\u003e bool {\r\n        match (\u0026self.secret_data, \u0026statement.statement_type) {\r\n            (SecretData::Preimage(pre), StatementType::Preimage { hash_function, hash_output }) =\u003e {\r\n                self.verify_preimage(hash_function, pre, hash_output)\r\n            }\r\n            (SecretData::DiscreteLog(secret), StatementType::DiscreteLog { generator, public_value }) =\u003e {\r\n                // Verify that generator^secret = public_value (mod p)\r\n                use num_bigint::BigUint;\r\n                \r\n                let modulus_bytes = vec![0xFF; 32];\r\n                let gen_big = BigUint::from_bytes_be(generator);\r\n                let secret_big = BigUint::from_bytes_be(secret);\r\n                let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n                let public_big = BigUint::from_bytes_be(public_value);\r\n                \r\n                let computed = gen_big.modpow(\u0026secret_big, \u0026mod_big);\r\n                computed == public_big\r\n            }\r\n            (\r\n                SecretData::Range { value, .. },\r\n                StatementType::Range {\r\n                    min,\r\n                    max,\r\n                    commitment: _,\r\n                },\r\n            ) =\u003e *value \u003e= *min \u0026\u0026 *value \u003c= *max,\r\n            _ =\u003e false,\r\n        }\r\n    }\r\n\r\n    /// Get witness type\r\n    pub fn witness_type(\u0026self) -\u003e \u0026WitnessType {\r\n        \u0026self.witness_type\r\n    }\r\n\r\n    /// Access randomness (used in proof generation)\r\n    pub(crate) fn randomness(\u0026self) -\u003e \u0026[u8] {\r\n        \u0026self.randomness\r\n    }\r\n\r\n    /// Get secret bytes for proof generation\r\n    /// \r\n    /// This is used internally by the proof system.\r\n    /// Should never be exposed outside the proof module.\r\n    pub(crate) fn get_secret_bytes(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e, \u0026'static str\u003e {\r\n        match \u0026self.secret_data {\r\n            SecretData::DiscreteLog(bytes) =\u003e Ok(bytes.clone()),\r\n            SecretData::Preimage(bytes) =\u003e Ok(bytes.clone()),\r\n            SecretData::Range { value, blinding } =\u003e {\r\n                // For range proofs, combine value and blinding\r\n                let mut result = value.to_be_bytes().to_vec();\r\n                result.extend_from_slice(blinding);\r\n                Ok(result)\r\n            }\r\n            SecretData::Custom(bytes) =\u003e Ok(bytes.clone()),\r\n        }\r\n    }\r\n\r\n    /// Verify hash preimage\r\n    fn verify_preimage(\r\n        \u0026self,\r\n        hash_fn: \u0026HashFunction,\r\n        preimage: \u0026[u8],\r\n        expected_hash: \u0026[u8],\r\n    ) -\u003e bool {\r\n        use sha3::{Digest, Sha3_256};\r\n\r\n        let actual_hash = match hash_fn {\r\n            HashFunction::SHA3_256 =\u003e {\r\n                let mut hasher = Sha3_256::new();\r\n                hasher.update(preimage);\r\n                hasher.finalize().to_vec()\r\n            }\r\n            _ =\u003e return false,\r\n        };\r\n\r\n        constant_time_eq(\u0026actual_hash, expected_hash)\r\n    }\r\n\r\n    /// Securely destroy witness\r\n    pub fn destroy(self) {\r\n        // Drop is called automatically, which triggers zeroization\r\n        drop(self);\r\n    }\r\n}\r\n\r\n/// Constant-time byte array equality\r\nfn constant_time_eq(a: \u0026[u8], b: \u0026[u8]) -\u003e bool {\r\n    if a.len() != b.len() {\r\n        return false;\r\n    }\r\n\r\n    let mut result = 0u8;\r\n    for (x, y) in a.iter().zip(b.iter()) {\r\n        result |= x ^ y;\r\n    }\r\n\r\n    result == 0\r\n}\r\n\r\n// Drop is automatically implemented by ZeroizeOnDrop derive\r\n// which handles secure zeroization of all fields\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::proof::StatementBuilder;\r\n\r\n    #[test]\r\n    fn test_preimage_witness() {\r\n        use sha3::{Digest, Sha3_256};\r\n\r\n        let preimage = b\"secret message\";\r\n        let hash = Sha3_256::digest(preimage).to_vec();\r\n\r\n        let witness = Witness::preimage(preimage.to_vec());\r\n        let statement = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, hash)\r\n            .build()\r\n            .unwrap();\r\n\r\n        assert!(witness.satisfies_statement(\u0026statement));\r\n    }\r\n\r\n    #[test]\r\n    fn test_constant_time_equality() {\r\n        let a = vec![1, 2, 3, 4];\r\n        let b = vec![1, 2, 3, 4];\r\n        let c = vec![1, 2, 3, 5];\r\n\r\n        assert!(constant_time_eq(\u0026a, \u0026b));\r\n        assert!(!constant_time_eq(\u0026a, \u0026c));\r\n    }\r\n\r\n    #[test]\r\n    fn test_witness_types() {\r\n        let witness = Witness::discrete_log(vec![1, 2, 3]);\r\n        assert!(matches!(witness.witness_type(), \u0026WitnessType::DiscreteLog));\r\n\r\n        let witness = Witness::preimage(vec![4, 5, 6]);\r\n        assert!(matches!(witness.witness_type(), \u0026WitnessType::Preimage));\r\n    }\r\n\r\n    #[test]\r\n    fn test_discrete_log_witness_mismatch() {\r\n        use num_bigint::BigUint;\r\n        let generator = vec![2u8;32];\r\n        let secret = vec![5u8;32];\r\n        // public_value computed with different secret to force mismatch\r\n        let wrong_secret = vec![7u8;32];\r\n        let modulus_bytes = vec![0xFF;32];\r\n        let gen_big = BigUint::from_bytes_be(\u0026generator);\r\n        let wrong_big = BigUint::from_bytes_be(\u0026wrong_secret);\r\n        let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n        let public_value = gen_big.modpow(\u0026wrong_big, \u0026mod_big).to_bytes_be();\r\n        let statement = StatementBuilder::new()\r\n            .discrete_log(generator.clone(), public_value)\r\n            .build()\r\n            .unwrap();\r\n        let witness = Witness::discrete_log(secret);\r\n        assert!(!witness.satisfies_statement(\u0026statement));\r\n    }\r\n\r\n    #[test]\r\n    fn test_preimage_witness_mismatch() {\r\n        use sha3::{Digest, Sha3_256};\r\n        let preimage = b\"correct\".to_vec();\r\n        let mut hasher = Sha3_256::new(); hasher.update(\u0026preimage); let hash = hasher.finalize().to_vec();\r\n        let statement = StatementBuilder::new()\r\n            .preimage(HashFunction::SHA3_256, hash)\r\n            .build()\r\n            .unwrap();\r\n        let wrong_witness = Witness::preimage(b\"wrong\".to_vec());\r\n        assert!(!wrong_witness.satisfies_statement(\u0026statement));\r\n    }\r\n\r\n    #[test]\r\n    fn test_range_witness_out_of_range() {\r\n        let statement = StatementBuilder::new()\r\n            .range(10, 20, vec![0u8;32])\r\n            .build()\r\n            .unwrap();\r\n        let witness = Witness::range(25, vec![1,2,3]);\r\n        assert!(!witness.satisfies_statement(\u0026statement));\r\n    }\r\n}\r\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":53,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":54,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":57,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":64,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":65,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":66,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":69,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":76,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":77,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":78,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":81,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":88,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":89,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":90,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":91,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":93,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":97,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":98,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":99,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":100,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":101,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":103,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":104,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":109,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":110,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":113,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":120,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":133,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":134,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":155,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":157,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":158,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":159,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":176,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":181,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":182,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":185,"address":[],"length":0,"stats":{"Line":720575940379279360}}],"covered":45,"coverable":58},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","utils","math.rs"],"content":"//! Mathematical primitives\r\n//!\r\n//! Common mathematical operations for cryptography.\r\n\r\nuse crate::{CryptoError, CryptoResult};\r\n\r\n/// Modular exponentiation: base^exp mod modulus\r\npub fn modular_exponentiation(_base: \u0026[u8], _exp: \u0026[u8], _modulus: u64) -\u003e CryptoResult\u003cVec\u003cu8\u003e\u003e {\r\n    // TODO: Implement efficient modular exponentiation\r\n    // For now, return a placeholder\r\n    Err(CryptoError::MathError(\r\n        \"Not yet implemented\".to_string(),\r\n    ))\r\n}\r\n\r\n/// Modular multiplicative inverse: find x such that (a * x) mod m = 1\r\npub fn mod_inverse(a: i64, m: i64) -\u003e CryptoResult\u003ci64\u003e {\r\n    // Extended Euclidean algorithm\r\n    let (mut old_r, mut r) = (a, m);\r\n    let (mut old_s, mut s) = (1i64, 0i64);\r\n\r\n    while r != 0 {\r\n        let quotient = old_r / r;\r\n        let temp_r = r;\r\n        r = old_r - quotient * r;\r\n        old_r = temp_r;\r\n\r\n        let temp_s = s;\r\n        s = old_s - quotient * s;\r\n        old_s = temp_s;\r\n    }\r\n\r\n    if old_r \u003e 1 {\r\n        return Err(CryptoError::MathError(format!(\r\n            \"{} has no inverse mod {}\",\r\n            a, m\r\n        )));\r\n    }\r\n\r\n    if old_s \u003c 0 {\r\n        old_s += m;\r\n    }\r\n\r\n    Ok(old_s)\r\n}\r\n\r\n/// Greatest common divisor\r\npub fn gcd(mut a: i64, mut b: i64) -\u003e i64 {\r\n    while b != 0 {\r\n        let temp = b;\r\n        b = a % b;\r\n        a = temp;\r\n    }\r\n    a.abs()\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_gcd() {\r\n        assert_eq!(gcd(48, 18), 6);\r\n        assert_eq!(gcd(17, 5), 1);\r\n        assert_eq!(gcd(100, 50), 50);\r\n    }\r\n\r\n    #[test]\r\n    fn test_mod_inverse() {\r\n        // 3 * 5 = 15 ≡ 1 (mod 7)\r\n        let inv = mod_inverse(3, 7).unwrap();\r\n        assert_eq!((3 * inv) % 7, 1);\r\n\r\n        // 2 has no inverse mod 6 (not coprime)\r\n        assert!(mod_inverse(2, 6).is_err());\r\n    }\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":19,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":20,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":22,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":23,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":24,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":25,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":26,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":28,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":29,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":30,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":33,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":34,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":36,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":40,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":41,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":44,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":48,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":49,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":50,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":51,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":52,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":54,"address":[],"length":0,"stats":{"Line":432345564227567616}}],"covered":24,"coverable":27},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","src","utils","mod.rs"],"content":"//! Utility functions and mathematical primitives\r\n//!\r\n//! This module provides common utility functions used throughout the library.\r\n\r\npub mod math;\r\n\r\n// Re-export common functions\r\npub use math::{mod_inverse, modular_exponentiation};\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","tests","comprehensive_tests.rs"],"content":"//! Comprehensive test suite for nexuszero-crypto\r\n//!\r\n//! This module provides extensive testing including:\r\n//! - Correctness tests for all security levels\r\n//! - Property-based testing with proptest\r\n//! - Security property verification\r\n//! - Edge case testing\r\n\r\nuse nexuszero_crypto::lattice::*;\r\nuse proptest::prelude::*;\r\n\r\n#[cfg(test)]\r\nmod correctness_tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_lwe_correctness_across_security_levels() {\r\n        use rand::thread_rng;\r\n        \r\n        // Test all three security levels\r\n        let params_128 = lwe::LWEParameters::new(512, 1024, 12289, 3.2);\r\n        let params_192 = lwe::LWEParameters::new(1024, 2048, 40961, 3.2);\r\n        let params_256 = lwe::LWEParameters::new(2048, 4096, 65537, 3.2);\r\n\r\n        for params in [params_128, params_192, params_256] {\r\n            let mut rng = thread_rng();\r\n            let (sk, pk) = lwe::keygen(\u0026params, \u0026mut rng).unwrap();\r\n\r\n            // Test 10 rounds with both true and false\r\n            for message_bit in [true, false] {\r\n                let ct = lwe::encrypt(\u0026pk, message_bit, \u0026params, \u0026mut rng).unwrap();\r\n                assert_eq!(\r\n                    lwe::decrypt(\u0026sk, \u0026ct, \u0026params).unwrap(),\r\n                    message_bit,\r\n                    \"Failed at n={}, message={}\", params.n, message_bit\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_lwe_encryption_randomness() {\r\n        use rand::thread_rng;\r\n        \r\n        let params = lwe::LWEParameters::new(512, 1024, 12289, 3.2);\r\n        let mut rng = thread_rng();\r\n        let (sk, pk) = lwe::keygen(\u0026params, \u0026mut rng).unwrap();\r\n\r\n        let ct1 = lwe::encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n        let ct2 = lwe::encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n\r\n        // Ciphertexts should be different (probabilistic encryption)\r\n        assert_ne!(ct1.v, ct2.v, \"Encryption should be randomized\");\r\n\r\n        // But both should decrypt to the same value\r\n        assert_eq!(lwe::decrypt(\u0026sk, \u0026ct1, \u0026params).unwrap(), true);\r\n        assert_eq!(lwe::decrypt(\u0026sk, \u0026ct2, \u0026params).unwrap(), true);\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_polynomial_operations() {\r\n        let modulus = 17;\r\n        let a = ring_lwe::Polynomial::from_coeffs(vec![1, 2, 3, 4], modulus);\r\n        let b = ring_lwe::Polynomial::from_coeffs(vec![5, 6, 7, 8], modulus);\r\n\r\n        let sum = ring_lwe::poly_add(\u0026a, \u0026b, modulus);\r\n        assert_eq!(sum.coeffs[0], 6);\r\n        assert_eq!(sum.coeffs[1], 8);\r\n\r\n        let diff = ring_lwe::poly_sub(\u0026a, \u0026b, modulus);\r\n        assert_eq!(diff.coeffs[0], (1i64 - 5).rem_euclid(modulus as i64));\r\n\r\n        let scaled = ring_lwe::poly_scalar_mult(\u0026a, 2, modulus);\r\n        assert_eq!(scaled.coeffs[0], 2);\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_ntt_correctness() {\r\n        let params = ring_lwe::RingLWEParameters::new_128bit_security();\r\n\r\n        // Create a test polynomial\r\n        for _ in 0..3 {\r\n            let coeffs: Vec\u003ci64\u003e = (0..params.n).map(|i| (i % params.q as usize) as i64).collect();\r\n            let poly = ring_lwe::Polynomial::from_coeffs(coeffs.clone(), params.q);\r\n\r\n            // Transform forward and back (we need the primitive root)\r\n            let primitive_root = 3; // For modulus 12289\r\n            let ntt_poly = ring_lwe::ntt(\u0026poly, params.q, primitive_root);\r\n            let recovered = ring_lwe::intt(\u0026ntt_poly, params.n, params.q, primitive_root);\r\n\r\n            // Check coefficients are recovered (may differ by scaling)\r\n            assert_eq!(poly.coeffs.len(), recovered.coeffs.len(), \"NTT should preserve degree\");\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_ring_lwe_encryption_correctness() {\r\n        let security_levels = [\r\n            ring_lwe::RingLWEParameters::new_128bit_security(),\r\n            ring_lwe::RingLWEParameters::new_192bit_security(),\r\n            ring_lwe::RingLWEParameters::new_256bit_security(),\r\n        ];\r\n\r\n        for params in \u0026security_levels {\r\n            let (sk, pk) = ring_lwe::ring_keygen(params).unwrap();\r\n\r\n            for msg_bool in [true, false] {\r\n                let message = vec![msg_bool];\r\n                let ciphertext = ring_lwe::ring_encrypt(\u0026pk, \u0026message, params).unwrap();\r\n                let decrypted = ring_lwe::ring_decrypt(\u0026sk, \u0026ciphertext, params).unwrap();\r\n\r\n                // Ring-LWE decodes all n coefficients, check first one matches message\r\n                assert!(decrypted.len() \u003e= 1, \"Should decrypt at least one bit\");\r\n                assert_eq!(decrypted[0], msg_bool,\r\n                    \"Failed to recover message {:?} at security level n={}\", msg_bool, params.n);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod property_based_tests {\r\n    use super::*;\r\n\r\n    proptest! {\r\n        #[test]\r\n        fn prop_lwe_encryption_decryption(message_bit in any::\u003cbool\u003e()) {\r\n            use rand::thread_rng;\r\n            \r\n            let params = lwe::LWEParameters::new(256, 512, 12289, 3.2);\r\n            let mut rng = thread_rng();\r\n            let (sk, pk) = lwe::keygen(\u0026params, \u0026mut rng).unwrap();\r\n\r\n            let ciphertext = lwe::encrypt(\u0026pk, message_bit, \u0026params, \u0026mut rng).unwrap();\r\n            let decrypted = lwe::decrypt(\u0026sk, \u0026ciphertext, \u0026params).unwrap();\r\n\r\n            prop_assert_eq!(decrypted, message_bit);\r\n        }\r\n\r\n        #[test]\r\n        fn prop_polynomial_addition_commutative(a in prop::collection::vec(0i64..17, 4), b in prop::collection::vec(0i64..17, 4)) {\r\n            let modulus = 17;\r\n            let poly_a = ring_lwe::Polynomial::from_coeffs(a, modulus);\r\n            let poly_b = ring_lwe::Polynomial::from_coeffs(b, modulus);\r\n\r\n            let sum1 = ring_lwe::poly_add(\u0026poly_a, \u0026poly_b, modulus);\r\n            let sum2 = ring_lwe::poly_add(\u0026poly_b, \u0026poly_a, modulus);\r\n\r\n            prop_assert_eq!(sum1.coeffs, sum2.coeffs);\r\n        }\r\n\r\n        #[test]\r\n        fn prop_polynomial_addition_associative(\r\n            a in prop::collection::vec(0i64..17, 4),\r\n            b in prop::collection::vec(0i64..17, 4),\r\n            c in prop::collection::vec(0i64..17, 4)\r\n        ) {\r\n            let modulus = 17;\r\n            let poly_a = ring_lwe::Polynomial::from_coeffs(a, modulus);\r\n            let poly_b = ring_lwe::Polynomial::from_coeffs(b, modulus);\r\n            let poly_c = ring_lwe::Polynomial::from_coeffs(c, modulus);\r\n\r\n            let sum1 = ring_lwe::poly_add(\u0026ring_lwe::poly_add(\u0026poly_a, \u0026poly_b, modulus), \u0026poly_c, modulus);\r\n            let sum2 = ring_lwe::poly_add(\u0026poly_a, \u0026ring_lwe::poly_add(\u0026poly_b, \u0026poly_c, modulus), modulus);\r\n\r\n            prop_assert_eq!(sum1.coeffs, sum2.coeffs);\r\n        }\r\n\r\n        #[test]\r\n        fn prop_ring_lwe_message_recovery(msg in any::\u003cbool\u003e()) {\r\n            let params = ring_lwe::RingLWEParameters::new_128bit_security();\r\n            let (sk, pk) = ring_lwe::ring_keygen(\u0026params).unwrap();\r\n\r\n            let message = vec![msg];\r\n            let ciphertext = ring_lwe::ring_encrypt(\u0026pk, \u0026message, \u0026params).unwrap();\r\n            let decrypted = ring_lwe::ring_decrypt(\u0026sk, \u0026ciphertext, \u0026params).unwrap();\r\n\r\n            // Ring-LWE decodes all n coefficients, check first one matches\r\n            prop_assert!(decrypted.len() \u003e= 1);\r\n            prop_assert_eq!(decrypted[0], message[0]);\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod security_tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_zeroization() {\r\n        use rand::thread_rng;\r\n        \r\n        // Test that secret keys can be inspected (zeroization would require ndarray support)\r\n        let params = lwe::LWEParameters::new(256, 512, 12289, 3.2);\r\n        let mut rng = thread_rng();\r\n        let (sk, _pk) = lwe::keygen(\u0026params, \u0026mut rng).unwrap();\r\n        \r\n        // Store original values\r\n        let has_nonzero = sk.s.iter().any(|\u0026x| x != 0);\r\n        assert!(has_nonzero, \"Secret key should have non-zero values\");\r\n        \r\n        // Verify secret key has expected properties\r\n        assert_eq!(sk.s.len(), params.n, \"Secret key should have correct dimension\");\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod edge_case_tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_empty_polynomial() {\r\n        let poly = ring_lwe::Polynomial::zero(4, 17);\r\n        assert_eq!(poly.coeffs.len(), 4);\r\n        assert!(poly.coeffs.iter().all(|\u0026x| x == 0));\r\n    }\r\n\r\n    #[test]\r\n    fn test_polynomial_zero_addition() {\r\n        let modulus = 17;\r\n        let poly = ring_lwe::Polynomial::from_coeffs(vec![1, 2, 3, 4], modulus);\r\n        let zero = ring_lwe::Polynomial::zero(4, modulus);\r\n\r\n        let result = ring_lwe::poly_add(\u0026poly, \u0026zero, modulus);\r\n        assert_eq!(result.coeffs, poly.coeffs);\r\n    }\r\n\r\n    #[test]\r\n    fn test_larger_dimension() {\r\n        use rand::thread_rng;\r\n        \r\n        // Test with larger dimension instead of large modulus\r\n        let params = lwe::LWEParameters::new(256, 512, 12289, 3.2);\r\n        let mut rng = thread_rng();\r\n        \r\n        // Should handle larger dimensions\r\n        let result = lwe::keygen(\u0026params, \u0026mut rng);\r\n        assert!(result.is_ok(), \"Should handle larger dimensions\");\r\n        \r\n        let (sk, pk) = result.unwrap();\r\n        let ct = lwe::encrypt(\u0026pk, true, \u0026params, \u0026mut rng).unwrap();\r\n        let pt = lwe::decrypt(\u0026sk, \u0026ct, \u0026params).unwrap();\r\n        assert_eq!(pt, true, \"Should correctly encrypt/decrypt with larger dimensions\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_zero_message_encryption() {\r\n        use rand::thread_rng;\r\n        \r\n        let params = lwe::LWEParameters::new(256, 512, 12289, 3.2);\r\n        let mut rng = thread_rng();\r\n        let (sk, pk) = lwe::keygen(\u0026params, \u0026mut rng).unwrap();\r\n\r\n        let ciphertext = lwe::encrypt(\u0026pk, false, \u0026params, \u0026mut rng).unwrap();\r\n        let decrypted = lwe::decrypt(\u0026sk, \u0026ciphertext, \u0026params).unwrap();\r\n\r\n        assert_eq!(decrypted, false);\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","tests","integration_tests.rs"],"content":"//! Integration tests for nexuszero-crypto\r\n\r\nuse nexuszero_crypto::lattice::lwe::{LWEParameters, keygen, encrypt, decrypt};\r\nuse nexuszero_crypto::{CryptoParameters, SecurityLevel};\r\n\r\n#[test]\r\nfn test_lwe_integration() {\r\n    let params = LWEParameters::new(32, 64, 97, 2.0);\r\n    let mut rng = rand::thread_rng();\r\n\r\n    let (sk, pk) = keygen(\u0026params, \u0026mut rng).unwrap();\r\n\r\n    let message = true;\r\n    let ciphertext = encrypt(\u0026pk, message, \u0026params, \u0026mut rng).unwrap();\r\n    let decrypted = decrypt(\u0026sk, \u0026ciphertext, \u0026params).unwrap();\r\n\r\n    assert_eq!(message, decrypted);\r\n}\r\n\r\n#[test]\r\nfn test_security_parameters() {\r\n    let params_128 = CryptoParameters::new_128bit_security();\r\n    assert_eq!(params_128.security_level, SecurityLevel::Bit128);\r\n\r\n    let params_192 = CryptoParameters::new_192bit_security();\r\n    assert_eq!(params_192.security_level, SecurityLevel::Bit192);\r\n\r\n    let params_256 = CryptoParameters::new_256bit_security();\r\n    assert_eq!(params_256.security_level, SecurityLevel::Bit256);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","sgbil","Nexuszero-Protocol","nexuszero-crypto","tests","test_vector_runner.rs"],"content":"/// Unified Test Vector Runner\r\n/// Adapts to nested JSON schemas for LWE, Ring-LWE, and Proof vectors.\r\nuse nexuszero_crypto::lattice::lwe::*;\r\nuse nexuszero_crypto::lattice::ring_lwe::*;\r\nuse nexuszero_crypto::proof::proof::*;\r\nuse nexuszero_crypto::proof::statement::*;\r\nuse nexuszero_crypto::proof::witness::*;\r\nuse serde::Deserialize;\r\nuse std::fs;\r\nuse rand::thread_rng;\r\nuse sha3::{Digest, Sha3_256};\r\n\r\n#[derive(Debug, Deserialize)]\r\nstruct GenericVectors\u003cT\u003e { vectors: Vec\u003cT\u003e }\r\n\r\n// LWE schema\r\n#[derive(Debug, Deserialize)]\r\nstruct LWEParametersJson { dimension: usize, modulus: u64, sigma: f64 }\r\n#[derive(Debug, Deserialize)]\r\nstruct LWETestCaseJson { plaintext_bit: u8, decryption_result: Option\u003cu8\u003e }\r\n#[derive(Debug, Deserialize)]\r\nstruct LWEVectorJson { name: String, security_level: u32, parameters: LWEParametersJson, test_cases: Vec\u003cLWETestCaseJson\u003e }\r\n\r\n// Ring-LWE schema\r\n#[derive(Debug, Deserialize)]\r\nstruct RingLWEParametersJson { degree: usize, modulus: u64, sigma: f64 }\r\n#[derive(Debug, Deserialize)]\r\nstruct EncryptionTestJson { message: Vec\u003cu8\u003e }\r\n#[derive(Debug, Deserialize)]\r\nstruct PolynomialTestJson { operation: Option\u003cString\u003e, poly_a: Option\u003cVec\u003ci64\u003e\u003e, poly_b: Option\u003cVec\u003ci64\u003e\u003e, expected: Option\u003cVec\u003ci64\u003e\u003e }\r\n#[derive(Debug, Deserialize)]\r\nstruct RingLWEVectorJson { name: String, security_level: u32, parameters: RingLWEParametersJson, encryption_tests: Option\u003cVec\u003cEncryptionTestJson\u003e\u003e, polynomial_tests: Option\u003cVec\u003cPolynomialTestJson\u003e\u003e }\r\n\r\n// Proof schema\r\n#[derive(Debug, Deserialize, Clone)]\r\nstruct ProofVectorJson { name: String }\r\n\r\n#[test]\r\nfn test_lwe_vectors() {\r\n    let json_data = fs::read_to_string(\"tests/test_vectors/lwe_test_vectors.json\").expect(\"read LWE vectors\");\r\n    let suite: GenericVectors\u003cLWEVectorJson\u003e = serde_json::from_str(\u0026json_data).expect(\"parse LWE vectors\");\r\n    for vector in \u0026suite.vectors {\r\n        let p = \u0026vector.parameters;\r\n        let m = p.dimension * 2; // derive samples\r\n        let params = LWEParameters::new(p.dimension, m, p.modulus, p.sigma);\r\n        let mut rng = thread_rng();\r\n        let (sk, pk) = keygen(\u0026params, \u0026mut rng).expect(\"keygen\");\r\n        for case in \u0026vector.test_cases {\r\n            let bit = case.plaintext_bit != 0;\r\n            let ct = encrypt(\u0026pk, bit, \u0026params, \u0026mut rng).expect(\"encrypt\");\r\n            let dec = decrypt(\u0026sk, \u0026ct, \u0026params).expect(\"decrypt\");\r\n            if let Some(expected) = case.decryption_result { assert_eq!(dec, expected != 0); } else { assert_eq!(dec, bit); }\r\n        }\r\n    }\r\n    println!(\"✓ LWE vectors OK\");\r\n}\r\n\r\n#[test]\r\nfn test_ring_lwe_vectors() {\r\n    let json_data = fs::read_to_string(\"tests/test_vectors/ring_lwe_test_vectors.json\").expect(\"read Ring-LWE vectors\");\r\n    let suite: GenericVectors\u003cRingLWEVectorJson\u003e = serde_json::from_str(\u0026json_data).expect(\"parse Ring-LWE vectors\");\r\n    for vector in \u0026suite.vectors {\r\n        let p = \u0026vector.parameters;\r\n        let params = RingLWEParameters::new(p.degree, p.modulus, p.sigma);\r\n        let (sk, pk) = ring_keygen(\u0026params).expect(\"ring keygen\");\r\n        if let Some(enc_tests) = \u0026vector.encryption_tests {\r\n            for t in enc_tests {\r\n                let bits: Vec\u003cbool\u003e = t.message.iter().map(|b| (b \u0026 1)==1).collect();\r\n                let ct = ring_encrypt(\u0026pk, \u0026bits, \u0026params).expect(\"ring encrypt\");\r\n                let dec = ring_decrypt(\u0026sk, \u0026ct, \u0026params).expect(\"ring decrypt\");\r\n                if !bits.is_empty() { assert_eq!(dec[0], bits[0]); }\r\n            }\r\n        }\r\n        if let Some(poly_tests) = \u0026vector.polynomial_tests {\r\n            for pt in poly_tests {\r\n                if pt.operation.as_deref() == Some(\"addition\") {\r\n                    if let (Some(a), Some(b), Some(exp)) = (\u0026pt.poly_a, \u0026pt.poly_b, \u0026pt.expected) {\r\n                        let pa = Polynomial { coeffs: a.clone(), modulus: p.modulus, degree: a.len() };\r\n                        let pb = Polynomial { coeffs: b.clone(), modulus: p.modulus, degree: b.len() };\r\n                        let sum = poly_add(\u0026pa, \u0026pb, p.modulus);\r\n                        for (i, e) in exp.iter().enumerate() { if i \u003c sum.coeffs.len() { assert_eq!(sum.coeffs[i], *e); } }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    println!(\"✓ Ring-LWE vectors OK\");\r\n}\r\n\r\n#[test]\r\nfn test_proof_vectors() {\r\n    let json_data = fs::read_to_string(\"tests/test_vectors/proof_test_vectors.json\").expect(\"read proof vectors\");\r\n    let suite: GenericVectors\u003cProofVectorJson\u003e = serde_json::from_str(\u0026json_data).expect(\"parse proof vectors\");\r\n    for vector in \u0026suite.vectors {\r\n        if vector.name.contains(\"Discrete-Log\") {\r\n            let generator = vec![2u8; 32];\r\n            let secret = vec![42u8; 32];\r\n            use num_bigint::BigUint; let modulus_bytes = vec![0xFF; 32];\r\n            let gen_big = BigUint::from_bytes_be(\u0026generator); let secret_big = BigUint::from_bytes_be(\u0026secret); let mod_big = BigUint::from_bytes_be(\u0026modulus_bytes);\r\n            let public_value = gen_big.modpow(\u0026secret_big, \u0026mod_big).to_bytes_be();\r\n            let statement = StatementBuilder::new().discrete_log(generator, public_value).build().expect(\"statement\");\r\n            let witness = Witness::discrete_log(secret);\r\n            let proof = prove(\u0026statement, \u0026witness).expect(\"prove\");\r\n            verify(\u0026statement, \u0026proof).expect(\"verify\");\r\n        } else if vector.name.contains(\"Preimage\") {\r\n            let preimage = b\"test_message\".to_vec(); let mut hasher = Sha3_256::new(); hasher.update(\u0026preimage); let hash = hasher.finalize().to_vec();\r\n            let statement = StatementBuilder::new().preimage(HashFunction::SHA3_256, hash).build().expect(\"preimage statement\");\r\n            let witness = Witness::preimage(preimage);\r\n            let proof = prove(\u0026statement, \u0026witness).expect(\"prove preimage\");\r\n            verify(\u0026statement, \u0026proof).expect(\"verify preimage\");\r\n        } else if vector.name.contains(\"Serialization\") {\r\n            let preimage = b\"serialization\".to_vec(); let mut hasher = Sha3_256::new(); hasher.update(\u0026preimage); let hash = hasher.finalize().to_vec();\r\n            let statement = StatementBuilder::new().preimage(HashFunction::SHA3_256, hash).build().expect(\"ser statement\");\r\n            let witness = Witness::preimage(preimage);\r\n            let proof = prove(\u0026statement, \u0026witness).expect(\"prove ser\");\r\n            let bytes = proof.to_bytes().expect(\"serialize\");\r\n            let restored = Proof::from_bytes(\u0026bytes).expect(\"deserialize\");\r\n            verify(\u0026statement, \u0026restored).expect(\"verify restored\");\r\n        }\r\n    }\r\n    println!(\"✓ Proof vectors OK\");\r\n}\r\n\r\n#[test]\r\nfn test_polynomial_operations_from_vectors() {\r\n    let json_data = fs::read_to_string(\"tests/test_vectors/ring_lwe_test_vectors.json\").expect(\"read Ring-LWE vectors\");\r\n    let suite: GenericVectors\u003cRingLWEVectorJson\u003e = serde_json::from_str(\u0026json_data).expect(\"parse Ring-LWE vectors\");\r\n    for vector in \u0026suite.vectors { let p=\u0026vector.parameters; if p.degree.is_power_of_two() { if let Some(root)=find_primitive_root(p.degree,p.modulus){ let poly=Polynomial{coeffs:vec![1i64;8],modulus:p.modulus,degree:8}; let t=ntt(\u0026poly,p.modulus,root); assert_eq!(t.len(),poly.coeffs.len()); } } }\r\n    println!(\"✓ Polynomial ops OK\");\r\n}\r\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, '🌙'),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e(
        'code',
        {
          className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        },
        line,
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '🌙';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '☀️';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '🌙';
    }
  });
})();
</script>
</body>
</html>